stone game vii alice bob take turns playing alice starting there stones arranged each they can remove either leftmost stone or rightmost stone row receive points equal sum remaining values winner one higher score when there no stones left bob found always lose this game always so decided minimize goal maximize difference array integers stones where represents value ith stone difference alice score they both play stones alice removes gets alice bob stones bob removes gets alice bob stones alice removes gets alice bob stones bob removes gets alice bob stones alice removes gets alice bob stones score difference stones
check if point is reachable there exists infinitely large currently point need reach point using finite one can move point any one following y two integers targetx targety representing your final true can reach point using some false targetx targety false impossible reach using any sequence so false targetx targety true can follow path targety
search in rotated sorted array ii there integer array nums sorted order necessarily distinct before being passed your nums rotated unknown pivot index k k such resulting array might rotated pivot index become array nums after rotation integer true target or false not must decrease overall operation steps much nums target true nums target false nums guaranteed rotated some target follow this problem similar search rotated sorted but nums may contain would this affect runtime how
replace non-coprime numbers in array array integers perform following find any two adjacent numbers nums no such numbers stop delete two numbers replace them their lcm common repeat this process long keep finding two adjacent final modified can shown replacing adjacent numbers any arbitrary order lead same test cases generated such values final array less than or equal two values x y where greatest common divisor x nums nums nums nums nums there no more adjacent numbers final modified array note there other ways obtain same resultant nums nums nums nums there no more adjacent numbers final modified array note there other ways obtain same resultant test cases generated such values final array less than or equal
maximum height by stacking cuboids cuboids where dimensions ith cuboid choose subset cuboids place them each can place cuboid i cuboid j widthi widthj lengthi lengthj heighti can rearrange any dimensions rotating put another maximum height stacked cuboids cuboid placed bottom side facing down height cuboid placed next side facing down height cuboid placed next side facing down height total height cuboids place any cuboids we choose cuboid rotate so side facing down height cuboids after rearranging can see all cuboids have same can place side down all cuboids so their heights maximum height stacked cuboids heighti
remove palindromic subsequences string s consisting only letters single step can remove one palindromic subsequence minimum steps make string string subsequence string generated deleting some characters string without changing note subsequence does not necessarily need string called palindrome one reads same backward well s s already so entirety can removed single s remove palindromic subsequence then s remove palindromic subsequence then either or
find k-th smallest pair distance distance pair integers b defined absolute difference between integer array nums integer kth smallest distance among all pairs where i j nums k here all then smallest distance pair distance nums k nums k k
maximal score after applying k operations integer array nums integer have starting score one choose index i such i increase your score replace maximum possible score can attain after applying exactly k ceiling function least integer greater than or equal nums k apply operation each array element exactly final score nums k can do following operation select i so nums becomes your score increases operation select i so nums becomes your score increases operation select i so nums becomes your score increases final score k
range sum of sorted subarray sums array nums consisting positive computed sum all continuous subarrays array then sorted them creating new array sum numbers index left index right new since answer can huge modulo nums left right all subarray sums after sorting them order we have new array sum numbers index le ri nums left right array same we have new array sum numbers index le ri nums left right left right
maximum product of the length of two palindromic substrings string s tasked finding two palindromic substrings odd length such product their lengths more want choose four integers l such i j k l both substrings palindromes have odd denotes substring index i index j maximum possible product lengths two palindromic palindrome string same forward substring contiguous sequence characters s substrings palindromes odd product s substrings palindromes odd product s consists lowercase english
maximum average pass ratio there school classes students each class having final integer array where know beforehand ith there totali total but only passi students pass also integer there another extrastudents brilliant students guaranteed pass exam any class they assigned want assign each extrastudents students class way maximizes average pass ratio across all pass ratio class equal students class pass exam divided total students average pass ratio sum pass ratios all classes divided maximum possible average pass ratio after assigning extrastudents answers within actual answer classes extrastudents can assign two extra students first average pass ratio equal classes extrastudents passi totali extrastudents
two out of three three integer arrays distinct array containing all values present least two out three may values any values present least two arrays all three values present least two arrays no value present least two
stamping the sequence two strings stamp there string s length all one can place stamp over s replace every letter s corresponding letter stamp target then s one turn place stamp index s obtain place stamp index s obtain or place stamp index s obtain note stamp must fully contained boundaries s order stamp cannot place stamp index we want convert s target using most array index letter being stamped each we cannot obtain target s within empty stamp target initially s place stamp index get place stamp index get would also accepted well some other stamp target initially s place stamp index get place stamp index get place stamp index get stamp target consist lowercase english
find score of an array after marking all elements array nums consisting positive starting score apply following choose smallest integer array not there choose one smallest add value chosen integer mark chosen element two adjacent elements they repeat until all array elements score get after applying above nums we mark elements smallest unmarked so we mark two adjacent smallest unmarked so we mark left adjacent only remaining unmarked so we mark our score nums we mark elements smallest unmarked so we mark two adjacent smallest unmarked since there two we choose so we mark one index right adjacent only remaining unmarked so we mark our score
frequency of the most frequent element frequency element times occurs integer array nums integer one can choose index nums increment element index maximum possible frequency element after performing most k nums k increment first element three times second element two times make nums frequency nums k there multiple optimal increment first element three times make nums frequency increment second element four times make nums frequency increment third element five times make nums frequency nums k k
basic calculator ii string s which represents evaluate this expression integer division should truncate toward may assume expression always all intermediate results range not allowed use any function which evaluates strings mathematical such s s s s consists integers operators separated some s represents valid all integers expression integers range answer guaranteed fit
smallest value after replacing with sum of prime factors positive integer continuously replace sum prime note prime factor divides multiple should included sum many times divides smallest value take so replace so replace so replace smallest value take smallest value take
swap salary sql schema salary column name type id int name varchar sex enum salary int id primary key this sex column enum value type table contains information about write sql query swap all values change all values vice single update statement no intermediate temporary note must write single update do not write any select statement this query result format following salary id name sex salary m b f c m d f id name sex salary f b m c f d m changed changed
subsequence with the minimum score two strings s allowed remove any characters string score string no characters removed string let left minimum index among all removed let right maximum index among all removed then score string right left minimum possible score make t subsequence subsequence string new string formed original string deleting some characters without disturbing relative positions remaining subsequence while s t this we remove character index string t becomes which subsequence string score can proven minimum score we can s t this we remove characters indices string t becomes which subsequence string score can proven minimum score we can s t consist only lowercase english
even odd tree binary tree named meets following root binary tree level index children level index their children level index every all nodes level have odd integer values strictly increasing order left every all nodes level have even integer values strictly decreasing order left root binary true binary tree otherwise root true node values each level level level level level since levels all odd increasing levels all even tree root false node values each level level level level node values level must strictly increasing so tree not root false node values level should even nodes tree range
binary tree inorder traversal root binary inorder traversal root root root nodes tree range follow recursive solution could do
find lucky integer in an array array integers lucky integer integer frequency array equal largest lucky integer there no lucky integer arr only lucky array because arr all lucky largest arr there no lucky numbers
binary tree cameras root binary we install cameras tree nodes where each camera node can monitor immediate minimum cameras needed monitor all nodes root one camera enough monitor all nodes placed root least two cameras needed monitor all nodes above image shows one valid configurations camera nodes tree range
132 pattern array integers pattern subsequence three integers such i j k true there pattern nums false there no pattern nums true there pattern nums true there three patterns
find all possible recipes from given supplies have information about different string array recipes string array ith recipe name can create have all needed ingredients ingredients recipe may need created other may contain string also string array supplies containing all ingredients initially have infinite supply all list all recipes can may answer any note two recipes may contain each other their recipes ingredients supplies we can create since we have ingredients recipes ingredients supplies we can create since we have ingredients we can create since we have ingredient can create ingredient recipes ingredients supplies we can create since we have ingredients we can create since we have ingredient can create ingredient we can create since we have ingredient can create ingredients consist only lowercase english all values recipes supplies combined each does not contain any duplicate
merge k sorted lists array k each sorted ascending merge all into one sorted lists merging them into one sorted lists lists k k sorted ascending sum not exceed
prime arrangements permutations so prime numbers prime indices integer prime only greater than cannot written product two positive integers both smaller than since answer may answer modulo valid but not because prime index
minimum amount of time to collect garbage array strings garbage where represents assortment garbage ith consists only characters representing one unit paper glass garbage picking up one unit any type garbage takes also integer array travel where minutes needed go house i house i there three garbage trucks each responsible picking up one type each garbage truck starts house must visit each house they do not need visit every only one garbage truck may used any while one truck driving or picking up other two trucks cannot do minimum minutes needed pick up all garbage travel paper garbage travels house house collects paper garbage house travels house house collects paper garbage house takes minutes pick up all paper glass garbage collects glass garbage house travels house house travels house house collects glass garbage house travels house house collects glass garbage house takes minutes pick up all glass since there no metal we do not need consider metal garbage takes total minutes collect all garbage travel metal garbage truck takes minutes pick up all metal paper garbage truck takes minutes pick up all paper glass garbage truck takes minutes pick up all glass takes total minutes collect all consists only letters
stone game viii alice bob take turns playing alice starting there stones arranged each while stones more than they do choose integer x remove leftmost x stones add sum removed values place new whose value equal left side game stops when only one stone left score difference between alice bob score goal maximize score goal minimize score integer array stones length where represents value ith stone score difference between alice bob they both play stones alice removes first adds her places stone value stones bob removes first adds his places stone value stones difference between their scores stones alice removes all adds her places stone value stones difference between their scores stones alice can only make one which remove both she adds her score places stone value stones difference between their scores
find the punishment number of an integer positive integer punishment punishment defined sum squares all integers i such i decimal representation i i can partitioned into contiguous substrings such sum integer values these substrings equals there exactly integers i satisfy conditions since since can partitioned into since can partitioned into punishment there exactly integers i satisfy conditions since since can partitioned into since can partitioned into since can partitioned into punishment
most stones removed with same row or column we place stones some integer coordinate each coordinate point may have most one stone can removed shares either same row or same column another stone not been array stones length where represents location ith largest possible stones can stones one way remove stones remove stone because shares same row remove stone because shares same column remove stone because shares same row remove stone because shares same column remove stone because shares same row stone cannot removed since does not share another stone still stones one way make moves remove stone because shares same row remove stone because shares same column remove stone because shares same row stones cannot removed since they do not share another stone still stones only stone so cannot remove yi no two stones same coordinate
combination sum array distinct integers candidates target integer list all unique combinations candidates where chosen numbers sum may combinations any same may chosen candidates unlimited two combinations unique frequency least one chosen numbers test cases generated such unique combinations sum up target less than combinations candidates target note can used multiple these only two candidates target candidates target all elements candidates target
x of a kind in a deck of cards integer array deck where represents written ith partition cards into one or more groups such each group exactly x cards where x all cards one group have same integer written true such partition or false deck true possible partition deck false no possible
find good days to rob the bank gang thieves planning robbing integer array where guards duty ith days numbered starting also integer ith day good day rob bank there least time days before after ith guards bank time days before i guards bank time days after i more this means day i good day rob bank only time time list all days good days rob order days returned does not security time day we have day we have no other days satisfy this so days only good days rob security time since time equals every day good day rob so every security time no day days before have no day good day rob so empty time
number of recent calls have recentcounter class which counts recent requests within certain time implement recentcounter initializes counter zero recent int adds new request time where t represents some time returns requests happened past milliseconds new requests have happened inclusive range guaranteed every call ping uses strictly larger value t than previous input output explanation recentcounter recentcounter new requests range requests range requests range requests range t each test case call ping strictly increasing values most calls made
grid illumination there grid size x where each cell this grid lamp initially turned array lamp positions where indicates lamp turned even same lamp listed more than turned when lamp turned illuminates cell all other cells same or also another array where jth determine whether illuminated or after answering jth turn off lamp adjacent lamps they lamp adjacent cell shares either side or corner array integers where should cell jth query or lamp lamps queries we have initial grid all lamps turned above picture we see grid after turning lamp then turning lamp query asks lamp illuminated or not blue so set we turn off all lamps red query asks lamp illuminated or not blue not so set we turn off all lamps red lamps queries lamps queries coli colj
rank transform of a matrix m x new matrix answer where rank rank integer represents how large element compared other calculated using following rank integer starting two elements p q same row or p q then p q then p q then rank should small test cases generated so answer unique under matrix rank because smallest integer row rank because rank rank because rank rank because both rank matrix matrix m
smallest string starting from leaf root binary tree where each node value range representing letters lexicographically smallest string starts leaf this tree ends any shorter prefix string lexicographically lexicographically smaller than leaf node node no root root root nodes tree range
minimum cost of buying candies with discount shop selling candies every two candies shop gives third candy customer can choose any candy take away free long cost chosen candy less than or equal minimum cost two candies there candies costs customer buys candies costs they can take candy cost but not candy cost integer array where denotes cost ith minimum cost buying all cost we buy candies costs take candy cost total cost buying all candies this only way we can buy note we cannot buy candies costs then take candy cost cost free candy less than or equal minimum cost purchased cost way which we can get minimum cost described buy candies costs take candy cost free we buy candies costs take last remaining candy cost free minimum cost buy all candies cost since there only we buy both there not third candy we can take minimum cost buy all candies
projection area of 3d shapes x grid where we place some x x cubes z each value v represents tower v cubes placed top cell we view projection these cubes onto zx projection like maps our figure we viewing when looking cubes total area all three grid here three projections shape made each grid grid
remove max number of edges to keep graph fully traversable alice bob have undirected graph nodes three types type can traversed alice type can traversed bob type can traversed both alice array edges where represents bidirectional edge type typei between nodes ui find maximum edges can remove so after removing graph can still fully traversed both alice graph fully traversed alice bob starting any they can reach all other maximum edges can or alice bob cannot fully traverse edges we remove edges graph still fully traversable alice removing any additional edge not make so maximum edges we can remove edges notice removing any edge not make graph fully traversable alice edges current alice cannot reach node other bob cannot reach therefore impossible make graph fully typei ui vi all tuples
same tree roots two binary trees p write function check they same or two binary trees considered same they structurally nodes have same p q true p q false p q false nodes both trees range
number of good paths there tree undirected graph no consisting nodes numbered exactly integer array vals length where denotes value ith also integer array edges where denotes there exists undirected edge connecting nodes ai good path simple path satisfies following starting node ending node have same all nodes between starting node ending node have values less than or equal starting node starting value should maximum value along distinct good note path reverse counted same considered same single node also considered valid vals edges there good paths consisting single there additional good reverse path treated same note not good path because vals edges there good paths consisting single there additional good vals edges tree consists only one so there one good bi ai bi edges represents valid
minimum cost to change the final value of expression valid boolean expression string expression consisting characters or not valid while valid minimum cost change final value expression value we want apply operations so new expression evaluates cost changing final value expression operations performed types operations described turn into turn into turn into turn into does not take precedence over order evaluate parentheses then expression we can turn into changing using new expression evaluates expression we can turn into using new expression evaluates expression we can turn into using new expression evaluates expression only contains all parentheses properly there no empty parentheses not substring
median of two sorted arrays two sorted arrays size m median two sorted overall run time complexity should merged array median merged array median m m m
check if matrix is x-matrix square matrix said both following conditions all elements diagonals matrix all other elements integer array grid size x representing square true grid grid true refer diagram should have green elements red elements grid grid false refer diagram should have green elements red elements grid not
balance a binary search tree root binary search balanced binary search tree same node there more than one any binary search tree balanced depth two subtrees every node never differs more than root this not only correct also root nodes tree range
maximum product after k increments array integers nums integer one may choose any element nums increment maximum product nums after most k since answer may very modulo note should maximize product before taking nums k increment first now nums product can shown maximum product so we note there may other ways increment nums have maximum nums k increment second time increment fourth now nums product can shown maximum product so we note there may other ways increment nums have maximum k
check if an original string exists given two encoded strings original consisting lowercase english can encoded following arbitrarily split into sequence some arbitrarily choose some elements replace each length numeric concatenate sequence encoded one way encode original string might split choose second third elements replaced their sequence becomes concatenate elements sequence get encoded two encoded strings consisting lowercase english letters digits true there exists original string could encoded both test cases generated such consecutive digits does not exceed true possible original do not replace any element which which true possible original which which false original string encoded must start letter original string encoded must start letter consist digits lowercase english letters consecutive digits does not exceed
online majority element in subarray design data structure efficiently finds majority element majority element subarray element occurs threshold times or more implementing majoritychecker initializes instance class array int int int returns element subarray occurs least threshold or no such element input output explanation majoritychecker majoritychecker new left right threshold right left threshold right left most calls made
design underground system underground railway system keeping track customer travel times between different they using this data calculate average time takes travel one station implement undergroundsystem void string int customer card id equal checks station stationname time customer can only checked into one place void string int customer card id equal checks out station stationname time double string returns average time takes travel startstation average time computed all previous traveling times startstation endstation happened meaning check startstation followed check out time takes travel startstation endstation may different time takes travel endstation there least one customer traveled startstation endstation before getaveragetime may assume all calls checkin checkout methods customer checks time then checks out time then all events happen chronological input output explanation undergroundsystem undergroundsystem new customer customer customer one trip two trips customer three trips input output explanation undergroundsystem undergroundsystem new customer customer customer t all strings consist uppercase lowercase english letters there most calls total answers within actual value
alert using same key-card three or more times in a one hour period leetcode company workers use unlock office each time worker uses their security system saves name time when system emits alert any worker uses three or more times list strings keyname keytime where corresponds name time when their used single access times time format such list unique worker names who received alert frequent keycard sort names ascending order notice considered within while not considered within keyname keytime used keycard times period keyname keytime used keycard times period format contains only lowercase english
last stone weight ii array integers stones where weight ith we playing game each we choose any two stones smash them suppose stones have weights x y x result this smash x both stones x stone weight x stone weight y new weight y end there most one stone smallest possible weight left there no stones stones we can combine get so array converts we can combine get so array converts we can combine get so array converts we can combine get so array converts then optimal stones
find elements in a contaminated binary tree binary tree following x then x x then x now binary tree which means all have been changed implement findelements initializes object contaminated binary tree recovers bool returns true target value exists recovered binary input output explanation findelements findelements new false true input output explanation findelements findelements new true true false input output explanation findelements findelements new true false false true height binary tree less than or equal total nodes between total calls between target
maximum points you can obtain from cards there several cards arranged each card associated points integer array one can take one card beginning or end have take exactly k your score sum points cards have integer array cardpoints integer maximum score can cardpoints k after first your score always choosing rightmost card first maximize your total optimal strategy take three cards giving final score cardpoints k regardless which two cards your score always cardpoints k have take all your score sum points all k
reverse pairs integer array reverse pairs reverse pair pair i j nums reverse pairs nums reverse pairs
range frequency queries design data structure find frequency value frequency value subarray occurrences value implement rangefreqquery constructs instance class integer array int int int returns frequency value subarray subarray contiguous sequence elements within denotes subarray contains elements nums between indices left right input output explanation rangefreqquery rangefreqquery new value occurs time subarray value occurs times whole value left right most calls made query
maximum sum of an hourglass m x integer matrix we define hourglass part matrix following maximum sum elements note hourglass cannot rotated must entirely contained within grid cells shown above represent hourglass maximum grid there only one hourglass m
rotate function integer array nums length assume arrk array obtained rotating nums k positions we define rotation function f nums maximum value test cases generated so answer fits nums so maximum value nums
k-th symbol in grammar we build table rows we start writing now every subsequent we look previous row replace each occurrence each occurrence row row row two integer kth symbol nth row table k row k row row k row row k
best time to buy and sell stock ii integer array prices where price stock ith each may decide buy sell can only hold most one share stock any can buy then immediately sell same find maximum profit can prices buy day sell day profit then buy day sell day profit total profit prices buy day sell day profit total profit prices there no way make positive so we never buy stock achieve maximum profit
find latest group of size m array arr represents permutation numbers have binary string size initially all bits set each step i both binary string arr bit position set also integer find latest step which there exists group ones length group ones contiguous substring such cannot extended either latest step which there exists group ones length exactly no such group arr m step step step step step latest step which there exists group size step arr m step step step step step no group size exists during any m all integers arr
minimum number of operations to make array continuous integer array one can replace any element nums any nums considered continuous both following conditions all elements nums difference between maximum element minimum element nums equals nums but nums not minimum operations make nums nums nums already nums one possible solution change last element resulting array which nums one possible solution change second element change third element change fourth element resulting array which
detect capital we define usage capitals word right when one following cases all letters this word like all letters this word not like only first letter this word like string true usage capitals word true word false word consists lowercase uppercase english
minimum time difference list clock time points minimum minutes difference between any two timepoints timepoints format
binary tree paths root binary all paths any leaf node no root root nodes tree range
find median from data stream median middle value ordered integer size list there no middle median mean two middle arr median arr median implement medianfinder initializes medianfinder void adds integer num data stream data double returns median all elements so answers within actual answer input output explanation medianfinder medianfinder new arr arr num there least one element data structure before calling most calls made addnum follow all integer numbers stream range how would optimize your all integer numbers stream range how would optimize your
rabbits in forest there forest unknown we asked rabbits many rabbits have same color collected answers integer array answers where answer ith array minimum rabbits could answers two rabbits answered could both same say rabbit answered red or answers would say rabbit answered then there should other blue rabbits forest answer into smallest possible rabbits forest therefore answered plus answers
number of times binary string is prefix-aligned have binary string length where all bits we flip all bits this binary string change them one integer array flips where indicates bit index i flipped ith binary string after ith all bits inclusive range ones all other bits times binary string during flipping flips binary string initially after applying step string becomes which not after applying step string becomes which not after applying step string becomes which not after applying step string becomes which after applying step string becomes which we can see string so we flips binary string initially after applying step string becomes which not after applying step string becomes which not after applying step string becomes which not after applying step string becomes which we can see string so we flips permutation integers range
lucky numbers in a matrix m x matrix distinct all lucky numbers matrix any lucky element matrix such minimum element row maximum matrix only lucky since minimum row maximum matrix only lucky since minimum row maximum matrix only lucky since minimum row maximum m m all elements matrix
k divisible elements subarrays integer array nums two integers k distinct subarrays which have most k elements divisible two arrays said distinct they different or there exists least one index i where subarray defined contiguous sequence elements nums k p elements indices divisible p distinct subarrays which have most k elements divisible note subarrays occur more than once but they should each counted only subarray should not counted because elements divisible nums k p all element nums divisible p every subarray nums have most elements divisible since all subarrays total subarrays satisfying all constraints p k follow can solve this problem time
number of ways to paint n × 3 grid have grid size x want paint each cell grid exactly one three or green while making sure no two adjacent cells have same color no two cells share vertical or horizontal sides have same rows ways can paint this answer may grow answer must computed modulo there possible way paint grid
palindrome partitioning iii string s containing lowercase letters integer need change some characters s other lowercase english then divide s into k disjoint substrings such each substring minimal characters need change divide s k can split string into change character make s k can split string into all them s k k s only contains lowercase english
maximum number of robots within budget have two integer chargetimes both length ith robot costs units charge costs units also integer total cost running k chosen robots equal k where largest charge cost among k robots sum running costs among k maximum consecutive robots can run such total cost does not exceed chargetimes runningcosts budget possible run all individual consecutive pairs robots within obtain answer consider first total cost which less than can shown not possible run more than consecutive robots within so we chargetimes runningcosts budget no robot can run does not exceed so we budget
sum in a matrix integer array your score perform following operations until matrix becomes each row select largest remove case does not matter which identify highest amongst all those removed step add your final nums first we remove we then add our we remove we add our we remove we add our our final score nums we remove add we
self crossing array integers start point move meters then meters meters meters so other after each your direction changes true your path crosses itself or false does distance true path crosses itself point distance false path does not cross itself any distance true path crosses itself point
word ladder transformation sequence word beginword word endword using dictionary wordlist sequence words beginword sk such every adjacent pair words differs single every si i k note beginword does not need sk endword two beginword dictionary words shortest transformation sequence beginword or no such sequence beginword endword wordlist one shortest transformation sequence which words beginword endword wordlist endword not therefore there no valid transformation consist lowercase english beginword endword all words wordlist
minimum cost tree from leaf values array arr positive consider all binary trees such each node either or values arr correspond values each leaf traversal value each node equal product largest leaf value left right among all possible binary trees smallest possible sum values each guaranteed this sum fits into node leaf only zero arr there two possible trees first node sum second node sum arr guaranteed answer fits into signed integer less than
expressive words sometimes people repeat letters represent extra these strings like we have groups adjacent letters all string s array query strings query word stretchy can made equal s any applications following extension choose group consisting characters add some characters c group so size group three or starting we could do extension group get but we cannot get since group size less than we could do another extension like get s then query word would stretchy because these two extension query query strings s words we can extend word get we extend get because group not size or s words s consist lowercase
avoid flood in the city your country infinite all lakes but when rains over nth nth lake becomes full rains over lake full there your goal avoid floods any integer array rains means there rains over means there no rains this day can choose one lake this day dry array ans lake choose dry ith day there multiple valid answers any impossible avoid flood empty notice chose dry full becomes but chose dry empty nothing rains after first day full lakes after second day full lakes after third day full lakes after fourth day full lakes no day dry any lake there no flood any rains after first day full lakes after second day full lakes after third we dry lake full lakes after fourth we dry lake there no full after fifth full lakes after sixth full lakes easy this scenario another acceptable rains after second full lakes we have dry one lake third after rain over lakes easy prove no matter which lake choose dry other one
count fertile pyramids in a land farmer rectangular grid land m rows columns can divided into unit each cell either fertile or barren all cells outside grid considered pyramidal plot land can defined set cells following cells set greater than all cells must apex pyramid topmost cell height pyramid rows let apex height plot comprises cells where r i r h c j c inverse pyramidal plot land can defined set cells similar cells set greater than all cells must apex inverse pyramid bottommost cell inverse height inverse pyramid rows let apex height plot comprises cells where r h i r c j c some examples valid invalid pyramidal inverse plots shown black cells indicate fertile m x binary matrix grid representing total pyramidal inverse pyramidal plots can found grid possible pyramidal plots shown blue red there no inverse pyramidal plots this hence total pyramidal inverse pyramidal plots grid pyramidal plot shown inverse pyramidal plot shown hence total plots grid there pyramidal which shown there inverse pyramidal which shown last total plots m m either or
card flipping game two integer arrays fronts backs length where ith card positive integer printed front printed each card placed table such front facing up other facing may flip over any cards after flipping integer considered good facing down some card not facing up any minimum possible good integer after flipping there no good fronts backs we flip second face up numbers face down minimum good integer appears facing down but not facing can shown minimum possible good integer obtainable after flipping some fronts backs there no good integers no matter how we flip so we
check if the sentence is pangram pangram sentence where every letter english alphabet appears least string sentence containing only lowercase english true sentence or false sentence true sentence contains least one every letter english sentence false sentence consists lowercase english
get watched videos by your friends there each person unique id between arrays watchedvideos where contain list watched videos list friends respectively person id level videos all watched videos your level videos all watched videos friends your friends so level k videos all watched videos people shortest path exactly equal k your id level list videos ordered their frequencies videos same frequency order them alphabetically least watchedvideos friends id level have id color your friends color person id watchedvideos person id watchedvideos frequencies watchedvideos your friends b c watchedvideos friends id level have id color only friend your friends person id color id level contains then contains i
primary department for each employee sql schema employee column name type int int varchar primary key this id id department which employee enum type flag department primary department flag department not employees can belong multiple when employee joins other they need decide which department their primary note when employee belongs only one their primary column write sql query report all employees their primary employees who belong one report their only result table any query result format following employee y y primary department employee primary department employee primary department employee primary department employee
largest rectangle in histogram array integers heights representing bar height where width each bar area largest rectangle heights above histogram where width each bar largest rectangle shown red which area heights
collect coins in a tree there exists undirected unrooted tree nodes indexed integer integer array edges length where indicates there edge between nodes ai bi also array coins size where can either or where indicates presence coin vertex choose start any vertex can perform following operations any collect all coins distance most current or move any adjacent vertex find minimum edges need go through collect all coins go back initial note pass edge several need count into answer several coins edges start vertex collect coin vertex move vertex collect coin vertex then move back vertex coins edges start vertex collect coins vertices move vertex collect coin vertex then move back vertex bi ai bi edges represents valid
minimum score after removals on a tree there undirected connected tree nodes labeled integer array nums length where represents value ith also integer array edges length where indicates there edge between nodes ai bi remove two distinct edges tree form three connected pair removed following steps get xor all values nodes each three components difference between largest xor value smallest xor value score say three components have node three xor values largest xor value smallest xor value score then minimum score any possible pair edge removals nums edges diagram above shows way make pair component nodes values xor value component node value xor value component node value xor value score difference between largest smallest xor value which can shown no other pair removals obtain smaller score than nums edges diagram above shows way make pair component nodes values xor value component nodes values xor value component nodes values xor value score difference between largest smallest xor value which we cannot obtain smaller score than bi ai bi edges represents valid
number of good leaf nodes pairs root binary tree integer pair two different leaf nodes binary tree said good length shortest path between them less than or equal good leaf node pairs root distance leaf nodes tree length shortest path between them this only good root distance good pairs shortest path pair not good because length ther shortest path between them root distance only good pair nodes tree range distance
sliding window median median middle value ordered integer size list there no middle so median mean two middle arr median arr median integer array nums integer there sliding window size k which moving very left array very can only see k numbers each time sliding window moves right one median array each window original answers within actual value nums k window position median nums k k
flatten a multilevel doubly linked list doubly linked which contains nodes have next previous additional child this child pointer may or may not point separate doubly linked also containing these special these child lists may have one or more children their so produce multilevel data structure shown head first level flatten list so all nodes appear doubly linked let curr node child nodes child list should appear after curr before flattened head flattened nodes list must have all their child pointers set head multilevel linked list input after flattening multilevel linked list head multilevel linked list input after flattening multilevel linked list head there could empty list nodes not exceed how multilevel linked list represented test we use multilevel linked list serialization each level serialize all levels we add nulls each level signify no node connects upper node previous serialization merging serialization each level removing trailing nulls we
maximum value at a given index in a bounded array three positive want construct array nums satisfies following positive integer where i where i sum all elements nums does not exceed constructed note equals x x index maxsum nums one array satisfies all there no arrays satisfy all conditions have so maximum index maxsum maxsum index
longest common subpath there country cities numbered this there road connecting every pair there m friends numbered m who traveling through each one them take path consisting some each path represented integer array contains visited cities path may contain city more than but same city not listed integer integer array paths where integer array representing path ith length longest common subpath shared every or there no common subpath subpath path contiguous sequence cities within paths longest common subpath paths there no common subpath shared three paths possible longest common subpaths all have length m m same city not listed multiple times consecutively
teemo attacking our hero teemo attacking enemy ashe poison when teemo attacks ashe gets poisoned exactly duration more attack second t mean ashe poisoned during inclusive time interval t duration teemo attacks again before poison effect timer poison effect end duration seconds after new integer array where denotes teemo attacks ashe second integer total seconds ashe timeseries duration attacks ashe go second teemo ashe poisoned seconds second teemo ashe poisoned seconds ashe poisoned seconds which seconds timeseries duration attacks ashe go second teemo ashe poisoned seconds second teemo attacks again resets poison ashe poisoned seconds ashe poisoned seconds which seconds duration timeseries sorted
day of the year string date representing gregorian calendar date formatted day date date day year date all other digits date represents calendar date between jan dec
construct binary tree from preorder and inorder traversal two integer arrays preorder inorder where preorder preorder traversal binary tree inorder inorder traversal same construct binary preorder inorder preorder inorder preorder inorder consist unique each value inorder also appears preorder guaranteed preorder traversal inorder guaranteed inorder traversal
display table of food orders in a restaurant array which represents orders customers have done more specifically where customernamei name tablenumberi table customer sit fooditemi item customer table whose row entries denote how many each food item each table first column table remaining columns correspond each food item alphabetical first row should header whose first column followed names food note customer names not part rows should sorted numerically increasing orders displaying table looks table david orders rous orders table carla orders table corina orders orders table adam brianna order table ratesh amadeus order orders customernamei fooditemi consist lowercase uppercase english letters space tablenumberi valid integer between
orderly queue string s integer can choose one first k letters s append end lexicographically smallest string could have after applying mentioned step any s k first we move character obtaining string second we move character obtaining final result s k first we move character obtaining string second we move character obtaining final result k s consist lowercase english
check if there is a valid parentheses string path parentheses string string consisting only valid any following conditions can written ab concatenated where b valid parentheses can written where valid parentheses m x matrix parentheses valid parentheses string path grid path satisfying all following path starts upper left cell path ends cell path only ever moves down or resulting parentheses string formed path true there exists valid parentheses string path grid true above diagram shows two possible paths form valid parentheses first path shown results valid parentheses string second path shown results valid parentheses string note there may other valid parentheses string grid false two possible paths form parentheses strings since neither them valid parentheses we m either or
minimum distance to type a word using two fingers have keyboard layout shown above where each english uppercase letter located some letter located coordinate letter located coordinate letter located coordinate letter located coordinate string minimum total distance type such string using only two distance between coordinates note initial positions your two fingers considered free so do not count towards your total also your two fingers do not have start first letter or first two word using two one optimal way type finger letter cost finger letter cost distance letter letter finger letter cost finger letter cost distance letter letter total distance word using two one optimal way type finger letter cost finger letter cost distance letter letter finger letter cost finger letter cost distance letter letter finger letter cost distance letter letter total distance word consists uppercase english
egg drop with 2 eggs and n floors two identical eggs have access building floors labeled know there exists floor f where f such any egg dropped floor higher than f any egg dropped or below floor f not each may take unbroken egg drop any floor x x egg can no longer use egg does not may reuse future minimum moves need determine certainty what value f we can drop first egg floor second egg floor first egg we know f second egg breaks but first egg we know f both eggs we know f one optimal strategy drop egg floor we know f between drop egg starting floor going up one time find f within more total drops egg does not drop egg again floor we know f between drop egg starting floor going up one time find f within more total drops egg does not break follow similar process dropping egg floors regardless takes most drops determine
find valid matrix given row and column sums two arrays rowsum colsum integers where sum elements ith row sum elements jth column other do not know elements but do know sums each row find any matrix integers size x satisfies rowsum colsum array representing any matrix fulfills guaranteed least one matrix fulfills requirements rowsum colsum row column sums all matrix elements another possible matrix rowsum colsum
operations on tree tree nodes numbered form parent array parent where parent ith root tree node so since no want design data structure allows users upgrade nodes data structure should support following locks node user prevents other users locking same may only lock node using this function node unlocks node may only unlock node using this function currently locked same locks node user unlocks all descendants regardless who locked may only upgrade node all conditions node least one locked descendant any does not have any locked implement lockingtree initializes data structure parent int returns true possible user id user lock node or false node num become locked user id int returns true possible user id user unlock node or false node num become int returns true possible user id user upgrade node or false node num input output explanation lockingtree lockingtree new true because node node now locked user false because user cannot unlock node locked user true because node previously locked user node now true because node node now locked user true because node unlocked least one locked descendant node now locked user node now false because node already i num user parent represents valid most calls total made
maximum score words formed by letters list list single letters score every maximum score any valid set words formed using letters cannot used two or more not necessary use all characters letters each letter can only used score letters words letters score score we can form words score words only get score words letters score score we can form words score word only get score words letters score letter can only used contains only lower case english
smallest range i integer array nums integer one can choose any index i where i change x where x integer range can apply this operation most once each index score nums difference between maximum minimum elements minimum score nums after applying mentioned operation most once each index nums k score nums k change nums score nums k change nums score k
counter integer counter this counter function initially returns then returns more than previous value every subsequent time called first time returns returns more than previous returns more than previous initially returns then increases after each sebsequent most calls made
a number after a double reversal reversing integer means reverse all reversing gives reversing gives leading zeros not integer reverse num get then reverse get true equals otherwise num true reverse num get then reverse get which equals num false reverse num get then reverse get which does not equal num true reverse num get then reverse get which equals num
set mismatch have set integers which originally contains all numbers due some one numbers s got duplicated another which results repetition one loss another integer array nums representing data status this set after find occurs twice missing them form nums nums
defanging an ip address valid ip defanged version ip defanged ip address replaces every period address address address valid
minimum window substring two strings s t lengths m minimum window substring s such every character t included there no such empty string testcases generated such answer s t minimum window substring includes string s t entire string s minimum s t both t must included since largest window s only one empty m s t consist uppercase lowercase english follow could find algorithm runs
find all good strings strings size string good good string size alphabetically greater than or equal alphabetically smaller than or equal does not contain string evil since answer can huge this modulo evil there good strings starting then there good strings starting finally there one good string starting evil all strings greater than or equal smaller than or equal start prefix there not any good evil all strings consist lowercase english
take gifts from the richest pile integer array gifts denoting gifts various every do choose pile maximum there more than one pile maximum choose leave behind floor square root gifts take rest gifts remaining after k gifts k gifts taken following first last pile chosen gifts left then second pile chosen gifts left after first pile chosen gifts left last pile chosen again gifts left final remaining gifts so total gifts remaining gifts k this regardless which pile have leave behind gift each take any pile total gifts remaining k
encode and decode tinyurl this companion problem system design design tinyurl url shortening service where enter url such returns short url such design class encode url decode tiny there no restriction how your algorithm should just need ensure url can encoded tiny url tiny url can decoded original implement solution initializes object string returns tiny url string returns original long url guaranteed shorturl encoded same url solution obj new string tiny returns encoded tiny string ans returns original url after decoding url guranteed valid
number of smooth descent periods of a stock integer array prices representing daily price history where stock price ith smooth descent period stock consists one or more contiguous days such price each day lower than price preceding day exactly first day period exempted this smooth descent prices there smooth descent note period one day smooth descent period prices there smooth descent note not smooth descent period prices there smooth descent
reformat phone number phone string consists spaces dashes would like reformat phone certain remove all spaces group digits left right into blocks length until there or fewer final digits then grouped single block length single block length two blocks length blocks then joined notice reformatting process should never produce any blocks length produce most two blocks length phone after digits step there more than so group next block step there digits so put them single block length block joining blocks gives digits step there more than so group next block step there digits so split them into two blocks length blocks joining blocks gives digits step block step block step there digits so put them single block length block joining blocks gives consists digits characters there least two digits
airplane seat assignment probability passengers board airplane exactly first passenger lost ticket picks seat but after rest passengers take their own seat still pick other seats randomly when they find their seat occupied probability nth person gets his own first person can only get first second person probability get second seat first person gets first
product of array except self integer array array answer such equal product all elements nums except product any prefix or suffix nums guaranteed fit must write algorithm runs time without using division nums nums product any prefix or suffix nums guaranteed fit follow can solve problem extra space output array does not count extra space space complexity
length of the longest alphabetical continuous substring alphabetical continuous string string consisting consecutive letters other any substring string alphabetical continuous while string s consisting lowercase letters length longest alphabetical continuous s there distinct continuous longest continuous s longest continuous s consists only english lowercase
maximum swap integer can swap two digits most once get maximum valued maximum valued can num swap num no num
make k-subarray sums equal integer array arr integer array arr other first element array next element last last element array previous element first can do following operation any pick any element arr increase or decrease minimum operations such sum each subarray length k subarray contiguous part arr k we can do one operation index make value equal array after operation subarray starts index sum subarray starts index sum subarray starts index sum subarray starts index sum arr k we can do three operations index make value equal two operations index make value equal array after operations subarray starts index sum subarray starts index sum subarray starts index sum subarray starts index sum k
immediate food delivery ii sql schema delivery column name type int int date date primary key this table holds information about food delivery customers make orders some date specify preferred delivery date same order date or after preferred delivery date same order then order called called first order customer order earliest order date customer guaranteed customer precisely one first write sql query find percentage immediate orders first orders all rounded decimal query result format following delivery customer id first order delivery id customer id first order delivery id customer id first order delivery id customer id first order delivery id half customers have immediate first
check if word is valid after substitutions string determine string s valid starting empty string t can transform t into s after performing following operation any insert string into any position more t becomes tleft where t tleft note tleft tright may true s valid s true s true s false impossible get using s consists letters
stone game alice bob play game piles there even piles arranged each pile positive integer stones objective game end most total stones across all piles so there no alice bob take alice starting each player takes entire pile stones either beginning or end this continues until there no more piles which point person most stones assuming alice bob play true alice wins or false bob piles true alice starts can only take first or last say she takes first so row becomes bob takes then board alice takes win bob takes last then board alice takes win this demonstrated taking first winning move so we piles true
capacity to ship packages within d days conveyor belt packages must shipped one port another within days ith package conveyor belt weight each we load ship packages conveyor belt order we may not load more weight than maximum weight capacity least weight capacity ship result all packages conveyor belt being shipped within days weights days ship capacity minimum ship all packages days like note cargo must shipped order so using ship capacity splitting packages into parts like not weights days ship capacity minimum ship all packages days like weights days days
minimum increment to make array unique integer array one can pick index i where i increment minimum moves make every value nums test cases generated so answer fits nums after array could nums after array could can shown or less moves impossible array have all unique
minimize maximum pair sum in array pair sum pair equal maximum pair sum largest pair sum list we have pairs maximum pair sum would array nums even length pair up elements nums into pairs such each element nums exactly one maximum pair sum minimized maximum pair sum after optimally pairing up nums elements can paired up into pairs maximum pair sum nums elements can paired up into pairs maximum pair sum
number of valid words for each puzzle respect puzzle word valid both following conditions word contains first letter each letter letter puzzle then valid words while invalid words not include which not array where words word list words valid respect puzzle words puzzles valid word valid word valid words valid words valid words there no valid words cause none words list contains letter words puzzles consist lowercase english each does not contain repeated
all o`one data structure design data structure store count ability strings minimum maximum implement allone initializes object data increments count string key key does not exist data insert count decrements count string key count key after remove data guaranteed key exists data structure before returns one keys maximal no element empty string returns one keys minimum no element empty string note each function must run average time input output explanation allone allone new key consists lowercase english guaranteed each call key existing data most calls made
create target array in the given order two arrays integers nums your task create target array under following initially target array left right read insert index value target repeat previous step until there no elements read nums target guaranteed insertion operations nums index nums index target nums index nums index target nums index i
number complement complement integer integer get when flip all all binary integer binary complement which integer integer num binary representation leading zero complement so need output num binary representation leading zero complement so need output num this question same
find first palindromic string in the array array strings first palindromic string there no such empty string string palindromic reads same forward words first string palindromic note also but not words first only string palindromic words there no palindromic so empty string consists only lowercase english
keys and rooms there rooms labeled all rooms locked except room your goal visit all cannot enter locked room without having when visit may find set distinct keys each key denoting which room can take all them unlock other array rooms where set keys can obtain visited room true can visit all or false rooms true we visit room pick up key we then visit room pick up key we then visit room pick up key we then visit room since we able visit every we rooms false we can not enter room since only key unlocks all values
prime subtraction operation integer array nums length can perform following operation many times pick index i picked pick prime p strictly less than then subtract p true can make nums strictly increasing array using above operation false strictly increasing array array whose each element strictly greater than preceding nums true first pick i p then subtract so nums becomes second i p subtract so nums becomes equal after second nums sorted strictly increasing so answer nums true initially nums sorted strictly increasing so we need make any nums false can proven there no way perform operations make nums sorted strictly increasing so answer
minimum path sum m x grid filled find path top left bottom which minimizes sum all numbers along can only move either down or right any point grid because path minimizes grid m
create hello world function write function should new function always returns args const f function returned createhelloworld should always args const f any arguments could passed function but should still always
fraction addition and subtraction string expression representing expression fraction addition calculation result string final result should irreducible your final result change format fraction denominator so this should converted expression expression expression input string only contains so does each fraction format first input fraction or output then input only contains valid irreducible where numerator denominator each fraction always range denominator means this fraction actually integer fraction format defined fractions range numerator denominator final result guaranteed valid range
kth largest sum in a binary tree root binary tree positive integer level sum tree sum values nodes same kth largest level sum tree necessarily there fewer than k levels note two nodes same level they have same distance root k level sums level level level level largest level sum root k largest level sum nodes tree k
maximum length of a concatenated string with unique characters array strings string s formed concatenation subsequence arr unique maximum possible length subsequence array can derived another array deleting some or no elements without changing order remaining arr all valid concatenations maximum length arr possible longest valid concatenations arr only string arr all contains only lowercase english
find the k-beauty of a number integer num defined substrings num when read string meet following length divisor integers num leading zeros not divisor any substring contiguous sequence characters num k following substrings num length divisor divisor num k following substrings num length divisor not divisor not divisor not divisor divisor num k num
student attendance record i string s representing attendance record student where each character signifies whether student or present record only contains following three student eligible attendance award they meet both following student absent strictly fewer than days student never late or more consecutive true student eligible attendance or false s true student fewer than absences never late or more consecutive s false student late consecutive days last so not eligible either or
exclusive time of functions we execute program containing each function unique id between function calls stored call when function call id pushed onto when function call id popped off function whose id top stack current function being each time function starts or we write log whether started or list where represents ith log message formatted string means function call function id started beginning timestamp means function call function id ended end timestamp note function can called multiple possibly exclusive time sum execution times all function calls function called one call executing time units another call executing time exclusive time exclusive time each function where value ith index represents exclusive time function id logs function starts beginning time then executes units time reaches end time function starts beginning time executes units ends end time function resumes execution beginning time executes unit so function spends units total time function spends units total time logs function starts beginning time executes units recursively calls function starts beginning time executes units function resumes execution then immediately calls itself function recursive starts beginning time executes unit function resumes execution beginning time executes unit so function spends units total time logs function starts beginning time executes units recursively calls function starts beginning time executes units function resumes execution then immediately calls function function starts beginning time executes unit ends end time function resumes execution beginning time executes units so function spends units total time function spends unit total time timestamp no two start events happen same no two end events happen same each function log each
generate parentheses pairs write function generate all combinations
minimized maximum of products distributed to any store integer indicating there specialty retail there m product types varying which integer array where represents products ith product need distribute all products retail stores following these store can only most one product type but can any amount after each store have been some products let x represent maximum products any want x small want minimize maximum products any minimum possible quantities one optimal way products type distributed first four stores these products type distributed other two stores these maximum products any store quantities one optimal way products type distributed first three stores these products type distributed next two stores these products type distributed last two stores these maximum products any store quantities only optimal way products type distributed only maximum products any store m m
merge intervals array intervals where merge all overlapping array intervals cover all intervals intervals since intervals merge them into intervals intervals considered starti endi
time needed to buy tickets there people line queuing buy where person front line person back integer array tickets length where tickets ith person would like buy each person takes exactly second buy person can only buy ticket time go back end line happens order buy more person does not have any tickets left person leave time taken person position k finish buying tickets k first everyone line buys ticket line becomes second everyone line buys ticket line becomes person position successfully bought tickets took tickets k first everyone line buys ticket line becomes next only person position buying person position successfully bought tickets took k
partition list head linked list value partition such all nodes less than x come before nodes greater than or equal should preserve original relative order nodes each two head x head x nodes list range x
next permutation permutation array integers arrangement members into sequence or linear arr following all permutations next permutation array integers next lexicographically greater permutation more all permutations array sorted one container according their lexicographical then next permutation array permutation follows sorted such arrangement not array must rearranged lowest possible order sorted ascending next permutation arr next permutation arr while next permutation arr because does not have lexicographical larger array integers find next permutation replacement must place use only constant extra nums nums nums
maximum number of points from grid queries m x integer matrix grid array queries size find array answer size k such each integer start top left cell matrix repeat following strictly greater than value current cell then get one point your first time visiting this can move any adjacent cell all do not get any end this after maximum points can note each query allowed visit same cell multiple resulting array grid queries diagrams above show which cells we visit get points each grid queries we can not get any points because value top left cell already greater than or equal m m k k
minimum xor sum of two arrays two integer arrays length xor sum two integer arrays xor xor xor xor sum equal xor xor xor rearrange elements such resulting xor sum xor sum after rearrange so becomes xor sum xor xor rearrange so becomes xor sum xor xor xor
number of ways to separate numbers wrote down many positive integers string called realized forgot add commas seperate different remember list integers no integer had leading possible lists integers could have written down get string since answer may modulo num could have written down num no numbers can have leading zeros all numbers must num no numbers can have leading zeros all numbers must num consists digits through
surrounded regions m x matrix board containing capture all regions surrounded region captured flipping all into surrounded board notice should not flipped or adjacent should not bottom so not other three form surrounded so they board m or
maximum matching of players with trainers integer array where represents ability ith also integer array where represents training capacity jth ith player can match jth trainer ability less than or equal training ith player can matched most one jth trainer can matched most one maximum matchings between players trainers satisfy these players trainers one ways we can form two matchings can matched since can matched since can proven maximum matchings can players trainers trainer can matched any each player can only matched one so maximum answer
find all duplicates in an array integer array nums length where all integers nums range each integer appears once or array all integers appears must write algorithm runs time uses only constant extra nums nums nums each element nums appears once or
remove sub-folders from the filesystem list folders folders after removing all those may answer any located within another called format path one or more concatenated strings followed one or more lowercase english valid paths while empty string folder folders subfolder inside folder our folder folders removed because they subfolders folder contains only lowercase letters always starts character each folder name
employee importance have data structure employee including unique importance direct array employees employees id ith importance value ith list ids direct subordinates ith integer id represents total importance value this employee all their direct indirect employees id employee importance value two direct employee employee they both have importance value total importance value employee employees id employee importance value no direct total importance value employee all one employee most one direct leader may have several ids valid
freedom trail video game fallout quest requires players reach metal dial called trail use dial spell specific keyword open string ring represents code engraved outer ring another string key represents keyword needs minimum steps spell all characters first character ring aligned should spell all characters key one one rotating ring clockwise or anticlockwise make each character string key aligned direction then pressing center stage rotating ring spell key character can rotate ring clockwise or anticlockwise one which counts one final purpose rotation align one characters where this character must equal character been aligned press center button which also counts one after could begin spell next character key have finished all ring key first key character since already we just need step spell this second key character we need rotate ring anticlockwise two steps make become we need more step so final output ring key ring key consist only lower case english guaranteed key could always spelled rotating
kth largest element in a stream design class find kth largest element note kth largest element sorted not kth distinct implement kthlargest initializes object integer k stream integers int appends integer val stream returns element representing kth largest element input output explanation kthlargest kthlargest new k val most calls made guaranteed there least k elements array when search kth
find palindrome with fixed length integer array queries positive integer array answer where either smallest positive palindrome length intlength or no such palindrome palindrome reads same backwards palindromes cannot have leading queries intlength first few palindromes length palindrome length queries intlength first six palindromes length intlength
global and local inversions integer array nums length which represents permutation all integers range global inversions different pairs i j local inversions indices i i true global inversions equal local nums true there global inversion local nums false there global inversions local all integers nums nums permutation all numbers range
flip equivalent binary trees binary tree we can define flip operation choose any swap left right child binary tree x flip equivalent binary tree y only we can make x equal y after some flip roots two binary trees true two trees flip equivalent or false true we flipped nodes values true false nodes each tree range each tree have unique node values range
number of ways to select buildings binary string s which represents types buildings along street denotes ith building office denotes ith building city would like select buildings random ensure no two consecutive buildings out selected buildings can same s we cannot select buildings would form which not allowed due having two consecutive buildings same valid ways select s following sets indices selected forms forms forms forms forms forms no other selection there total s can shown there no valid either or
count the digits that divide a number integer digits num divide integer val divides nums nums val num divides hence answer num divisible but not since occurs twice we num divisible all hence answer num num does not contain one
nim game playing following nim game your there heap stones your friend alternate taking go each person whose turn remove stones one who removes last stone stones true can win game assuming both your friend play otherwise false these possible remove your friend removes including last your friend remove your friend removes including last your friend remove your friend removes last your friend all your friend true true
removing minimum and maximum from array array distinct integers there element nums lowest value element highest we call them minimum maximum your goal remove both these elements deletion defined either removing element front array or removing element back minimum deletions would take remove both minimum maximum element nums minimum element array which maximum element array which we can remove both minimum maximum removing elements front elements this results which minimum nums minimum element array which maximum element array which we can remove both minimum maximum removing elements this results only which minimum nums there only one element which makes both minimum maximum we can remove integers nums
rectangle area ii array each denotes ith rectangle where coordinates coordinates calculate total area covered all rectangles any area covered two or more rectangles should only counted total since answer may too modulo rectangles total area covered all three illustrated green red rectangles all three rectangles rectangles answer modulo which
determine whether matrix can be obtained by rotation two x binary matrices mat true possible make mat equal target rotating mat or false mat target true we can rotate mat degrees clockwise make mat equal mat target false impossible make mat equal target rotating mat target true we can rotate mat degrees clockwise two times make mat equal either or
valid parenthesis string string s containing only three types true s following rules define valid any left parenthesis must have corresponding right parenthesis any right parenthesis must have corresponding left parenthesis left parenthesis must go before corresponding right parenthesis could treated single right parenthesis or single left parenthesis or empty string s true s true s true or
minimize hamming distance after swap operations two integer source both length also array allowedswaps where each indicates allowed swap elements index ai index bi array note can swap elements specific pair indices multiple times any hamming distance two arrays same source positions where elements indices i i where minimum hamming distance source target after performing any amount swap operations array source target allowedswaps source can transformed following swap indices source swap indices source hamming distance source target they differ index source target allowedswaps there no allowed hamming distance source target they differ index index source target allowedswaps bi ai bi
maximum equal frequency array nums positive longest possible length array prefix such possible remove exactly one element this prefix so every appeared have same after removing one element there no remaining still considered every appeared same ocurrences nums subarray length we remove we get so each appear exactly nums
rotated digits integer x good after rotating each digit individually we get valid different each digit must rotated we cannot choose leave valid each digit remains digit after rotate rotate each other this case they rotated different other or gets rotate each rest numbers do not rotate any other become integer good integers range there four good numbers range note not good since they remain unchanged after
partition string into substrings with values at most k string s consisting digits integer partition string s called good each digit s part exactly one value each substring less than or equal minimum substrings good partition no good partition s note value string result when interpreted value value substring contiguous sequence characters within s k we can partition string into substrings each substring value less than or equal k can shown we cannot partition string into less than s k there no good partition this digit k
search a 2d matrix m x integer matrix matrix following two each row sorted first integer each row greater than last integer previous integer true target matrix or false must write solution time matrix target true matrix target false m target
pizza with 3n slices there pizza slices varying your friends take slices pizza pick any pizza your friend alice pick next slice direction your your friend bob pick next slice clockwise direction your repeat until there no more slices integer array slices represent sizes pizza slices clockwise maximum possible sum slice sizes can slices pick pizza slice size alice bob pick slices size then pick slices size finally alice bob pick slice size total slices pick pizza slice size each pick slice size your partners pick slices size
find the winner of the circular game there friends playing friends sitting circle numbered clockwise more moving clockwise ith friend brings friend i moving clockwise nth friend brings rules game start count next k friends clockwise direction including friend started counting wraps around circle may count some friends more than last friend counted leaves circle loses there still more than one friend go back step starting friend immediately clockwise friend who just lost last friend circle wins integer winner k here steps start friend count friends which friends friend leaves next start friend count friends which friends friend leaves next start friend count friends which friends friend leaves next start friend count friends which friends friend leaves only friend so they k friends leave this winner friend k follow could solve this problem linear time constant
total cost to hire k workers integer array costs where cost hiring ith also two integers k we want hire exactly k workers according following run k sessions hire exactly one worker each each hiring choose worker lowest cost either first candidates workers or last candidates break tie smallest costs candidates then first hiring we choose worker because they have lowest cost second hiring we choose worker because they have same lowest cost worker but they have smallest index please note indexing may changed there fewer than candidates workers choose worker lowest cost among break tie smallest worker can only chosen total cost hire exactly k costs k candidates we hire workers total cost initially first hiring round we choose worker lowest cost we break tie smallest which total cost second hiring round we choose worker lowest cost total cost third hiring round we choose worker lowest cost total cost notice worker index common first last four total hiring cost costs k candidates we hire workers total cost initially first hiring round we choose worker lowest cost we break tie smallest which total cost notice workers index common first last second hiring round we choose worker lowest cost total cost third hiring round there less than three we choose worker remaining workers lowest cost total cost total hiring cost candidates
lexicographically smallest equivalent string two strings same length string we say equivalent then we have equivalent characters follow usual rules any equivalence implies implies equivalency information equivalent strings basestr lexicographically smallest equivalent string lexicographically smallest equivalent string basestr using equivalency information basestr based equivalency information we can group their characters characters each group equivalent sorted lexicographical so answer basestr based equivalency information we can group their characters so only second letter basestr changed answer basestr we group equivalent characters thus all letters basestr except transformed answer basestr basestr consist lowercase english
create components with same value there undirected tree nodes labeled integer array nums length where represents value ith also integer array edges length where indicates there edge between nodes ai bi allowed delete some splitting tree into multiple connected let value component sum all which node i maximum edges can such every connected component tree same nums edges above figure shows how we can delete edges created components nodes sum values each component equals can proven no better deletion so answer nums edges there no edges edges represents valid
maximum earnings from taxi there points road driving your taxi points road labeled direction want drive point point make money picking up cannot change direction passengers represented integer array where denotes ith passenger requesting ride point starti point endi who willing give tipi dollar each passenger i pick earn endi starti tipi may only drive most one passenger maximum dollars can earn picking up passengers may drop off passenger pick up different passenger same rides we can pick up passenger earn rides we pick up following drive passenger point point profit drive passenger point point profit drive passenger point point profit we earn dollars starti endi tipi
validate binary tree nodes have binary tree nodes numbered where node i two children true only all nodes form exactly one valid binary node i no left child then equal similarly right note nodes have no values we only use node numbers this leftchild rightchild true leftchild rightchild false leftchild rightchild false
coloring a border m x integer matrix three integers each value grid represents color grid square two squares called adjacent they next each other any two squares belong same connected component they have same color they border connected component all squares connected component either adjacent square not or boundary grid first or last row or should color border connected component contains square final grid row col color grid row col color grid row col color m color row m col
monotone increasing digits integer monotone increasing digits only each pair adjacent digits x y satisfy x integer largest less than or equal monotone increasing
perfect squares integer least perfect square numbers sum perfect square integer square other product some integer perfect squares while
best position for a service centre delivery company wants build new service center new company knows positions all customers this city wants build new center position such sum euclidean distances all customers array positions where position ith customer minimum sum euclidean distances all other need choose position service center such following formula answers within actual value positions can see choosing make distance each customer sum all distances which minimum possible we can positions minimum possible sum distances yi
power of three integer true power integer power there exists integer x such true false there no x where false there no x where follow could solve without
check if all characters have equal number of occurrences string true s good or false string s good all characters appear s have same occurrences same s true characters appear s all characters occur times s false characters appear s occurs times while occurs which not same s consists lowercase english
split with minimum sum positive integer split into two integers such concatenation permutation other sum occurrences each digit equal occurrences digit can contain leading minimum possible sum guaranteed num does not contain any leading order occurrence digits may differ order occurrence num we can split so giving sum we can prove indeed minimal possible num we can split so which would give optimal sum num
product sales analysis i sql schema sales column name type int int year int quantity int price int primary key this foreign key product each row this table shows sale product certain note price per product column name type int varchar primary key this each row this table indicates product name each write sql query reports price each sales resulting table any query result format following sales year quantity price product nokia apple samsung year price nokia nokia apple we can conclude nokia sold year we can conclude nokia sold year we can conclude apple sold year
minimum number of days to eat n oranges there oranges kitchen decided eat some these oranges every day eat one remaining oranges divisible then can eat remaining oranges divisible then can eat can only choose one actions per integer minimum days eat have day eat day eat divisible day eat day eat last orange need least days eat have day eat divisible day eat divisible day eat last orange need least days eat
groups of special-equivalent strings array strings same length one can swap any two even indexed characters or any two odd indexed characters string two strings after any because we may make moves group strings words subset words such every pair strings group special group largest size possible there not string not group such every string groups strings words one group since they all pairwise special none other strings all pairwise special equivalent other two groups note not special equivalent words consist lowercase english all strings same
find the losers of the circular game there friends playing friends sitting circle numbered clockwise more moving clockwise ith friend brings friend i moving clockwise nth friend brings rules game friend receives after friend passes friend who k steps away them clockwise after friend who receives ball should pass friend who k steps away them clockwise after friend who receives ball should pass friend who k steps away them clockwise so so other ith friend holding ball should pass friend who i k steps away them clockwise game finished when some friend receives ball second losers game friends who did not receive ball entire integer array which contains losers game ascending k game goes start friend pass ball friend who steps away them friend passes ball friend who steps away them friend passes ball friend who steps away them game ends friend receives ball second k game goes start friend pass ball friend who steps away them game ends friend receives ball second k
merge two binary trees two binary trees imagine when put one them cover some nodes two trees overlapped while others need merge two trees into new binary merge rule two nodes then sum node values up new value merged not null node used node new merged merging process must start root nodes both nodes both trees range
count number of ways to place houses there street where there plots each side plots each side numbered each house can ways houses can placed such no two houses adjacent each other same side since answer may very modulo note house placed ith plot one side house can also placed ith plot other side possible all plots house placed one side house placed other side two houses one each side possible arrangements shown diagram
vertical order traversal of a binary tree root binary calculate vertical order traversal binary each node position left right children positions col col root tree vertical order traversal binary tree list orderings each column index starting leftmost column ending rightmost there may multiple nodes same row same such sort these nodes their vertical order traversal binary root column only node this column nodes this column order top column only node this column only node this root column only node this column only node this column nodes this so comes same position so we order them their before column only node this column only node this root this case exact same but nodes note solution remains same since same location should ordered their nodes tree range
maximize distance to closest person array representing row seats where represents person sitting ith represents ith seat empty there least one empty least one person alex wants sit seat such distance between him closest person him maximum distance closest seats alex sits second open seat then closest person distance alex sits any other open closest person distance maximum distance closest person seats alex sits last seat closest person seats this maximum distance so answer seats or least one seat least one seat
solve the equation solve equation value form string equation contains only variable should there no solution or there infinite solutions there exactly one solution we ensure value equation equation equation equation exactly one equation consists integers absolute value range without any leading variable
shortest subarray to be removed to make array sorted integer array remove subarray arr such remaining elements arr length shortest subarray subarray contiguous subsequence arr shortest subarray we can remove length remaining elements after which another correct solution remove subarray arr since array strictly we can only keep single therefore we need remove subarray length either or arr array already we do not need remove any
convert binary number in a linked list to integer head which reference node value each node linked list either or linked list holds binary representation decimal value linked most significant bit head linked head base base head linked list not nodes not exceed each value either or
minimum consecutive cards to pick up integer array cards where represents value ith pair cards matching cards have same minimum consecutive cards have pick up have pair matching cards among picked impossible have matching cards we can pick up cards which contain matching pair cards value note picking up cards also cards there no way pick up set consecutive cards contain pair matching
reformat the string alphanumeric string string string consisting lowercase english letters have find permutation string where no letter followed another letter no digit followed another no two adjacent characters have same reformatted string or empty string impossible reformat s no two adjacent characters have same type also valid s only characters so we cannot separate them s only digits so we cannot separate them s consists only lowercase english letters
longest common subsequence two strings length their longest common there no common subsequence string new string generated original string some characters deleted without changing relative order remaining subsequence common subsequence two strings subsequence common both longest common subsequence length longest common subsequence length there no such common so result consist only lowercase english
maximum depth of binary tree root binary maximum binary maximum depth nodes along longest path root node down farthest leaf root root nodes tree range
distinct subsequences two strings s distinct subsequences s which equals test cases generated so answer fits signed s t shown there ways can generate rabbbit rabbbit rabbbit s t shown there ways can generate babgbag babgbag babgbag babgbag babgbag s t consist english
zigzag conversion string written zigzag pattern rows like may want display this pattern fixed font better p h p l s i i g y i r then read line write code take string make this conversion string int s numrows s numrows p i l s i g y h r p i s numrows s consists english letters numrows
longest harmonious subsequence we define harmonious array array where difference between maximum value minimum value exactly integer array length longest harmonious subsequence among all possible subsequence array sequence can derived array deleting some or no elements without changing order remaining nums longest harmonious subsequence nums nums
lowest common ancestor of a binary tree binary find lowest common ancestor two nodes according definition lca lowest common ancestor defined between two nodes p q lowest node t both p q descendants we allow node descendant root p q lca nodes root p q lca nodes since node can descendant itself according lca root p q nodes tree range all p q p q exist
perfect rectangle array rectangles where represents point rectangle point true all rectangles together form exact cover rectangular rectangles true all rectangles together form exact cover rectangular rectangles false because there gap between two rectangular rectangles false because two rectangles overlap each bi
length of last word string s consisting words length last word word maximal substring consisting characters s last word length s fly me moon last word length s still last word length s consists only english letters spaces there least one word
nested array generator array generator object which yields integers same order inorder array recursive data structure contains both integers other inorder traversal iterates over each array left yielding any integers encounters or applying inorder traversal any arrays arr const generator true arr there no integers so generator yield maxnestingdepth can solve this without creating new flattened version
number of squareful arrays array squareful sum every pair adjacent elements perfect integer array permutations nums two permutations different there some index i such nums valid nums
range sum of bst root node binary search tree two integers low sum values all nodes value inclusive range root low high nodes range root low high nodes range nodes tree range low high all
maximum split of positive even integers integer split into sum maximum unique positive even finalsum following splits valid positive even integers summing up among contains maximum note finalsum cannot split into all numbers should list integers represent valid split containing maximum no valid split exists empty may integers any finalsum following valid maximum which we note also finalsum there no valid splits we empty finalsum following valid maximum which we note also finalsum
checking existence of edge length limited paths undirected graph nodes defined where denotes edge between nodes ui vi distance note there may multiple edges between two array where your task determine each whether there path between pj qj such each edge path distance strictly less than limitj boolean array where jth value answer true there path false edgelist queries above figure shows note there two overlapping edges between distances first between there no path where each distance less than thus we false this second there path two edges distances less than thus we true this edgelist queries above figure shows qj ui vi pj qj limitj there may multiple edges between two
count unguarded cells in the grid two integers m representing m x also two integer arrays guards walls where represent positions ith guard jth wall guard can see every cell four cardinal directions or starting their position unless obstructed wall or another cell guarded there least one guard can see unoccupied cells not m guards walls guarded unguarded cells shown red green respectively above there total unguarded so we m guards walls unguarded cells shown green above there total unguarded so we m m rowj m colj all positions guards walls
lemonade change lemonade each lemonade costs customers standing queue buy order one time order specified each customer only buy one lemonade pay either or must provide correct change each customer so net transaction customer pays note do not have any change hand integer array bills where bill ith customer true can provide every customer correct or false bills true first we collect three bills fourth we collect bill give back fifth we give bill since all customers got correct we output bills false first two customers we collect two next two customers we collect bill give back last we can not give change back because we only have two since not every customer received correct answer either or
count number of rectangles containing each point integer array rectangles where indicates ith rectangle length li height also integer array points where point coordinates ith rectangle corner point coordinates corner point integer array count length where rectangles contain jth ith rectangle contains jth point xj li yj note points lie edges rectangle also considered contained rectangles points first rectangle contains no second rectangle contains only point third rectangle contains points rectangles contain point rectangles contain point we rectangles points first rectangle contains only point second rectangle contains only point third rectangle contains points rectangles contain point rectangles contain point we xj yj all rectangles all points
sign of the product of an array there function x x x equal integer array let product product all values array nums product all values array nums product all values array nums product all values array
maximum twin sum of a linked list linked list size where ith node linked list known twin i then node twin node node twin node these only nodes twins twin sum defined sum node head linked list even maximum twin sum linked head nodes twins nodes all have twin sum there no other nodes twins linked maximum twin sum linked list head nodes twins present this linked list node twin node having twin sum node twin node having twin sum maximum twin sum linked list head there only one node twin linked list having twin sum nodes list even integer range
maximum total beauty of the gardens alice caretaker gardens she wants plant flowers maximize total beauty all her integer array flowers size where flowers already planted ith flowers already planted cannot then another integer which maximum flowers alice can additionally also integers garden considered complete least target total beauty gardens then determined sum complete gardens multiplied minimum flowers any incomplete gardens multiplied there no incomplete then this value maximum total beauty alice can obtain after planting most newflowers flowers newflowers target full partial alice can plant flowers garden flowers garden flower garden flower garden gardens then she planted total there garden minimum flowers incomplete gardens total beauty no other way planting flowers can obtain total beauty higher than flowers newflowers target full partial alice can plant flowers garden flowers garden flowers garden flowers garden gardens then she planted total there gardens minimum flowers incomplete gardens total beauty no other way planting flowers can obtain total beauty higher than note alice could make all gardens complete but this she would obtain lower total target newflowers partial
count equal and divisible pairs in an array integer array nums length integer pairs where i j such divisible nums k there pairs meet all which divisible which divisible which divisible which divisible nums k since no value nums there no pairs meet all k
contains duplicate iii integer array nums two integers indexdiff find pair indices such i true such pair exists or false nums indexdiff valuediff true we can choose we satisfy three i j indexdiff valuediff nums indexdiff valuediff false after trying all possible pairs we cannot satisfy three so we indexdiff valuediff
valid triangle number integer array triplets chosen array can make triangles we take them side lengths nums valid combinations first second nums
koko eating bananas koko loves eat there piles ith pile guards have gone come back h koko can decide her eating speed each she chooses some pile bananas eats k bananas pile less than k she eats all them instead not eat any more bananas during this koko likes eat slowly but still wants finish eating all bananas before guards minimum integer k such she can eat all bananas within h piles h piles h piles h h
design add and search words data structure design data structure supports adding new words finding string matches any previously added implement worddictionary initializes void adds word data can matched bool returns true there any string data structure matches word or false word may contain dots where dots can matched any input output explanation worddictionary worddictionary new false true true true word addword consists lowercase english word search consist or lowercase english there most dots word search most calls made addword
build a matrix with conditions positive integer also integer array rowconditions size where integer array colconditions size m where two arrays contain integers have build k x k matrix contains each numbers k exactly remaining cells should have value matrix should also satisfy following abovei should appear row strictly above row which belowi appears all i lefti should appear column strictly left column which righti appears all i m any matrix satisfies no answer empty k rowconditions colconditions diagram above shows valid matrix satisfies all row conditions row row so above row row so above column conditions column column so left column column so left note there may multiple correct k rowconditions colconditions first two below but third conditions needs above no matrix can satisfy all so we empty k righti k abovei belowi lefti righti
calculate special bonus sql schema employees column name type int name varchar salary int primary key this each row this table indicates employee employee write sql query calculate bonus each bonus employee their salary id employee odd employee name does not start character bonus employee result table ordered query result format following employees name salary meir michael addilyn juan kannon bonus employees ids get bonus because they have even employee id gets bonus because their name starts rest employees get
find smallest letter greater than target array characters letters sorted character there least two different characters smallest character letters lexicographically greater than such character does not first character letters target smallest character lexicographically greater than letters letters target smallest character lexicographically greater than letters letters target there no characters letters lexicographically greater than so we lowercase english letters sorted letters contains least two different target lowercase english
distinct subsequences ii string distinct subsequences since answer may very modulo subsequence string new string formed original string deleting some characters without disturbing relative positions remaining subsequence while s distinct subsequences s distinct subsequences s distinct subsequences s consists lowercase english
decoded string at index encoded string decode string encoded string read one character time following steps character read letter written onto character read digit entire current tape repeatedly written d more times integer kth letter decoded s k decoded string letter string s k decoded string letter s k decoded string repeated letter s consists lowercase english letters digits through s starts k guaranteed k less than or equal length decoded decoded string guaranteed have less than
minimum time to finish the race integer array tires where indicates ith tire can finish xth successive lap fi fi ri then tire would finish lap lap lap also integer changetime integer race consists numlaps laps may start race any have unlimited supply each tire after every may change any tire current tire wait changetime minimum time finish tires changetime numlaps lap start tire finish lap lap continue tire finish lap lap change tires new tire seconds then finish lap another lap continue tire finish lap total time minimum time complete race tires changetime numlaps lap start tire finish lap lap continue tire finish lap lap change tires new tire seconds then finish lap another lap continue tire finish lap lap change tires tire seconds then finish lap another total time minimum time complete race changetime ri numlaps
number of sub-arrays with odd sum array integers subarrays odd since answer can very modulo arr all subarrays all sum odd sums so answer arr all subarrays all sum all have even sum answer arr
find all people with secret integer indicating there people numbered also integer array meetings where indicates person xi person yi have meeting person may attend multiple meetings same integer person secret initially shares secret person firstperson time this secret then shared every time meeting takes place person more every person xi secret then they share secret person vice secrets shared person may receive secret share people other meetings within same time list all people have secret after all meetings have taken may answer any meetings firstperson time person shares secret person time person shares secret person time person shares secret person time person shares secret person people know secret after all meetings firstperson time person shares secret person time neither person nor person know time person shares secret person person people know secret after all meetings firstperson time person shares secret person time person shares secret person person shares secret person note person can share secret same time receiving time person shares secret person people know secret after all yi xi yi timei firstperson
triangle judgement sql schema triangle column name type x int y int z int primary key column this each row this table contains lengths three line write sql query report every three line segments whether they can form result table any query result format following triangle x y z x y z triangle no yes
search a 2d matrix ii write efficient algorithm searches value target m x integer matrix this matrix following integers each row sorted ascending left integers each column sorted ascending top matrix target true matrix target false m m all integers each row sorted ascending all integers each column sorted ascending target
get biggest three rhombus sums in a grid m x integer matrix rhombus sum sum elements form border regular rhombus shape rhombus must have shape square rotated degrees each corners centered grid below image four valid rhombus shapes corresponding colored cells should included each rhombus note rhombus can have area which depicted purple rhombus bottom right biggest three distinct rhombus sums grid descending there less than three distinct all grid rhombus shapes three biggest distinct rhombus sums depicted grid rhombus shapes three biggest distinct rhombus sums depicted rhombus bottom right rhombus bottom grid all three possible rhombus sums so m
binary string with substrings representing 1 to n binary string s positive integer true binary representation all integers range substrings or false substring contiguous sequence characters within s true s false either or
n-queens ii puzzle problem placing queens x chessboard such no two queens attack each integer distinct solutions there two distinct solutions puzzle
the kth factor of n two positive integers factor integer defined integer i where i consider list all factors sorted ascending kth factor this list or less than k k factors list factor k factors list factor k factors list there only we should k follow could solve this problem less than
max chunks to make sorted integer array arr length represents permutation integers range we split arr into some chunks individually sort each after concatenating result should equal sorted largest chunks we can make sort arr splitting into two or more chunks not required splitting into result which arr we can split into two such splitting into highest chunks all elements arr
paint house iii there row m houses small each house must painted one colors some houses have been painted last summer should not painted neighborhood maximal group continuous houses painted same houses contains neighborhoods array m x matrix cost integer target color house house not painted cost paint house i color j minimum cost painting all remaining houses such way there exactly target not houses cost m target paint houses this way this array contains target cost paint all houses houses cost m target some houses already paint houses this way this array contains target cost paint first last house houses cost m target houses already painted total neighborhoods different target m m target m
number of adjacent elements with the same color there array nums length all elements uncolored value integer array queries where each color index indexi color colori array array answer same length queries where adjacent elements same color after ith more indices such j after ith queries initially array nums where denotes uncolored elements after query nums count adjacent elements same color after query nums count adjacent elements same color after query nums count adjacent elements same color after query nums count adjacent elements same color after query nums count adjacent elements same color queries initially array nums where denotes uncolored elements after query nums count adjacent elements same color indexi colori
most visited sector in a circular track integer integer array we have circular track which consists sectors labeled marathon held this marathon consists m ith round starts sector ends sector round starts sector ends sector array most visited sectors sorted ascending notice circulate track ascending order sector numbers direction first rounds marathon starts sector order visited sectors round round round we can see both sectors visited twice they most visited sectors visited only rounds rounds m m i m
maximum score of spliced array two integer arrays both length can choose two integers left right where left right swap subarray subarray choose left right becomes becomes may choose apply mentioned operation once or not do score arrays maximum where sum all elements array maximum possible subarray contiguous sequence elements within denotes subarray contains elements nums between indices left right choosing left right we have score choosing left right we have score we choose not swap any score
rotating the box m x matrix characters box representing each cell box one stone stationary obstacle empty box rotated degrees causing some stones fall due each stone falls down until lands another or bottom gravity does not affect inertia rotation does not affect horizontal guaranteed each stone box rests another or bottom x m matrix representing box after rotation described box box box m either or
maximum sum bst in binary tree binary tree maximum sum all keys any which also binary search tree assume bst defined left subtree node contains only nodes keys less than right subtree node contains only nodes keys greater than both left right subtrees must also binary search root maximum sum valid binary search tree obtained root node key equal root maximum sum valid binary search tree obtained single root node key equal root all values empty nodes tree range
naming a company array strings ideas represents list names used process naming process naming company choose distinct names call them ideaa swap first letters ideaa ideab each both new names not found original then name ideaa ideab concatenation ideaa separated valid company not valid distinct valid names ideas following selections company name created company name created company name created company name created company name created company name created there total distinct company following some examples invalid name formed after swapping already exists original both names still same after swapping exist original both names formed after swapping already exist original ideas there no valid consists lowercase english all strings ideas
find kth largest xor coordinate value matrix size m x consisting also integer value coordinate matrix xor all where i m j b find kth largest value all coordinates matrix k value coordinate xor which largest matrix k value coordinate which largest matrix k value coordinate xor which largest m k m
queue reconstruction by height array which attributes some people queue necessarily each represents ith person height hi exactly ki other people front who have height greater than or equal reconstruct queue represented input array returned queue should formatted array where attributes jth person queue person front people person height no other people taller or same height person height no other people taller or same height person height two persons taller or same height which person person height one person taller or same height which person person height four people taller or same height which people person height one person taller or same height which person hence reconstructed people hi ki guaranteed queue can
peeking iterator design iterator supports peek operation existing iterator addition hasnext next implement peekingiterator initializes object integer iterator int returns next element array moves pointer next boolean returns true there still elements int returns next element array without moving each language may have different implementation constructor but they all support int boolean input output explanation peekingiterator peekingiterator new pointer moves next element pointer does not move pointer moves next element pointer moves next element false all calls next peek most calls made follow how would extend your design generic work all not just
not boring movies sql schema cinema column name type id int movie varchar description varchar rating float id primary key this each row contains information about name rating decimal places float range write sql query report movies id description not result table ordered rating descending query result format following cinema id movie description rating war great science fiction irish boring ice song fantacy house card interesting id movie description rating house card interesting war great we have three movies movie id boring so we do not include
construct the rectangle web developer needs know how design web specific rectangular web your job now design rectangular web whose length l width w satisfy following area rectangular web page designed must equal target width w should not larger than length which means l difference between length l width w should small array where l w length width web page designed area target area all possible ways construct but according requirement according requirement not optimal compared so length l width w area area area
similar string groups two x considered similar either they identical or we can make them equivalent swapping most two letters distinct within string similar positions but not similar or these form two connected groups notice same group even though they not each group such word group only similar least one other word we list strs strings where every string strs anagram every other string how many groups strs strs consists lowercase letters all words strs have same length anagrams each
difference between element sum and digit sum of an array positive integer array element sum sum all elements digit sum sum all digits necessarily appear absolute difference between element sum digit sum note absolute difference between two integers x y defined nums element sum nums digit sum nums absolute difference between element sum digit sum nums element sum nums digit sum nums absolute difference between element sum digit sum
jump game ii array integers nums length initially positioned each element represents maximum length forward jump index other can jump any j i j minimum jumps reach test cases generated such can reach nums minimum jumps reach last index jump step index then steps last nums guaranteed can reach
count increasing quadruplets integer array nums size containing all numbers increasing quadruplet increasing i j k l nums when i j k l when i j k l there no other so we nums there exists only one quadruplet i j k l but since we all integers nums nums
customers who bought all products sql schema customer column name type int int there no primary key this may contain not foreign key product product column name type int primary key column this write sql query report customer ids customer table bought all products product result table any query result format following customer product customers who bought all products customers ids
big countries sql schema world column name type name varchar continent varchar area int population int gdp bigint name primary key column this each row this table gives information about name continent which gdp country big area least three million or population least million write sql query report area big result table any query result format following world name continent area population gdp afghanistan asia albania europe algeria africa andorra europe angola africa name population area afghanistan algeria
last stone weight array integers stones where weight ith we playing game each we choose heaviest two stones smash them suppose heaviest two stones have weights x y x result this smash x both stones x stone weight x stone weight y new weight y end there most one stone weight last remaining there no stones stones we combine get so array converts we combine get so array converts we combine get so array converts we combine get so array converts then value last stones
maximum score from removing stones playing solitaire game three piles stones sizes c each turn choose two different take one stone add point your game stops when there fewer than two piles there no more available three integers maximum score can b c starting state one optimal set moves take state now take state now take state now take state now take state now take state now there fewer than two so game b c starting state one optimal set moves take state now take state now take state now take state now take state now take state now take state now there fewer than two so game b c one optimal set moves take piles turns until they after there fewer than two so game c
disconnect path in a binary matrix by at most one flip m x binary matrix can move cell any cells or col value matrix disconnected there no path can flip value most one cannot flip cells true possible make matrix disconnect or false note flipping cell changes value or grid true we can change cell shown diagram there no path resulting grid false not possible change most one cell such there not path m m either or
word ladder ii transformation sequence word beginword word endword using dictionary wordlist sequence words beginword sk such every adjacent pair words differs single every si i k note beginword does not need sk endword two beginword dictionary all shortest transformation sequences beginword or empty list no such sequence each sequence should returned list words beginword endword wordlist there shortest transformation beginword endword wordlist endword not therefore there no valid transformation consist lowercase english beginword endword all words wordlist sum all shortest transformation sequences does not exceed
height of binary tree after subtree removal queries root binary tree each node assigned unique value also array queries size have perform m independent queries tree where ith query do remove subtree rooted node value guaranteed not equal value array answer size m where height tree after performing ith queries so tree returns initial state after each height tree edges longest simple path root some node root queries diagram above shows tree after removing subtree rooted node value height tree path root queries we have following removing subtree rooted node value height tree becomes path removing subtree rooted node value height tree becomes path removing subtree rooted node value height tree becomes path removing subtree rooted node value height tree becomes path nodes tree all values tree m m
destroy sequential targets array nums consisting positive representing targets also integer have machine which can destroy seeding machine some allows destroy all targets values can represented c where c any want destroy maximum targets minimum value can seed machine destroy maximum nums space we seed machine then we destroy all targets equal this we would destroy total targets except impossible destroy more than so we nums space seeding machine or destroys not possible destroy more than since minimal integer can destroy we nums space whatever initial seed we we can only destroy minimal seed space
cat and mouse game undirected graph played two mouse who alternate graph list all nodes b such ab edge mouse starts node goes cat starts node goes there hole node during each they must travel along one edge graph meets where they mouse node must travel any node not allowed cat travel hole game can end three ever cat occupies same node cat ever mouse reaches mouse ever position repeated players same position previous same turn game assuming both players play mouse wins cat wins or game graph graph i mouse cat can always
filling bookcase shelves array books where indicates thickness height ith also integer we want place these books order onto bookcase shelves have total width we choose some books place this shelf such sum their thickness less than or equal then build another level shelf bookcase so total height bookcase increased maximum height books we just put we repeat this process until there no more books note each step above order books we place same order sequence we have ordered list we might place first second book onto first third book second fourth fifth book last minimum possible height total bookshelf can after placing shelves this books shelfwidth sum heights shelves notice book does not have first books shelfwidth thicknessi shelfwidth heighti
mice and cheese there two mice different types each type cheese should eaten exactly one point cheese index i first mouse eats second mouse eats positive integer array positive integer array integer maximum points mice can achieve first mouse eats exactly k types k this first mouse eats types second mouse eats types total points can proven maximum total points mice can k this first mouse eats types second mouse does not eat any total points can proven maximum total points mice can k
minimum domino rotations for equal row row represent top bottom halves ith domino tile two numbers one each half we may rotate ith so swap minimum rotations so all values tops or all values bottoms cannot tops bottoms first figure represents dominoes tops before we do any we rotate second fourth we can make every value top row equal indicated second tops bottoms this not possible rotate dominoes make one row values
3sum closest integer array nums length integer find three integers nums such sum closest sum three may assume each input would have exactly one nums target sum closest target nums target sum closest target target
count good nodes in binary tree binary tree node x tree named good path root x there no nodes value greater than good nodes binary root nodes blue root node always good node maximum value path starting node maximum value path node maximum value root node not because higher than root root considered nodes binary tree range each value between
find the middle index in array integer array find leftmost middleindex smallest amongst all possible middleindex index where middleindex left side sum considered middleindex right side sum considered leftmost middleindex satisfies or there no such nums sum numbers before index sum numbers after index nums sum numbers before index sum numbers after index nums there no valid this question same
find right interval array where each starti right interval interval i interval j such startj endi startj note i may equal array right interval indices each interval no right interval exists interval then put index intervals there only one interval so outputs intervals there no right interval right interval since smallest start right interval since smallest start intervals there no right interval right interval since smallest start starti endi start point each interval
smallest even multiple positive integer smallest positive integer multiple both smallest multiple both smallest multiple both note multiple
delete duplicate folders in system due there many duplicate folders file array where array representing absolute path ith folder file represents path two folders necessarily same identical they contain same set identical subfolders underlying subfolder folders do not need root level two or more folders then mark folders well all their folders file structure below they well their should all file structure also included path then folders would not note would still considered identical even added once all identical folders their subfolders have been file system delete all file system only runs deletion so any folders become identical after initial deletion not array ans containing paths remaining folders after deleting all marked paths may returned any paths file structure folders their marked deletion because they both contain empty folder named paths file structure folders their marked deletion because they both contain empty folder named note folders identical after but they not deleted because they not marked paths all folders unique file note returned array can different order order does not consists lowercase english no two paths lead same any folder not root parent folder also
minimum sum of four digit number after splitting digits positive integer num consisting exactly four split num into two new integers using digits found leading zeros allowed all digits found num must num have following two one one some possible pairs minimum possible sum num some possible pairs minimum sum can obtained pair num some possible pairs minimum sum can obtained pair num
uncommon words from two sentences sentence string separated words where each word consists only lowercase word uncommon appears exactly once one does not appear other two sentences list all uncommon may answer any apple apple consist lowercase english letters do not have leading or trailing all words separated single
two sum array integers nums integer indices two numbers such they add up may assume each input would have exactly one may not use same element can answer any nums target because we nums target nums target target only one valid answer can come up algorithm less than time
palindromic substrings string palindromic substrings string palindrome when reads same backward substring contiguous sequence characters within s three palindromic s six palindromic s consists lowercase english
add minimum number of rungs strictly increasing integer array rungs represents height rungs currently floor height want reach last also integer can only climb next highest rung distance between where currently floor or next rung most able insert rungs any positive integer height rung not already minimum rungs must added ladder order climb last rungs dist currently cannot reach last add rungs heights climb this ladder now have rungs rungs dist this ladder can climbed without adding additional rungs dist currently cannot reach first rung add rung height climb this ladder now have rungs dist rungs strictly
maximum trailing zeros in a cornered path integer array grid size m x where each cell contains positive cornered path defined set adjacent cells most one more path should exclusively move either horizontally or vertically up turn there without returning previously visited after path then move exclusively alternate move vertically moved vice also without returning previously visited product path defined product all values maximum trailing zeros product cornered path found horizontal movement means moving either left or right vertical movement means moving either up or down grid grid left shows valid cornered product which trailing can shown this maximum trailing zeros product cornered grid middle not cornered path more than one grid right not cornered path requires previously visited grid grid shown figure there no cornered paths grid result product trailing m m
execution of all suffix instructions staying in a grid there x cell cell integer integer array startpos where startpos indicates robot initially cell also string s length m where ith instruction robot can begin executing any ith instruction executes instructions one one towards end s but stops either these conditions next instruction move robot off there no more instructions left array answer length m where instructions robot can execute robot begins executing ith instruction startpos s starting startpos beginning execution ith only one instruction can executed before moves off all five instructions can executed while stays grid ends all four instructions can executed while stays grid ends all three instructions can executed while stays grid ends only one instruction can executed before moves off moving would move off startpos s startpos s no matter which instruction robot begins execution would move off m m startcol s consists
minimum ascii delete sum for two strings two strings lowest ascii sum deleted characters make two strings deleting adds ascii value deleting adds both strings minimum sum possible achieve deleting turn string into adds deleting adds both strings equal answer instead we turned both strings into or we would get answers or which consist lowercase english
different ways to add parentheses string expression numbers all possible results computing all different possible ways group numbers may answer any test cases generated such output values fit integer different results does not exceed expression expression expression consists digits operator all integer values input expression range
restore ip addresses valid ip address consists exactly four integers separated single each integer between cannot have leading valid ip but invalid ip string s containing only all possible valid ip addresses can formed inserting dots into not allowed reorder or remove any digits may valid ip addresses any s s s s consists digits
two furthest houses with different colors there houses evenly lined up each house beautifully integer array colors length where represents color ith maximum distance between two houses different distance between ith jth houses where absolute value colors above color color furthest two houses different colors house house house color house color distance between them note houses can also produce optimal colors above color color color furthest two houses different colors house house house color house color distance between them colors furthest two houses different colors house house house color house color distance between them test data generated such least two houses have different
minimum falling path sum ii x integer matrix minimum sum falling path falling path shifts choice exactly one element each row grid such no two elements chosen adjacent rows same grid possible falling paths falling path smallest sum so answer grid
sort the students by their kth score there class m students m x integer matrix where each row represents one student denotes score ith student got jth matrix score contains distinct integers also integer sort students rows their scores kth exam highest matrix after sorting score k above s denotes while e denotes student index scored exam which highest so they got first student index scored exam which second highest so they got second student index scored exam which lowest so they got third score k above s denotes while e denotes student index scored exam which highest so they got first student index scored exam which lowest so they got second m score consists distinct k
max increase to keep city skyline there city composed x where each block contains single building shaped like vertical square x integer matrix grid where represents height building located block row r column skyline outer contour formed all building when viewing side city skyline each cardinal direction west may we allowed increase height any buildings any amount amount can different per height building can also increasing height building should not affect skyline any cardinal maximum total sum height buildings can increased without changing skyline any cardinal grid building heights shown center above skylines when viewed each cardinal direction drawn grid after increasing height buildings without affecting skylines gridnew grid increasing height any building result skyline
range product queries of powers positive integer there exists array called composed minimum powers sum array sorted there only one way form also integer array where each represents query where have find product all lefti j array equal length where answer ith since answer ith query may too each should returned modulo queries powers can shown powers cannot smaller answer answer answer each answer modulo yields same so queries powers answer only query answer modulo so starti endi
super palindromes say positive integer also square two positive integers left right represented integers inclusive range left right note not but not left right left right consist only left right cannot have leading left right represent integers range left less than or equal
find common characters string array array all characters show up all strings within words may answer any words words consists lowercase english
daily leads and partners sql schema dailysales column name type date varchar int int this table does not have primary this table contains date name product sold ids lead partner sold name consists only lowercase english write sql query each distinct distinct result table any query result format following dailysales toyota toyota toyota toyota toyota honda honda honda honda honda toyota toyota honda honda toyota gets leads partners while honda gets leads partners toyota gets leads partners while honda gets leads partners
find two non-overlapping sub-arrays each with target sum array integers arr integer have find two arr each sum equal there can multiple answers so have find answer where sum lengths two minimum sum lengths two required or cannot find such two arr target only two have sum sum their lengths arr target although we have three sum but we choose first third sum their lengths arr target we have only one sum target
unique binary search trees integer structurally unique search which exactly nodes unique values
video stitching series video clips sporting event lasted time these video clips can overlapping each other have varying each video clip described array clips where indicates ith clip started starti ended we can cut these clips into segments clip can cut into segments minimum clips needed so we can cut clips into segments cover entire sporting event task clips time we take clips total we can reconstruct sporting event we cut into segments now we have segments which cover sporting event clips time we cannot cover only clips time we can take clips starti endi time
partition array for maximum sum integer array partition array into subarrays length most after each subarray their values changed become maximum value largest sum array after test cases generated so answer fits arr k arr becomes arr k arr k k
cycle length queries in a tree integer there complete binary tree root tree node value every node value val range two children left node value right node value val also integer array queries length where each solve following add edge between nodes values ai find length cycle remove added edge between nodes values ai note cycle path starts ends same each edge path visited only length cycle edges visited there could multiple edges between two nodes tree after adding edge array answer length m where answer ith queries diagrams above show tree nodes colored red describe nodes cycle after adding after adding edge between nodes graph contains cycle nodes thus answer first query we delete added edge process next after adding edge between nodes graph contains cycle nodes thus answer second query we delete added edge process next after adding edge between nodes graph contains cycle nodes thus answer third query we delete added queries diagram above shows tree nodes colored red describe nodes cycle after adding after adding edge between nodes graph contains cycle nodes thus answer first query we delete added m m bi ai bi
design front middle back queue design queue supports push pop operations implement frontmiddleback initializes void adds val front void adds val middle void adds val back int removes front element queue returns queue int removes middle element queue returns queue int removes back element queue returns queue notice when there two middle position operation performed frontmost middle position pushing into middle results popping middle returns results frontmiddlebackqueue q new queue val most calls made
k highest ranked items within a price range integer array grid size m x represents map items integers grid represent represents wall cannot pass represents empty cell can freely move all other positive integers represent price item may also freely move these item takes step travel between adjacent grid also integer arrays pricing start where pricing start indicates start position interested only items price range further integer interested positions k items whose prices within price rank determined first these criteria defined length shortest path start distance higher price price higher but must price row row higher column column higher k items within price range sorted their rank there fewer than k reachable items within price all grid pricing start k start price range we can take items ranks these items distance distance distance distance highest ranked items price range grid pricing start k start price range we can take items ranks these items distance price distance price distance distance highest ranked items price range grid pricing start k start price range we can take items ranks these items distance distance highest ranked items price range note k but there only reachable items within price m m low high row m col k m
check if word can be placed in crossword m x matrix representing current state crossword crossword contains lowercase english letters solved represent any empty represent any blocked word can placed horizontally right or right or vertically bottom or bottom board does not occupy cell containing character cell each letter placed must either or match letter already there must not any empty cells or other lowercase letters directly left or right word word placed there must not any empty cells or other lowercase letters directly above or below word word placed string true word can placed or false board word true word can placed shown above board word false impossible place word because there always above or below board word true word can placed shown above m m or lowercase english word contain only lowercase english
minimum genetic mutation gene string can represented long choices suppose we need investigate mutation gene string startgene gene string endgene where one mutation defined one single character changed gene one there also gene bank bank records all valid gene gene must bank make valid gene two gene strings startgene endgene gene bank minimum mutations needed mutate startgene there no such note starting point assumed so might not included startgene endgene bank startgene endgene bank consist only characters
minimum number of taps to open to water a garden there garden garden starts point ends point length garden there taps located points integer integer array ranges length where means tap can water area i minimum taps should open water whole garden cannot watered ranges tap point can cover interval tap point can cover interval tap point can cover interval tap point can cover interval tap point can cover interval tap point can cover interval opening only second tap water whole garden ranges even activate all four taps cannot water whole
the number of full rounds you have played participating online chess there chess round starts every first round day starts after every new round second round starts fourth round starts seventh round starts two strings logintime logouttime logintime time login logouttime time logout logouttime earlier than this means have played logintime midnight midnight full chess rounds have played all times follow means first round day starts last round day starts logintime logouttime played one full round did not play full round because logged after did not play full round because logged out before logintime logouttime played full rounds full rounds logintime logouttime format hh mm logintime logouttime not
add two numbers ii two linked lists representing two most significant digit comes first each their nodes contains single add two numbers sum linked may assume two numbers do not contain any leading except nodes each linked list range guaranteed list represents does not have leading follow could solve without reversing input
sliding subarray beauty integer array nums containing find beauty each subarray size beauty subarray xth smallest integer subarray or there fewer than x negative integer array containing k which denote beauty subarrays order first index subarray contiguous sequence elements within nums k x there subarrays size k first subarray smallest negative integer second subarray smallest negative integer third subarray smallest negative integer nums k x there subarrays size k smallest negative integer smallest negative integer smallest negative integer smallest negative integer nums k x there subarrays size k smallest negative integer there no negative integer so beauty smallest negative integer smallest negative integer smallest negative integer k x k
find xor-beauty of array integer array effective value three indices k defined array xoring effective values all possible triplets indices where k note bitwise or bitwise nums triplets their corresponding effective values listed effective value effective value effective value effective value effective value effective value effective value effective value array bitwise xor all beauties nums array
filter elements from array integer array arr filtering function filtered array fn function takes one or two arr i index filteredarr should only contain elements arr which expression evaluates truthy truthy value value where returns please solve without arr fn function const newarray function filters out values not greater than arr fn function i fn can also accept index each element this function removes elements not index arr fn function falsey values such should filtered out
minimum lines to represent a line chart integer array stockprices where indicates price stock day dayi line chart created array plotting points xy plane representing day representing price connecting adjacent one such shown minimum lines needed represent line stockprices diagram above represents representing day representing following lines can drawn represent line line passing through line line passing through can shown not possible represent line chart using less than stockprices shown diagram line chart can represented single pricei all dayi
jewels and stones strings jewels representing types stones stones representing stones each character stones type stone want know how many stones have also letters case so considered different type stone jewels stones jewels stones jewels stones consist only english all characters jewels
can make palindrome from substring string s array queries where we may rearrange substring each query then choose up ki them replace any lowercase english substring possible palindrome string after operations result query result boolean array answer where result ith query note each letter counted individually so ki we can only replace two note no query modifies initial string s queries substring substring not substring not palidrome after replacing only substring could changed which also this can changed first rearrange then replace substring could changed which s queries lefti righti ki s consists lowercase english
minimum numbers of function calls to make target array integer array have integer array arr same length all values set also have following modify want use modify function convert arr nums using minimum minimum function calls make nums test cases generated so answer fits signed nums increment get double all increment total nums increment double all total nums
pseudo-palindromic paths in a binary tree binary tree where node values digits path binary tree said least one permutation node values path paths going root node leaf root figure above represents binary there three paths going root node leaf red path green path path among these paths only red path green path paths since red path can rearranged green path can rearranged root figure above represents binary there three paths going root node leaf green path path path among these paths only green path since can rearranged root nodes tree range
k inverse pairs array integer array inverse pair pair integers where i j two integers different arrays consist numbers such there exactly k inverse since answer can modulo k only array which consists numbers exactly inverse k array have exactly inverse k
find bottom left tree value root binary leftmost value last row root root nodes tree range
max sum of rectangle no larger than k m x matrix matrix integer max sum rectangle matrix such sum no larger than guaranteed there rectangle sum no larger than matrix k because sum blue rectangle max no larger than k matrix k m k follow what rows much larger than
super ugly number super ugly positive integer whose prime factors array integer array integers nth super ugly nth super ugly guaranteed fit signed primes sequence first super ugly numbers primes primes no prime therefore all prime factors array primes guaranteed prime all values primes unique sorted ascending
car fleet there cars going same destination along destination target miles two integer array position both length where position ith car speed ith car miles per car can never pass another car ahead but can catch up drive bumper bumper same faster car slow down match slower distance between these two cars ignored they assumed have same car fleet some set cars driving same position same note single car also car car catches up car fleet right destination still considered one car car fleets arrive target position speed cars starting become meeting each other car starting does not catch up any other so fleet cars starting become meeting each other fleet moves speed until reaches note no other cars meet these fleets before so answer target position speed there only one hence there only one target position speed cars starting become meeting each other fleet moves speed fleet car starting become one meeting each other fleet moves speed until reaches target target all values position
reducing dishes chef collected data satisfaction level his chef can cook any dish unit coefficient dish defined time taken cook dish including previous dishes multiplied satisfaction level maximum sum coefficient chef can obtain after dishes dishes can prepared any order chef can discard some dishes get this maximum satisfaction after removing second last maximum total coefficient equal each dish prepared one unit satisfaction dishes can prepared any satisfaction people do not like no dish
minimum cost for tickets have planned some train traveling one year days year which travel integer array each day integer train tickets sold three different pass sold pass sold pass sold passes allow many days consecutive we get pass day then we can travel minimum dollars need travel every day list days costs here one way buy passes lets travel your travel day bought pass which covered day day bought pass which covered days day bought pass which covered day spent covered all days your days costs here one way buy passes lets travel your travel day bought pass which covered days day bought pass which covered day spent covered all days your days strictly increasing
stone game vi alice bob take turns playing alice starting there stones each they can remove stone pile receive points based alice bob may value stones two integer arrays length alicevalues each represents how alice value ith winner person most points after all stones both players have same amount game results both players play both players know determine result alice bob game results alicevalues bobvalues alice takes stone alice receive bob can only choose stone only receive alice alicevalues bobvalues alice takes stone bob takes stone they both have alicevalues bobvalues regardless how alice bob able have more points than alice takes stone bob can take stone alice takes stone alice have points bob
max sum of a pair with equal sum of digits array nums consisting positive can choose two indices i such i sum digits equal maximum value can obtain over all possible indices i j satisfy nums pairs satisfy conditions both numbers have sum digits equal their sum both numbers have sum digits equal their sum so maximum sum we can obtain nums there no two numbers satisfy so we
count number of special subsequences sequence special consists positive followed positive then positive not array nums only integers different subsequences since answer may very modulo subsequence array sequence can derived array deleting some or no elements without changing order remaining two subsequences different set indices chosen nums special subsequences bolded nums there no special subsequences nums special subsequences
make array strictly increasing two integer arrays minimum operations needed make strictly one can choose two indices i j do assignment there no way make strictly replace then replace then replace make strictly
rank teams by votes special ranking each voter gives rank highest lowest all teams participating ordering teams decided who received most two or more teams tie first we consider second position resolve they tie we continue this process until ties two or more teams still tied after considering all we rank them alphabetically based their team array strings votes which votes all voters ranking sort all teams according ranking system described string all teams sorted ranking votes team ranked first place no other team voted first so team first team b ranked second voters ranked third team c ranked second voters ranked third most voters ranked c team c second team b votes x winner due x same votes w first but x one vote second while w does not have any votes second votes only one so their votes used j english uppercase all characters all characters occur also occur where j
put marbles in bags have k integer array weights where weight ith also integer divide marbles into k bags according following no bag ith marble jth marble then all marbles index between ith jth indices should also same bag consists all marbles index i j then cost bag score after distributing marbles sum costs all k difference between maximum minimum scores among marble weights k distribution results minimal score distribution results maximal score we their difference weights k only distribution possible since both maximal minimal score we k
count ways to make array with product integer each where find different ways can place positive integers into array size ni such product integers ways may too answer ith query ways modulo integer array answer where answer ith queries each query there ways fill array size multiply there way fill array size multiply there ways fill array size multiply modulo queries ki
sort the jumbled numbers integer array mapping which represents mapping rule shuffled decimal j means digit i should mapped digit j this mapped value integer new integer obtained replacing each occurrence digit i integer all i also another integer array array nums sorted order based mapped values elements same mapped values should appear same relative order elements nums should only sorted based their mapped values not replaced mapping nums map so all occurrences digit become so all occurrences digit become mapped value maps or after removing leading maps which also after removing leading since share same mapped they should remain same relative so comes before sorted array mapping nums maps maps maps sorted array all values
can you eat your favorite candy on your favorite day? array positive integers candiescount where represents candies ith type also array queries where play game following start eating candies day cannot eat any candy type i unless have eaten all candies type i must eat least one candy per day until have eaten all construct boolean array answer such true can eat candy type favoritetypei day favoritedayi without eating more than dailycapi candies any false note can eat different types candy same provided follow rule constructed array candiescount queries eat candies day candies day eat candy type day can eat most candies each eat candies every eat candies day candies type day day can only eat candies type so cannot eat candy type day eat candy each eat candy type day candiescount queries favoritetypei favoritedayi dailycapi
sum of two integers two integers sum two integers without using operators b b b
minimum deletions to make character frequencies unique string s called good there no two different characters s have same string minimum characters need delete make s frequency character string times appears string frequency while frequency s s already s can delete two resulting good string another way delete one one resulting good string s can delete both resulting good string note we only care about characters still string end frequency s contains only lowercase english
maximum distance between a pair of values two integer arrays pair indices where i j valid both i j distance pair j maximum distance any valid pair there no valid array arr every i valid pairs maximum distance pair valid pairs maximum distance pair valid pairs maximum distance pair both
push dominoes there dominoes we place each domino vertically we simultaneously push some dominoes either left or after each each domino falling left pushes adjacent domino dominoes falling right push their adjacent dominoes standing when vertical domino dominoes falling both stays still due balance purposes this we consider falling domino expends no additional force falling or already fallen string dominoes representing initial state ith domino been pushed ith domino been pushed ith domino not been string representing final dominoes first domino expends no additional force second dominoes either or
matrix cells in distance order four integers there rows x cols matrix cell coordinates coordinates all cells sorted their distance smallest distance largest may answer any order satisfies this distance between two cells rows cols rcenter ccenter distances other cells rows cols rcenter ccenter distances other cells answer would also accepted rows cols rcenter ccenter distances other cells there other answers would also accepted such cols rcenter rows ccenter cols
maximum area of a piece of cake after horizontal and vertical cuts rectangular cake size h x w two arrays integers horizontalcuts verticalcuts distance top rectangular cake ith horizontal cut distance left rectangular cake jth vertical maximum area piece cake after cut each horizontal vertical position provided arrays horizontalcuts since answer can large this modulo h w horizontalcuts verticalcuts figure above represents rectangular red lines horizontal vertical after cut green piece cake maximum h w horizontalcuts verticalcuts figure above represents rectangular red lines horizontal vertical after cut green yellow pieces cake have maximum h w horizontalcuts verticalcuts w h w all elements horizontalcuts all elements verticalcuts
design a food rating system design food rating system can do modify rating food item listed food item type cuisine implement foodratings initializes food items described cuisines all which have length name ith type cuisine ith initial rating ith void int changes rating food item name string returns name food item highest rating type there item lexicographically smaller note string x lexicographically smaller than string y x comes before y dictionary either x prefix or i first position such then comes before alphabetic input output explanation foodratings foodratings new highest rated korean food rating highest rated japanese food rating now rating highest rated japanese food rating now rating both have rating lexicographically smaller than consist lowercase english all strings foods food name food item system across all calls cuisine type cuisine least one food item system across all calls most calls total made changerating
sorting the sentence sentence list words separated single space no leading or trailing each word consists lowercase uppercase english sentence can shuffled appending word position each word then rearranging words sentence can shuffled or shuffled sentence s containing no more than reconstruct original s sort words s their original positions then remove s myself sort words s their original positions then remove s consists lowercase uppercase english digits words s between words s separated single s contains no leading or trailing
count binary substrings binary string substrings have same all all these substrings grouped substrings occur multiple times counted times they s there substrings have equal consecutive notice some these substrings repeat counted times they not valid substring because all not grouped s there have equal consecutive either or
shortest path in a grid with obstacles elimination m x integer matrix grid where each cell either or can move or right empty cell one minimum steps walk upper left corner lower right corner can eliminate most k not possible find such walk grid k shortest path without eliminating any obstacle shortest path one obstacle elimination position such path grid k we need eliminate least two obstacles find such m k m either or
path with maximum gold gold mine grid size m x each cell this mine integer representing amount gold maximum amount gold can collect under every time located cell collect all gold your can walk one step or visit same cell more than never visit cell can start stop collecting gold any position grid some grid path get maximum grid path get maximum m there most cells containing
evaluate reverse polish notation array strings tokens represents arithmetic expression reverse polish evaluate integer represents value note valid operators each operand may integer or another division between two integers always truncates toward there not any division input represents valid arithmetic expression reverse polish answer all intermediate calculations can represented tokens tokens tokens either or or integer range
convert to base -2 integer binary string representing representation base note returned string should not have leading zeros unless string
reorganize string string rearrange characters s so any two adjacent characters not any possible rearrangement s or not s s s consists lowercase english
average time of process per machine sql schema activity column name type int int enum timestamp float table shows user activities factory primary key this id id process running machine id enum type timestamp float representing current time means machine starts process timestamp means machine ends process timestamp always before timestamp every there factory website several machines each running same write sql query find average time each machine takes complete time complete process timestamp minus average time calculated total time complete every process machine divided processes resulting table should have along average time which should rounded decimal result table any query result format following activity timestamp start end start end start end start end start end start end there machines running processes machine average time machine average time machine average time
investments in 2016 sql schema insurance column name type pid int float float lat float lon float pid primary key column this each row this table contains information about one policy pid policy total investment value total investment value lat latitude policy guaranteed lat not lon longitude policy guaranteed lon not write sql query report sum all total investment values all policyholders have same value one or more other not located same city like any other policyholder attribute pairs must round two decimal query result format following insurance pid lat lon first record like last meets both two value same third fourth location second record does not meet any two not like any other policyholders location same third which makes third record result sum first last which
find the town judge there people labeled there rumor one these people secretly town town judge town judge trusts everybody town trusts town there exactly one person satisfies properties array trust where representing person labeled ai trusts person labeled trust relationship does not exist trust then such trust relationship does not label town judge town judge exists can or trust trust trust all pairs trust ai bi bi
number of different subsequences gcds array nums consists positive gcd sequence numbers defined greatest integer divides all numbers sequence gcd sequence subsequence array sequence can formed removing some elements subsequence different gcds among all subsequences nums figure shows all subsequences their different gcds nums
divide intervals into minimum number of groups integer array intervals where represents inclusive interval have divide intervals into one or more groups such each interval exactly one no two intervals same group intersect each minimum groups need two intervals intersect there least one common between intervals intervals we can divide intervals into following group group group can proven not possible divide intervals into fewer than intervals none intervals so we can put all them one lefti righti
minimum operations to make array equal ii two integer arrays equal length integer can perform following operation choose two indexes i j increment k decrement other k said equal all indices i such i minimum operations required make equal impossible make them k we can transform i j after applying i j after applying one can prove impossible make arrays equal fewer k can proved impossible make two arrays k
employee bonus sql schema employee column name type empid int name varchar supervisor int salary int empid primary key column this each row this table indicates name id employee addition their salary id their bonus column name type empid int bonus int empid primary key column this empid foreign key empid employee each row this table contains id employee their respective write sql query report name bonus amount each employee bonus less than result table any query result format following employee empid name supervisor salary brad null john dan thomas bonus empid bonus name bonus brad null john null dan
match substring after replacement two strings s also character array mappings where indicates may perform following operation any replace character oldi sub each character sub cannot replaced more than true possible make sub substring s replacing zero or more characters according substring contiguous sequence characters within s sub mappings true replace first sub sub now sub substring so we s sub mappings false string not substring s no replacements can note we cannot replace s sub mappings true replace first second sub sub now sub substring so we oldi newi s sub consist uppercase lowercase english letters oldi newi either uppercase or lowercase english letters or
vowel spellchecker we want implement spellchecker converts query word into correct query spell checker handles two categories spelling query matches word wordlist then query word returned same case case wordlist query correct wordlist query correct wordlist query correct vowel after replacing vowels query word any vowel matches word wordlist then query word returned same case match wordlist query correct wordlist query correct wordlist query correct spell checker operates under following precedence when query exactly matches word wordlist should same word when query matches word up should first such match when query matches word up vowel should first such match query no matches should empty some list words where correct word query wordlist queries wordlist queries consist only only english
maximum running time of n computers have integer integer array batteries where ith battery can run computer interested running all computers simultaneously using can insert most one battery into each after any integer time can remove battery computer insert another battery any inserted battery can totally new battery or battery another may assume removing inserting processes take no note batteries cannot maximum minutes can run all computers batteries insert battery into first computer battery into second after two remove battery second computer insert battery note battery can still run one end third battery need remove first computer insert battery end fourth battery also first computer no longer we can run two computers simultaneously most so we batteries insert battery into first computer battery into second after one battery battery drained so need remove them insert battery into first computer battery into second after another battery battery also drained so first second computers no longer we can run two computers simultaneously most so we
find positive integer solution for a given equation callable function hidden formula value reverse engineer formula all positive integer pairs x y where may pairs any while exact formula function monotonically y function interface defined like interface customfunction returns some positive integer two positive integers x y based int int we judge your solution judge list hidden implementations along way generate answer key all valid pairs specific judge receive two determine which implementation test your code target judge call your findsolution compare your results answer your results match answer your solution z hidden formula x following positive integer values x y make equal z hidden formula x following positive integer values x y make equal z guaranteed solutions z range y also guaranteed fit bit signed integer y
sum of nodes with even-valued grandparent root binary sum values nodes there no nodes grandparent node parent parent root red nodes nodes grandparent while blue nodes root nodes tree range
magical string magical string s consists only obeys following string s magical because concatenating contiguous occurrences characters generates string s first few elements s s we group consecutive occurrences or each group can see occurrence sequence s integer first magical string first elements magical string s contains three so
equal row and column pairs x integer matrix pairs such row ri column cj row column pair considered equal they contain same elements same order equal grid there equal row column column grid there equal row column column column column
odd even jump integer array some starting can make series jumps series called jumps series called note jumps not may jump forward index i index j i following during jumps jumps jump index j such smallest possible there multiple such indices can only jump smallest such index during jumps jumps jump index j such largest possible there multiple such indices can only jump smallest such index may case some index there no legal starting index good starting can reach end array jumping some times or more than good starting arr starting index i we can make our jump i smallest among greater or equal then we cannot jump any starting index i i we can make our jump i then we cannot jump any starting index i we can make our jump i so we have reached starting index i we have reached end there different starting indices i i where we can reach end some arr starting index i we make jumps i i i during our jump we first jump i because smallest value greater than or equal during our jump we jump i i because largest value less than or equal also largest but smaller so we can only jump i not i during our jump we jump i i because smallest value greater than or equal we jump i i so starting index i not similar we can deduce starting index i we jump i so we reach starting index i we jump i then we jump starting index i we jump i so we reach starting index i we already there different starting indices i i i where we can reach end some arr we can reach end starting indices
diameter of binary tree root binary length diameter diameter binary tree length longest path between any two nodes this path may or may not pass through length path between two nodes represented edges between root length path or root nodes tree range
most frequent even element integer array most frequent even there smallest there no such nums even elements appear we smallest which nums even element appears nums there no even
append k integers with minimal sum integer array nums integer append k unique positive integers do not appear nums nums such resulting total sum sum k integers appended nums k two unique positive integers do not appear nums which we append resulting sum nums which sum two integers appended so we nums k six unique positive integers do not appear nums which we append resulting sum nums which sum six integers appended so we k
strong password checker ii password said strong satisfies all following least contains least one lowercase contains least one uppercase contains least one contains least one special special characters characters following does not contain same character adjacent positions violates this but does string true strong password true password meets all we password false password does not contain digit also contains same character adjacent we password false password does not meet length we password consists special
count artifacts that can be extracted there x grid some artifacts buried integer integer array artifacts describing positions rectangular artifacts where denotes ith artifact buried subgrid coordinate cell ith artifact coordinate cell ith excavate some cells grid remove all mud cell part artifact buried all parts artifact can extract integer array dig where indicates excavate cell artifacts can test cases generated such no two artifacts each artifact only covers most entries dig artifacts dig different colors represent different excavated cells labeled there artifact can namely red blue artifact one part cell which remains so we cannot extract we artifacts dig both red blue artifacts have all parts uncovered can so we ci no two artifacts cells covered artifact most entries dig
building h2o there two kinds oxygen your goal group these threads form water there barrier where each thread wait until complete molecule can hydrogen oxygen threads releasehydrogen releaseoxygen methods which allow them pass these threads should pass barrier groups they must immediately bond each other form water must guarantee all threads one molecule bond before any other threads next molecule other oxygen thread arrives barrier when no hydrogen threads must wait two hydrogen hydrogen thread arrives barrier when no other threads must wait oxygen thread another hydrogen we do not have worry about matching threads up threads do not necessarily know which other threads they paired up key threads pass barriers complete we examine sequence threads bind divide them into groups each group should contain one oxygen two hydrogen write synchronization code oxygen hydrogen molecules enforces these water also valid water also valid either or there exactly there exactly
minimum skips to arrive at meeting on time integer hours have travel your arrive your have travel through road lengths integer array dist length where describes length ith road integer which speed travel after travel road must rest wait next integer hour before can begin traveling next note do not have rest after traveling last road because already traveling road takes must wait until hour mark before traveling next traveling road takes exactly do not need allowed skip some rests able arrive meaning do not need wait next integer note this means may finish traveling future roads different hour suppose traveling first road takes hours traveling second road takes skipping rest after first road mean finish traveling second road right hour letting start traveling third road minimum skips required arrive meeting or dist speed hoursbefore without skipping any arrive can skip first rest arrive note second rest shortened because finish traveling second road integer hour due skipping first dist speed hoursbefore without skipping any arrive can skip first third rest arrive dist speed hoursbefore impossible arrive meeting time even skip all speed hoursbefore
network delay time network labeled also list travel times directed edges where ui source vi target wi time takes signal travel source we send signal node minimum time takes all nodes receive impossible all nodes receive times k times k times k k vi ui vi wi all pairs no multiple
my calendar iii happens when k events have some intersection there some time common all k some events after each integer k representing maximum between all previous implement mycalendarthree initializes int int returns integer k representing largest integer such there exists input output explanation mycalendarthree mycalendarthree new starttime endtime most calls made
non-negative integers without consecutive ones positive integer integers range whose binary representations do not contain consecutive here integers their corresponding binary among only integer disobeys rule consecutive other satisfy
smallest string with swaps string array pairs indices string pairs where indicates can swap characters any pair indices pairs any lexicographically smallest string s can changed after using s pairs swap s swap s s pairs swap s swap s swap s s pairs swap s swap s swap s s only contains lower case english
split linked list in parts head singly linked list integer split linked list into k consecutive linked list length each part should equal no two parts should have size differing more than this may lead some parts being parts should order occurrence input parts occurring earlier should always have size greater than or equal parts occurring array k head k first element last element but string representation listnode head k input been split into consecutive parts size difference most earlier parts larger size than later nodes list range k
single number iii integer array which exactly two elements appear only once all other elements appear exactly find two elements appear only can answer any must write algorithm runs linear runtime complexity uses only constant extra nums also valid nums nums each integer nums appear only two integers appear
minimum time to complete all tasks there computer can run unlimited tasks same integer array tasks where indicates ith task should run total durationi seconds necessarily within inclusive time range may turn computer only when needs run can also turn off minimum time during which computer should turned complete all tasks first task can run inclusive time range second task can run inclusive time range third task can run two inclusive time ranges computer total tasks first task can run inclusive time range second task can run inclusive time ranges third task can run two inclusive time range computer total endi durationi endi starti
maximum value of a string in an array value alphanumeric string can defined numeric representation string base comprises digits length array strs alphanumeric maximum value any string strs consists both letters so value consists only so value also consists only so value numeric also consists only so value consists only so value maximum value strs each string array value we consists only lowercase english letters
cheapest flights within k stops there cities connected some array flights where indicates there flight city fromi city toi cost also three integers cheapest price src dst most k there no such flights src dst k graph shown optimal path most stop city marked red cost note path through cities cheaper but invalid because uses flights src dst k graph shown optimal path most stop city marked red cost flights src dst k graph shown optimal path no stops city marked red cost toi fromi toi pricei there not any multiple flights between two k src dst
redistribute characters to make all strings equal array strings words one pick two distinct indices i where move any character any position true can make every string words equal using any false words true move first front make all strings now equal so words false impossible make all strings equal using consists lowercase english
maximum number of tasks you can assign have tasks m each task strength requirement stored integer array ith task requiring strength strength each worker stored integer array jth worker having each worker can only assigned single task must have strength greater than or equal strength requirement have pills magical pills increase strength can decide which workers receive magical may only give each worker most one magical integer arrays tasks workers integers pills maximum tasks can tasks workers pills strength we can assign magical pill tasks give magical pill worker assign worker task assign worker task assign worker task tasks workers pills strength we can assign magical pill tasks give magical pill worker assign worker task tasks workers pills strength we can assign magical pills tasks give magical pill worker worker assign worker task assign worker task last pill not because not make any worker strong enough last m m pills m strength
sentence similarity iii sentence list words separated single space no leading or trailing world hello all words consist only uppercase lowercase english two sentences similar possible insert arbitrary sentence inside one these sentences such two sentences become my name can made equal inserting name between two sentences true name true can turned inserting between lot false no single sentence can inserted inside one sentences make equal right true can turned inserting end consist lowercase uppercase english letters words separated single
find first and last position of element in sorted array array integers nums sorted find starting ending position target target not found must write algorithm runtime nums target nums target nums target nums target
reverse substrings between each pair of parentheses string s consists lower case english letters reverse strings each pair matching starting innermost your result should not contain any s s substring reversed then whole string s we reverse substring then whole s only contains lower case english characters guaranteed all parentheses
check knight tour configuration there knight x valid knight starts cell board visits every cell board exactly x integer matrix grid consisting distinct integers range where indicates cell cell knight moves true grid represents valid configuration movements or false note valid knight move consists moving two squares vertically one square or two squares horizontally one square figure below illustrates all possible eight moves knight some grid true above diagram represents can shown valid grid false above diagram represents move knight not valid considering position after all integers grid
detect squares stream points design algorithm adds new points stream into data duplicate points allowed should treated different query counts ways choose three points data structure such three points query point form square positive square square whose edges all same length either parallel or perpendicular implement detectsquares initializes object empty data void adds new point point data int counts ways form squares point point described input output explanation detectsquares detectsquares new can third points query point cannot form square any points data adding duplicate points can third points fourth points y most calls total made add
minimum insertion steps to make a string palindrome string one step can insert any character any index minimum steps make s palindrome string one reads same backward well s string already palindrome we do not need any s string can or s inserting characters string becomes s consists lowercase english
sliding window maximum array integers there sliding window size k which moving very left array very can only see k numbers each time sliding window moves right one max sliding nums k window position max nums k k
maximum number of ways to partition an array integer array nums length ways partition nums pivot indices satisfy both pivot also integer can choose change value one element nums or leave array maximum possible ways partition nums satisfy both conditions after changing most one nums k one optimal approach change array becomes there one way partition pivot we have partition nums k optimal approach leave array there two ways partition pivot we have partition pivot we have partition nums k one optimal approach change array becomes there four ways partition
minimum number of operations to make all array elements equal to 1 array nums consisiting positive can do following operation array any select index i such i replace either or their gcd minimum operations make all elements nums equal gcd two integers greatest common divisor two nums we can do following choose index i replace now we have nums choose index i replace now we have nums choose index i replace now we have nums choose index i replace now we have nums nums can shown impossible make all elements equal time complexity solution but could find constant time complexity
number of boomerangs points plane all where boomerang tuple points such distance between i j equals distance between i k order tuple points two boomerangs points points yi all points
escape a large maze there million million grid coordinates each grid square we start source square want reach target there also array blocked where each represents blocked square coordinates each we can walk one square or west square not array blocked we also not allowed walk outside true only possible reach target square source square through sequence valid blocked source target false target square inaccessible starting source square because we cannot we cannot move north or east because those squares we cannot move south or west because we cannot go outside blocked source target true because there no blocked possible reach target yi ty source target guaranteed source target not
group by write code enhances all arrays such can call method any array grouped version grouped array object where each key output each value array containing all items original array provided callback fn accept item array string order each value list should order items appear any order keys please solve without array fn function output selector function gets out each item there two objects both those objects put first there one object object put second array fn function array can any this selector function defines key being first element all arrays have their first element so they grouped array fn function selector function splits array whether each greater than fn returns string
maximum nesting depth of two valid parentheses strings string valid parentheses string only consists characters empty or can written ab concatenated where b or can written where we can similarly define nesting depth any vps s where b where nesting depths not vps split into two disjoint subsequences such b now choose any such b such minimum possible answer array length encodes such choice part else note even though multiple answers may may any seq seq
reverse linked list ii head singly linked list two integers left right where left reverse nodes list position left position reversed head left right head left right nodes list left right follow could do one
longest word in dictionary through deleting string s string array longest string dictionary can formed deleting some string there more than one possible longest word smallest lexicographical there no possible empty s dictionary s dictionary s consist lowercase english
nth magical number positive integer magical divisible either or three integers nth magical since answer may very modulo b b b
truncate sentence sentence list words separated single space no leading or trailing each words consists only uppercase lowercase english letters world hello all sentence s integer want truncate s such contains only first k s after truncating s how k how words s first words should how s solution this k words s first words should s not k not k range words s consist only lowercase uppercase english letters words s separated single there no leading or trailing
majority element ii integer array size find all elements appear more than nums nums nums follow could solve problem linear time
minimum suffix flips binary string target length have another binary string s length initially set all want make s equal one can pick index i where i flip all bits inclusive range flip means changing minimum operations needed make s equal target s choose index i choose index i choose index i we need least flip operations form target s choose index i choose index i choose index i we need least flip operations form target we do not need any operations since initial s already equals either or
check if number has equal digit count and digit value string num length consisting true every index i range i digit i occurs times otherwise num true digit occurs once digit occurs twice digit occurs once digit occurs zero times condition holds true every index so num false digit should occur zero but actually occurs twice digit should occur three but actually occurs zero times digit occurs zero times indices both violate so num consists
restaurant growth sql schema customer column name type int name varchar date amount int primary key this this table contains data about customer transactions date which customer id visited amount total paid restaurant owner want analyze possible expansion least one customer every write sql query compute moving average how much customer paid seven days window current day days should rounded two decimal result table ordered ascending query result format following customer name amount jhon daniel jade khaled winston elvis anna maria jaze jhon jade amount moving average moving average moving average moving average
grid game array grid size x where represents points position two robots playing game this both robots initially start want reach each robot may only move right c or down start first robot moves collecting all points cells all cells traversed set second robot moves collecting points note their paths may intersect one first robot wants minimize points collected second second robot wants maximize points both robots play points collected second grid optimal path taken first robot shown optimal path taken second robot shown cells visited first robot set second robot collect grid optimal path taken first robot shown optimal path taken second robot shown cells visited first robot set second robot collect grid optimal path taken first robot shown optimal path taken second robot shown cells visited first robot set second robot collect
binary search array integers nums which sorted ascending integer write function search target target then must write algorithm runtime nums target exists nums index nums target does not exist nums so target all integers nums nums sorted ascending
swim in rising water x integer matrix grid where each value represents elevation point rain starts time depth water everywhere can swim square another adjacent square only elevation both squares individually most can swim infinite distances zero must stay within boundaries grid during your least time until can reach bottom right square start top left square grid time grid location cannot go anywhere else because adjacent neighbors have higher elevation than t cannot reach point until time when depth water we can swim anywhere inside grid final route we need wait until time so each value
replace elements in an array array nums consists distinct positive apply m operations this where ith operation replace guaranteed ith exists does not exist array obtained after applying all nums operations we perform following operations replace nums becomes replace nums becomes replace nums becomes we final array nums operations we perform following operations replace nums becomes replace nums becomes replace nums becomes we array m m all values nums exist nums when applying ith not exist nums when applying ith
maximum non negative product in a matrix m x matrix located corner each can only move right or down among all possible paths starting corner ending corner find path maximum product path product all integers grid cells visited along maximum product modulo maximum product notice modulo performed after getting maximum grid not possible get product path so grid maximum product shown grid maximum product shown m
maximum subarray sum with one deletion array maximum sum subarray most one element other want choose subarray optionally delete one element so there still least one element left sum remaining elements maximum note subarray needs after deleting one arr because we can choose drop thus subarray becomes maximum arr we just choose maximum arr final subarray needs choose delete then get empty subarray make sum equals
remove duplicate letters string remove duplicate letters so every letter appears once only must make sure your result smallest lexicographical order among all possible s s s consists lowercase english this question same
find the k-sum of an array integer array nums positive integer can choose any subsequence array sum all elements we define array kth largest subsequence sum can obtained necessarily subsequence array can derived another array deleting some or no elements without changing order remaining note empty subsequence considered have sum nums k all possible subsequence sums we can obtain following sorted decreasing array nums k array k
project employees i sql schema project column name type int int primary key this foreign key employee each row this table indicates employee working project employee column name type int name varchar int primary key this guaranteed not each row this table contains information about one write sql query reports average experience years all employees each rounded result table any query result format following project employee name khaled ali john doe average experience years first project second project
minimize the maximum difference of pairs integer array nums integer find p pairs indices nums such maximum difference amongst all pairs ensure no index appears more than once amongst p note pair elements index i difference this pair where represents absolute value minimum maximum difference among all p we define maximum empty set nums p first pair formed indices second pair formed indices maximum difference we nums p let indices form difference pair which minimum we can p
lru cache design data structure follows constraints least recently used implement lrucache initialize lru cache positive size int value key key otherwise void int update value key key add pair keys exceeds capacity this evict least recently used functions get put must each run average time input output explanation lrucache lrucache new cache cache lru key evicts key cache returns lru key evicts key cache capacity key value most calls made get
count all possible routes array distinct positive integers locations where represents position city also integers finish fuel representing starting ending initial amount fuel each city can pick any city j such j i j move city moving city i city j reduces amount fuel have please notice denotes absolute value notice fuel cannot become negative any point allowed visit any city more than once start count all possible routes start since answer may too modulo locations start finish fuel following all possible each uses units locations start finish fuel following all possible used fuel used fuel used fuel used fuel used fuel locations start finish fuel impossible get using only units fuel since shortest route needs units all integers locations finish fuel
find largest value in each tree row root binary array largest value each row tree root root nodes tree range
find customer referee sql schema customer column name type id int name varchar int id primary key column this each row this table indicates id their id customer who referred write sql query report names customer not referred customer id result table any query result format following customer id name null jane null alex bill null zack mark name jane bill zack
most popular video creator two string arrays creators integer array all length ith video platform created id popularity creator sum views all find creator highest popularity id their most viewed multiple creators have highest find all multiple videos have highest view count find lexicographically smallest array strings answer where means creatori highest popularity idi id their most popular answer can returned any creators ids views popularity alice popularity bob popularity chris alice bob most popular video highest view count videos highest view count since lexicographically smaller than included creators ids views videos id have highest view since lexicographically smaller than included consist only lowercase english
maximum product of word lengths string array maximum value where two words do not share common no such two words words two words can words two words can words no such pair consists only lowercase english
sort integers by the power value power integer x defined steps needed transform x into using following x even then x x x odd then x x power x because needs steps become three integers hi task sort all integers interval power value ascending two or more integers have same power value sort them ascending kth integer range sorted power notice any integer x x guaranteed x transform into using these steps power x fit signed lo hi k power power power power interval sorted power value k answer second element which notice have same power value we sorted them ascending same lo hi k power array corresponding interval interval sorted power fourth sorted array lo hi k hi lo
shortest completing word string licenseplate array strings find shortest completing word completing word word contains all letters ignore numbers spaces treat letters case letter appears more than once then must appear word same times or licenseplate then contains letters possible completing words shortest completing word guaranteed answer there multiple shortest completing first one occurs licenseplate words licenseplate contains letters contains but only contains contains both missing missing since only word containing all licenseplate words licenseplate only contains letter all words contain but among these answer because word appears earliest licenseplate contains letters or or space consists lower case english
maximum score of a node sequence there undirected graph numbered integer array scores length where denotes score node also integer array edges where denotes there exists undirected edge connecting nodes ai node sequence valid meets following there edge connecting every pair adjacent nodes no node appears more than once score node sequence defined sum scores nodes maximum score valid node sequence length no such sequence scores edges figure above shows graph chosen node sequence score node sequence can shown no other node sequence score more than note sequences also valid have score sequence not valid since no edge connects nodes scores edges figure above shows there no valid node sequences length so we bi ai bi there no duplicate
split the array to make coprime products integer array nums length split index i where i called valid product first i elements product remaining elements nums then split index i valid because while split index i not valid because not split index i not valid because i smallest index i which array can split validly or there no such two values coprime where greatest common divisor nums table above shows values product first i remaining their gcd each index only valid split index nums table above shows values product first i remaining their gcd each index there no valid
minimum number of steps to make two strings anagram two strings same length s one step can choose any character t replace another minimum steps make t anagram anagram string string contains same characters different s t replace first t t which anagram s t replace t proper characters make t anagram s t s t consist lowercase english letters
minimum number of swaps to make the binary string alternating binary string minimum character swaps make or string called alternating no two adjacent characters strings while string any two characters may even they not s swap positions string now s string already no swaps s either or
element appearing more than 25% in sorted array integer array sorted there exactly one integer array occurs more than arr arr
most common word string paragraph string array banned words most frequent word not guaranteed there least one word not answer words paragraph answer should returned paragraph hit hit ball flew far after banned occurs but banned occurs twice no other word so most frequent word note words paragraph not case punctuation ignored adjacent such answer even though occurs more because paragraph banned paragraph consists english space or one consists only lowercase english
contains duplicate integer array true any value appears least twice false every element nums true nums false nums true
count subarrays with score less than k score array defined product sum score positive integer array nums integer subarrays nums whose score strictly less than subarray contiguous sequence elements within nums k subarrays having scores less than score score score score score score note subarrays such not considered because their scores while we need scores strictly less than nums k every subarray except score less than score which greater than there subarrays having scores less than k
minimize deviation in array array nums positive can perform two types operations any element array any element divide array then can do this operation last array element multiply array then can do this operation first array deviation array maximum difference between any two elements minimum deviation array can have after performing some nums can transform array then then deviation nums can transform array after two operations then deviation nums
all elements in two binary search trees two binary search trees list containing all integers both trees sorted ascending nodes each tree range
find the closest palindrome string representing closest integer including which there smaller closest defined absolute difference minimized between two closest palindromes but we smallest which consists only does not have leading representing integer range
minimum total space wasted with k resizing operations currently designing dynamic integer array where elements array time integer maximum times can resize array any size array time must least because there needs enough space array hold all space wasted time t defined sizet total space wasted sum space wasted across every time t where t minimum total space wasted can resize array most k array can have any size start does not count towards resizing nums k size we can set initial size total wasted space nums k size we can set initial size resize time total wasted space nums k size we can set initial size resize time resize time total wasted space k
three consecutive odds integer array true there three consecutive odd numbers arr false there no three consecutive arr true three consecutive
count special integers we call positive integer special all digits positive integer special integers belong interval all integers except there special all integers there integers some integers not special
baseball game keeping scores baseball game strange beginning start empty list strings where ith operation must apply record one integer record new score record new score sum previous two record new score double previous invalidate previous removing sum all scores record after applying all test cases generated such answer all intermediate calculations fit integer all operations ops add record now add record now invalidate remove previous record now add record now add record now total sum ops add record now add record now add record now invalidate remove previous record now add record now add record now add record now add record now total sum ops add record now invalidate remove previous record now since record total sum or string representing integer range operation there always least two previous scores operations there always least one previous score
minimum add to make parentheses valid parentheses string valid only empty can written ab concatenated where b valid or can written where valid parentheses string one can insert parenthesis any position s can insert opening parenthesis or closing parenthesis minimum moves required make s s s either or
minimum cost to move chips to the same position we have where position ith chip we need move all chips same one we can change position ith chip or cost or cost minimum cost needed move all chips same position first move chip position position cost second move chip position position cost total cost position we can move two chips position position each move cost total cost position
subarray product less than k array integers nums integer contiguous subarrays where product all elements subarray strictly less than nums k subarrays have product less than note not included product not strictly less than nums k k
isomorphic strings two strings s determine they two strings s t isomorphic characters s can replaced get all occurrences character must replaced another character while preserving order no two characters may map same but character may map s t true s t false s t true s t consist any valid ascii
number of people aware of a secret day one person discovers integer which means each person share secret new person every starting delay days after discovering also integer which means each person forget secret forget days after discovering person cannot share secret same day they forgot or any day integer people who know secret end day since answer may very modulo delay forget day suppose first person named day only person who knows day shares secret new day shares secret new day forgets b shares secret new day b shares secret c shares secret delay forget day first person named day shares secret day b share secret new c day forgets d share secret new delay forget
maximum number of non-overlapping palindrome substrings string s positive integer select set substrings string s satisfy following length each substring least each substring maximum substrings optimal substring contiguous sequence characters within s k we can select substrings underlined s both palindromes have length least k can shown we cannot find selection more than two valid s k there no palindrome substring length least k s consists lowercase english
divide players into teams of equal skill positive integer array skill even length where denotes skill ith divide players into teams size such total skill each team chemistry team equal product skills players sum chemistry all or there no way divide players into teams such total skill each team skill divide players into following where each team total skill sum chemistry all teams skill two players form team total skill chemistry team skill there no way divide players into teams such total skill each team
remove invalid parentheses string s contains parentheses remove minimum invalid parentheses make input string list unique strings valid minimum may answer any s s s s consists lowercase english letters parentheses there most parentheses
shortest path to get all keys m x grid grid empty starting lowercase letters represent uppercase letters represent start starting point one move consists walking one space one four cardinal cannot walk outside or walk into walk over can pick up cannot walk over lock unless have corresponding some k there exactly one lowercase one uppercase letter first k letters english alphabet this means there exactly one key each one lock each also letters used represent keys locks chosen same order english lowest moves acquire all grid note goal obtain all keys not open all grid grid m either english or keys grid range each key grid each key grid matching
call function with custom context enhance all functions have callpolyfill method accepts object obj first parameter any additional obj becomes this context additional arguments passed function callpolyfill method belongs had function const totalcost price cost calling this function like log cost undefined this because this context not calling function like log cost salad this context appropriately function logged appropriate please solve this without using fn function args callpolyfill sets context passed fn function cost args cost burger callpolyfill sets context passed additional typeof null
closest room there hotel rooms represented integer array rooms where denotes there room room roomidi size equal each roomidi guaranteed also k queries array queries where answer jth query room id room such room size least where absolute value there tie absolute then use room smallest such there no such answer array answer length k where contains answer jth rooms queries answers queries query room closest size least answer query there no rooms size least so answer query room closest size least answer rooms queries answers queries query room closest size least answer query room numbers both have sizes least answer since query room only room size least answer k k preferredj minsizej
jump game iii array integers initially positioned start index when index can jump i or i check can reach any index value notice can not jump outside array any arr start true all possible ways reach index value index index index index index index index index index arr start true one possible way reach index value index index index index arr start false there no way reach index value start
rotate list head linked rotate list right k head k head k nodes list range k
maximum value after insertion very large integer represented integer digit digits digit x inclusive range may represent negative want maximize numerical value inserting x anywhere decimal representation cannot insert x left negative x would best insert between making x would best insert before first making string representing maximum value after x result same regardless where insert x can make one largest those three x digits range valid representation case negative begin
find the distinct difference array array nums length distinct difference array nums array diff length such equal distinct elements suffix subtracted distinct elements prefix distinct difference array note denotes subarray nums starting index i ending index j i j then denotes empty nums index i there element prefix distinct elements index i there distinct elements prefix distinct elements index i there distinct elements prefix distinct elements index i there distinct elements prefix distinct element index i there distinct elements prefix no elements nums index i there element prefix distinct elements index i there distinct elements prefix distinct elements index i there distinct elements prefix distinct elements index i there distinct elements prefix distinct element index i there distinct elements prefix no elements
customer placing the largest number of orders sql schema orders column name type int int primary key this this table contains information about order id customer write sql query find customer who placed largest test cases generated so exactly one customer have placed more orders than any other query result format following orders customer two which greater than either customer or because each them only one so result follow what more than one customer largest can find all this
minimum adjacent swaps to reach the kth smallest number string representing large integer we call some integer wonderful permutation digits num greater value than there can many wonderful we only care about when num smallest wonderful integer smallest wonderful integer smallest wonderful integer smallest wonderful integer minimum adjacent digit swaps needs applied num reach kth smallest wonderful tests generated such way kth smallest wonderful integer num k smallest wonderful get this swap index index swap index index num k smallest wonderful get this swap index index swap index index swap index index swap index index num k smallest wonderful get this swap index index k num only consists
maximum performance of a team two integers k two integer arrays speed efficiency both length there engineers numbered represent speed efficiency ith engineer choose most k different engineers out engineers form team maximum performance team sum their speeds multiplied minimum efficiency among their maximum performance this since answer can huge modulo speed efficiency k we have maximum performance team selecting engineer engineer performance speed efficiency k this same first but k we can select engineer engineer engineer get maximum performance performance speed efficiency k k
minimum distance to the target element integer array nums two integers target find index i such target note absolute value guaranteed target exists nums target start only value equal so answer nums target start only value equal so answer nums target start every value nums but minimizes which start target
score after flipping matrix m x binary matrix move consists choosing any row or column toggling each value row or column changing all all every row matrix interpreted binary score matrix sum these highest possible score after making any moves zero grid grid m either or
merge nodes in between zeros head linked which contains series integers separated beginning end linked list have every two consecutive merge all nodes lying between them into single node whose value sum all merged modified list should not contain any head modified linked head above figure represents linked modified list contains sum nodes marked sum nodes marked head above figure represents linked modified list contains sum nodes marked sum nodes marked sum nodes marked nodes list range there no two consecutive nodes beginning end linked list have
path with maximum probability undirected weighted graph nodes represented edge list where undirected edge connecting nodes b probability success traversing edge two nodes start find path maximum probability success go start end success there no path start your answer accepted differs correct answer most edges succprob start end there two paths start one having probability success other edges succprob start end edges succprob start end there no path between end start end b b there most one edge between every two
find the duplicate number array integers nums containing integers where each integer range there only one repeated this repeated must solve problem without modifying array nums uses only constant extra nums nums all integers nums appear only once except precisely one integer which appears two or more follow how can we prove least one duplicate must exist can solve problem linear runtime
count pairs with xor in a range integer array nums two integers low nice nice pair pair where i j low xor nums low high all nice pairs xor xor xor xor xor xor nums low high all nice pairs xor xor xor xor xor xor xor xor low high
edit distance two strings minimum operations required convert have following three operations permitted insert character delete character replace character horse rorse rorse rose rose ros intention inention inention enention enention exention exention exection exection execution consist lowercase english
symmetric tree root binary check whether mirror itself symmetric around root true root false nodes tree range follow could solve both recursively
rotting oranges m x grid where each cell can have one three representing empty representing fresh or representing rotten every any fresh orange adjacent rotten orange becomes minimum minutes must elapse until no cell fresh this grid grid orange bottom left corner column never because rotting only happens grid since there already no fresh oranges minute answer just m or
maximum number of weeks for which you can work there projects numbered integer array milestones where each denotes milestones ith project can work projects following these two every finish exactly one milestone one must work every cannot work two milestones same project two consecutive once all milestones all projects or only milestones can work cause violate above stop note may not able finish every milestones due these maximum weeks would able work projects without violating rules mentioned milestones one possible scenario during work milestone project during work milestone project during work milestone project during work milestone project during work milestone project during work milestone project total weeks milestones one possible scenario during work milestone project during work milestone project during work milestone project during work milestone project during work milestone project during work milestone project during work milestone project total weeks note cannot work last milestone project week because would violate one milestone project remain
sum of digits in base k integer base base sum digits after converting base base after each digit should interpreted base sum should returned base k expressed base k already base k
maximum score from performing multiplication operations two integer arrays nums multipliers size m where begin score want perform exactly m ith operation choose one integer x either start or end array add x your note corresponds first second so remove x maximum score after performing m nums multipliers optimal solution choose adding choose adding choose adding total score nums multipliers optimal solution choose adding choose adding choose adding choose adding choose adding total score m m m
longest univalue path root binary length longest where each node path same this path may or may not pass through length path between two nodes represented edges between root shown image shows longest path same value root shown image shows longest path same value nodes tree range depth tree not exceed
minimum time to make rope colorful alice balloons arranged string colors where color ith alice wants rope she does not want two consecutive balloons same so she asks bob bob can remove some balloons rope make integer array neededtime where time bob needs remove ith balloon minimum time bob needs make rope colors neededtime above bob can remove blue balloon index this takes there no longer two consecutive balloons same total time colors neededtime rope already bob does not need remove any balloons colors neededtime bob remove ballons indices each ballon takes second there no longer two consecutive balloons same total time colors contains only lowercase english
stone game ii alice bob continue their games piles there piles arranged each pile positive integer stones objective game end most alice bob take alice starting m each player can take all stones first x remaining where x we set m game continues until all stones have been assuming alice bob play maximum stones alice can piles alice takes one pile bob takes two then alice takes piles alice can get piles alice takes two piles then bob can take all three piles this alice get piles so we since piles
special positions in a binary matrix m x binary matrix special positions position called special all other elements row i column j columns mat special position because all other elements row column mat special m either or
longest mountain in array may recall array arr mountain array only there exists some index i i such integer array length longest which there no mountain arr largest mountain which length arr there no follow can solve using only one can solve
largest number after mutating substring string which represents large also integer array change length maps each digit another more digit d maps digit may choose mutate single substring mutate replace each digit digit maps change replace string representing largest possible integer after mutating choosing not single substring substring contiguous sequence characters within num change replace substring maps becomes largest can so num change replace substring maps maps maps becomes largest can so num change already largest can so num consists only digits
count ways to group overlapping ranges integer array ranges where denotes all integers between starti endi contained ith split ranges into two groups such each range belongs exactly one any two overlapping ranges must belong same two ranges said overlapping there exists least one integer present both overlapping because occur both total ways split ranges into two since answer may very modulo ranges two ranges so they must same there two possible put both ranges together group put both ranges together group ranges ranges they must same ranges also they must also same there four possible ways group all ranges group all ranges group ranges group group ranges group group starti endi
list the products ordered in a period sql schema products column name type int varchar varchar primary key this this table contains data about orders column name type int date unit int there no primary key this may have duplicate foreign key products unit products ordered write sql query get names products have least units ordered february their result table any query result format following products leetcode solutions book jewels stringology book hp laptop lenovo laptop leetcode kit orders unit unit leetcode solutions leetcode kit products ordered february total products ordered february total products ordered february total products not ordered february products ordered february total
maximum number of consecutive values you can make integer array coins length which represents coins value ith coin can make some value x can choose some your coins such their values sum up maximum consecutive integer values can make your coins starting including note may have multiple coins same coins can make following take take can make consecutive integer values starting coins can make following take take take take take take take take can make consecutive integer values starting nums
minimum cost to hire k workers there two integer arrays quality wage where quality ith worker minimum wage expectation ith we want hire exactly k workers form paid hire group k we must pay them according following every worker paid group should paid ratio their quality compared other workers paid every worker paid group must paid least their minimum wage integer least amount money needed form paid group satisfying above answers within actual answer quality wage k we pay worker quality wage k we pay workers k
validate binary search tree root binary determine valid binary search tree valid bst defined left subtree node contains only nodes keys less than right subtree node contains only nodes keys greater than both left right subtrees must also binary search root true root false root value but right value nodes tree range
smallest good base integer represented smallest good base we call k good base all digits base k base base base integer range does not contain any leading
equal rational numbers two strings s each which represents rational true only they represent same strings may use parentheses denote repeating part rational rational can represented using up three represented one following three repeating portion decimal expansion conventionally denoted within pair round s t true because represents represents strings represent same s t true s t true represents repeated which equals this link represents which formed each part consists only does not have leading zeros zero
minimum time to repair cars integer array ranks representing ranks some ranksi rank ith mechanic rank r can repair cars r also integer cars representing total cars waiting garage minimum time taken repair all all mechanics can repair cars ranks cars first mechanic repair two time required second mechanic repair two time required third mechanic repair two time required fourth mechanic repair four time required can proved cars cannot repaired less than ranks cars first mechanic repair one time required second mechanic repair four time required third mechanic repair one time required can proved cars cannot repaired less than cars
restore the array program supposed print array program forgot print whitespaces array printed string digits s all we know all integers array range there no leading zeros string s integer possible arrays can printed s using mentioned since answer may very modulo s k only possible array s k there cannot array printed this way all integer s k possible arrays s consists only digits does not contain leading k
logical or of two binary grids represented as quad-trees binary matrix matrix which all elements either or represents binary matrix represents another binary representing binary matrix which result logical bitwise or two binary matrixes represented notice can assign value node true or false when isleaf both accepted tree data structure which each internal node exactly four each node two true node represents grid or false node represents grid true node leaf node tree or false node four class node public boolean public boolean public node public node public node public node we can construct area using following current grid same value all or all set isleaf true set val value grid set four children null current grid different set isleaf false set val any value divide current grid into four shown recurse each children proper want know more about can refer represents serialized format using level order where null signifies path terminator where no node exists very similar serialization binary only difference node represented list value isleaf or val true we represent list value isleaf or val false we represent shown can see binary matrix which represented each we apply logical bitwise or two binary matrices we get binary matrix below which represented result notice binary matrices shown only have construct binary matrix get result each tree represents binary matrix size each matrix contains only resulting matrix size also both valid each representing where x
minimum cuts to divide a circle valid cut circle can cut represented straight line touches two points edge circle passes through or cut represented straight line touches one point edge circle some valid invalid cuts shown figures integer minimum cuts needed divide circle into equal above figure shows how cutting circle twice through middle divides into equal least cuts needed divide circle into equal can shown less than cuts cannot result slices equal size also note first cut not divide circle into distinct
subsets integer array nums unique all possible subsets power solution set must not contain duplicate solution any nums nums all numbers nums
find the string with lcp we define lcp matrix any string word lowercase english letters x grid such equal length longest common prefix between substrings x matrix alphabetically smallest string word corresponds there no such empty string lexicographically smaller than string b same first position where b string letter appears earlier alphabet than corresponding letter lexicographically smaller than because first position they differ third comes before lcp lcp corresponds any letter string two alternating lexicographically smallest them lcp lcp corresponds any letter string single distinct lexicographically smallest them lcp cannot equal since consists only single no answer
spiral matrix ii positive integer generate x matrix filled elements spiral
count good triplets array integers three integers b need find good triplet good following conditions i j k b c where denotes absolute value good arr b c there good arr b c no triplet satisfies all c
remove nth node from end of list head linked remove nth node end list head head head nodes list sz sz follow could do this one
number of increasing paths in a grid m x integer matrix where can move cell any adjacent cell all strictly increasing paths grid such can start any cell end any since answer may very modulo two paths considered different they do not have exactly same sequence visited grid strictly increasing paths paths length paths length paths length total paths grid strictly increasing paths paths length paths length total paths m m
gray code gray code sequence sequence integers every integer inclusive range first integer integer appears no more than once binary representation every pair adjacent integers differs exactly one binary representation first last integers differs exactly one integer any valid gray code binary representation differ one bit differ one bit differ one bit differ one bit also valid gray code whose binary representation differ one bit differ one bit differ one bit differ one bit
movie rating sql schema movies column name type int title varchar primary key this title name users column name type int name varchar primary key this movierating column name type int int rating int date primary key this this table contains rating movie user their review write sql query find name user who rated greatest case lexicographically smaller user find movie name highest average rating february case lexicographically smaller movie query result format following movies title avengers frozen joker users name daniel monica maria james movierating rating results daniel frozen daniel monica have rated movies but daniel smaller frozen joker have rating average february but frozen smaller
longest substring with at least k repeating characters string s integer length longest substring s such frequency each character this substring greater than or equal s k longest substring repeated s k longest substring repeated times repeated s consists only lowercase english k
substring with largest variance variance string defined largest difference between occurrences any characters present note two characters may or may not string s consisting lowercase english letters largest variance possible among all substrings substring contiguous sequence characters within s all possible variances along their respective substrings listed variance substrings variance substrings variance substrings variance substring since largest possible variance we s no letter occurs more than once so variance every substring s consists lowercase english
finding mk average two m stream tasked implement data structure calculates mkaverage mkaverage can calculated using these elements stream less than m should consider mkaverage copy last m elements stream separate remove smallest k elements largest k elements calculate average value rest elements rounded down nearest implement mkaverage int initializes mkaverage object empty stream two integers m void inserts new element num into int calculates returns mkaverage current stream rounded down nearest input output explanation mkaverage obj new current elements current elements because m only elements current elements last elements after removing smallest largest element container average equals current elements current elements current elements last elements after removing smallest largest element container average equals m m num most calls made addelement
biggest single number sql schema mynumbers column name type num int there no primary key this may contain each row this table contains single appeared only once mynumbers write sql query report largest single there no single report query result format following mynumbers num num single numbers since largest single we mynumbers num num null there no single numbers input table so we
reverse words in a string iii string reverse order characters each word within sentence while still preserving whitespace initial word s take leetcode ekat edocteel s s contains printable ascii s does not contain any leading or trailing there least one word all words s separated single
number of substrings containing all three characters string s consisting only characters b substrings containing least one occurrence all these characters b s substrings containing least one occurrence characters b c s substrings containing least one occurrence characters b c s x s only consists b or c
bulb switcher there bulbs initially first turn all then turn off every second third toggle every third bulb off or turning off ith toggle every i nth only toggle last bulbs after three bulbs after first three bulbs after second three bulbs after third three bulbs so should because there only one bulb
largest odd number in string string representing large odd integer substring or empty string no odd integer substring contiguous sequence characters within num only substrings only odd num there no odd numbers num already odd num only consists digits does not contain any leading
pass the pillow there people standing line labeled first person line holding pillow every person holding pillow passes next person standing once pillow reaches end direction people continue passing pillow opposite once pillow reaches nth person they pass then person so two positive integers index person holding pillow after time time people pass pillow following afer five pillow time people pass pillow following afer two pillow time
reachable nodes in subdivided graph undirected graph nodes labeled decide subdivide each edge graph into chain new nodes varying between each graph array edges where indicates there edge between nodes ui vi original cnti total new nodes subdivide edge note cnti means not subdivide subdivide edge replace new edges cnti new new nodes new edges this new want know how many nodes reachable node where node reachable distance maxmoves or original graph nodes reachable node new edges maxmoves edge subdivisions shown image nodes reachable highlighted edges maxmoves edges maxmoves node disconnected rest so only node ui vi there no multiple edges cnti maxmoves
remove all occurrences of a substring two strings s perform following operation s until all occurrences substring part find leftmost occurrence substring part remove s after removing all occurrences substring contiguous sequence characters s part following operations s remove starting index so s s remove starting index so s s remove starting index so s now s no occurrences s part following operations s remove starting index so s s remove starting index so s s remove starting index so s s remove starting index so s now s no occurrences s part consists lowercase english
array reduce transformation integer array reducer function initial value reduced reduced array created applying following val val val until every element array been final value val length array should please solve without using nums fn function accum init value final answer nums fn function accum curr init value final answer nums fn function init empty answer always init
word break string s dictionary strings true s can segmented into sequence one or more dictionary note same word dictionary may reused multiple times s worddict true true because can segmented s worddict true true because can segmented pen note allowed reuse dictionary s worddict false s consist only lowercase english all strings worddict
number of digit one integer count total digit appearing all integers less than or equal
game of life according game also known simply cellular automaton devised british mathematician john horton conway board made up m x grid where each cell initial live or dead each cell interacts eight neighbors using following four rules above wikipedia any live cell fewer than two live neighbors dies caused any live cell two or three live neighbors lives next any live cell more than three live neighbors any dead cell exactly three live neighbors becomes live next state created applying above rules simultaneously every cell current where births deaths occur current state m x grid next board board m or follow could solve remember board needs updated cannot update some cells first then use their updated values update other this we represent board using board which would cause problems when active area encroaches upon border array live cells reach how would address these
form smallest number from two digit arrays two arrays unique digits smallest contains least one digit each contains digit digit can proven smallest we can contains digit which exists both all digits each array
count sorted vowel strings integer strings length consist only vowels lexicographically string s lexicographically sorted all valid same or comes before sorted strings consist vowels only sorted strings consist vowels only note not valid string since comes after
kth distinct string in an array distinct string string present only once array strings integer kth distinct string present there fewer than k distinct empty string note strings considered order which they appear arr k only distinct strings arr appears so distinct appears so distinct since k arr k all strings arr so string arr k only distinct string since there fewer than distinct we empty string k consists lowercase english
sum multiples positive integer find sum all integers range inclusive divisible or integer denoting sum all numbers range satisfying numbers range divisible or sum these numbers numbers range divisible or sum these numbers numbers range divisible or sum these numbers
replace employee id with the unique identifier sql schema employees column name type id int name varchar id primary key this each row this table contains id name employee employeeuni column name type id int int primary key this each row this table contains id corresponding unique id employee write sql query show unique id each user does not have unique id replace just show result table any query result format following employees id name alice bob meir winston jonathan employeeuni id name null alice null bob meir winston jonathan alice bob do not have unique we show null unique id meir unique id winston unique id jonathan
find the difference two strings s string t generated random shuffling string s then add one more letter random letter added s t letter s t s t consist lowercase english
remove stones to minimize the total integer array where represents stones ith integer should apply following operation exactly k choose any remove stones notice can apply operation same pile more than minimum possible total stones remaining after applying k greatest integer smaller than or equal x rounds x piles k steps possible scenario apply operation pile resulting piles apply operation pile resulting piles total stones piles k steps possible scenario apply operation pile resulting piles apply operation pile resulting piles apply operation pile resulting piles total stones k
minimum cost of a path with special roads array start where start represents your initial position also array target where target represents your target position cost going position any other position space there also some special array specialroads where indicates ith special road can take cost equal can use each special road any minimum cost required go start target specialroads optimal path this move cost this move uses first special cost this move cost this move uses second special cost so total cost can shown we cannot achieve smaller total cost than start target specialroads optimal not use any special edges go directly starting ending position cost startx targetx starty targety startx targetx starty targety costi
minimum difference between largest and smallest value in three moves integer array one can choose one element nums change any minimum difference between largest smallest value nums after performing most three nums we can make most first change nums becomes second change nums becomes third change nums becomes after performing difference between minimum maximum nums we can make most first change nums becomes second change nums becomes third change nums becomes after performing difference between minimum maximum can shown there no way make difference nums we can make most first change nums becomes second change nums becomes third change nums becomes after performing difference between minimum maximum
number of longest increasing subsequence integer array longest increasing notice sequence strictly nums two longest increasing subsequences nums length longest increasing subsequence there increasing subsequences length so output
triples with bitwise and equal to zero integer array triple triple indices such i j k where represents nums we could choose following k nums
missing number array nums containing distinct numbers range only range missing nums since there so all numbers range missing range since does not appear nums since there so all numbers range missing range since does not appear nums since there so all numbers range missing range since does not appear all numbers nums follow could implement solution using only extra space complexity runtime
friend requests ii: who has the most friends sql schema requestaccepted column name type int int date primary key this this table contains id user who sent id user who received date when request write sql query find people who have most friends most friends test cases generated so only one person most query result format following requestaccepted id num person id friend people so three friends which most than any follow real multiple people could have same most could find all these people this
reorder routes to make all paths lead to the city zero there cities numbered roads such there only one way travel between two different cities network form last ministry transport decided orient roads one direction because they too roads represented connections where represents road city ai city this there big event capital many people want travel this your task consists reorienting some roads such each city can visit city minimum edges guaranteed each city can reach city after connections change direction edges show red such each node can reach node connections change direction edges show red such each node can reach node connections bi ai bi
delete columns to make sorted array strings all same strings can arranged such there one each making strs can arranged abc bce cae want delete columns not sorted above columns while column so would delete column columns strs grid looks cba daf ghi columns but column so only need delete strs grid looks b column only column so not delete any strs grid looks zyx wvu tsr all columns not so delete all consists lowercase english
design bitset bitset data structure compactly stores implement bitset initializes bitset size all which void updates value bit index idx value already no change void updates value bit index idx value already no change void flips values each bit other all bits value now have value vice boolean checks value each bit bitset returns true satisfies false boolean checks there least one bit bitset value returns true satisfies false int returns total bits bitset which have value string returns current composition note resultant character ith index should coincide value ith bit input output explanation bitset bs new bitset value idx updated so bitset value idx updated so bitset value each bit so bitset not all values bitset value idx updated so bitset value each bit so bitset there least index value value idx updated so bitset there bits value which composition size idx size most calls made total least one call made or most calls made
happy number write algorithm determine happy defined following starting any positive replace sum squares repeat process until equals or loops endlessly cycle which does not include those numbers which this process ends true happy false true false
intersection of two arrays two integer arrays array their each element result must unique may result any also
sum of all subset xor totals xor total array defined bitwise xor all or array xor total array xor xor array sum all xor totals every subset subsets same elements should counted multiple array subset array b can obtained b deleting some elements nums subsets empty subset xor total xor total xor total xor total xor nums subsets empty subset xor total xor total xor total xor total xor total xor xor total xor xor total xor xor total xor xor nums sum all xor totals every subset
evaluate the bracket pairs of a string string s contains some bracket each pair containing string there two bracket pairs contain keys know values wide range this represented string array knowledge where each indicates key keyi value tasked evaluate all bracket when evaluate bracket pair contains some key replace keyi bracket pair corresponding do not know value replace keyi bracket pair question mark quotation each key appear most once your there not any nested brackets resulting string after evaluating all bracket s knowledge key value so replace key value so replace s knowledge do not know value key replace s knowledge same key can appear multiple key value so replace all occurrences notice not bracket pair not s consists lowercase english letters round brackets every open bracket s have corresponding close bracket key each bracket pair s there not any nested bracket pairs keyi valuei consist lowercase english each keyi knowledge
node with highest edge score directed graph nodes labeled where each node exactly one outgoing graph represented integer array edges length where indicates there directed edge node i node edge score node i defined sum labels all nodes have edge pointing node highest edge multiple nodes have same edge node smallest edges nodes have edge pointing node edge score node node edge pointing node edge score node node edge pointing node edge score node nodes have edge pointing node edge score node node highest edge score so edges nodes have edge pointing node edge score node nodes have edge pointing node edge score node nodes both have edge score since node smaller we i
find subarrays with equal sum integer array determine whether there exist two subarrays length equal note two subarrays must begin different true these subarrays false subarray contiguous sequence elements within nums true subarrays elements have same sum nums false no two subarrays size have same nums true subarrays have same sum note even though subarrays have same two subarrays considered different because they different positions original
find the longest balanced substring of a binary string binary string s consisting only zeroes substring s considered balanced all zeroes before ones zeroes equal ones inside notice empty substring considered balanced length longest balanced substring substring contiguous sequence characters within s longest balanced substring which length s longest balanced substring which length s there no balanced substring except empty so answer
predict the winner integer array two players playing game this player player player player take player starting both players start game score each player takes one numbers either end array or which reduces size array player adds chosen their game ends when there no more elements true player can win scores both players then player still should also may assume both players playing nums false player can choose between chooses then player can choose player chooses then player left final score player player player never winner need nums true player first chooses then player choose between no matter which player player can choose player more score than player so need true representing can
dice roll simulation die simulator generates random each introduced constraint generator such cannot roll i more than consecutive array integers rollmax integer distinct sequences can obtained exact since answer may too modulo two sequences considered different least one element differs each rollmax there rolls there no constraints there possible this looking rollmax numbers appear most once therefore sequences cannot so final answer rollmax rollmax
longest duplicate substring string consider all duplicated substrings s occur or more occurrences may any duplicated substring longest possible s does not have duplicated answer s s s consists lowercase english
design an ordered stream there stream pairs arriving arbitrary where idkey integer between value no two pairs have same design stream returns values increasing order their ids returning chunk values after each concatenation all chunks should result list sorted implement orderedstream constructs stream take string inserts pair into then returns largest possible chunk currently inserted values appear next input output explanation note values ordered id orderedstream os new inserts returns inserts returns inserts returns inserts returns inserts returns concatentating all chunks resulting order same order id value consists only lowercase each call insert have unique exactly calls made
circular array loop playing game involving circular array integers each denotes indices must move located index move steps move steps since array may assume moving forward last element puts first moving backwards first element puts last cycle array consists sequence indices seq length k following movement rules above results repeating index sequence every either all positive or all k true there cycle or false nums true graph shows how indices white nodes jumping while red jumping we can see cycle all nodes white same nums false graph shows how indices white nodes jumping while red jumping only cycle size so we nums true graph shows how indices white nodes jumping while red jumping we can see cycle while size node jumping forward node jumping so not we can see cycle all nodes white same follow could solve time complexity extra space
number of sets of k non-overlapping line segments points where ith point x find ways we can draw exactly k line segments such each segment covers two or more endpoints each segment must have integral k line segments do not have cover all they allowed share ways we can draw k line since this can modulo k two line segments shown red image above shows different ways k ways k total possible ways draw line segments taking this modulo gives us k
alternating digit sum positive integer each digit sign according following most significant digit assigned positive each other digit opposite sign adjacent sum all digits their corresponding
evaluate boolean binary tree root full binary tree following leaf nodes have either value or where represents false represents nodes have either value or where represents boolean or represents boolean evaluation node node leaf evaluation value true or evaluate two children apply boolean operation value boolean result evaluating root full binary tree binary tree where each node either or leaf node node zero root true above diagram illustrates evaluation node evaluates false true or node evaluates true or false root node evaluates so we root false root node leaf node evaluates so we nodes tree range every node either or leaf nodes have value or nodes have value or
the k-th lexicographical string of all happy strings of length n happy string string consists only letters set all values i strings all happy strings strings not happy two integers consider list all happy strings length sorted lexicographical kth string this list or empty string there less than k happy strings length k list contains all happy strings length third string k there only happy strings length k there different happy string length find string k
the k weakest rows in a matrix m x binary matrix mat soldiers positioned front all appear left all each row i weaker than row j one following soldiers row i less than soldiers row both rows have same soldiers i indices k weakest rows matrix ordered weakest mat k soldiers each row row row row row row rows ordered weakest strongest mat k soldiers each row row row row row rows ordered weakest strongest m m k m either or
next greater element i next greater element some element x array first greater element right x same two distinct integer arrays where subset each i find index j such determine next greater element there no next greater then answer this query array ans length such next greater element described next greater element each value underlined there no next greater so answer underlined next greater element underlined there no next greater so answer next greater element each value underlined next greater element underlined there no next greater so answer all integers all integers also appear follow could find
consecutive numbers sum integer ways can write sum consecutive positive
guess number higher or lower ii we playing guessing game work i pick between guess guess right win guess wrong then i tell whether i picked higher or continue every time guess wrong pay x run out lose particular minimum amount money need guarantee win regardless what i winning strategy range guess this my your total pay my range guess this my your total pay my must guess your total my must guess your total my range guess this my your total pay my range guess this my your total pay my must guess your total my must guess your total my range guess this my your total pay my must guess your total worst case all these scenarios pay only need guarantee there only one possible so can guess not have pay there two possible guess this my your total pay my must guess your total worst case pay
can i win two players take turns running any integer player who first causes running total reach or exceed what we change game so players cannot two players might take turns drawing common pool numbers without replacement until they reach total two integers maxchoosableinteger true first player move can force assume both players play maxchoosableinteger desiredtotal false no matter which integer first player first player first player can choose integer up first player choose second player can only choose integers up second player win choosing get total which same other integers chosen first second player always maxchoosableinteger desiredtotal true maxchoosableinteger desiredtotal true maxchoosableinteger desiredtotal
booking concert tickets in groups concert hall rows numbered each m numbered m need design ticketing system can allocate seats following group k spectators can sit together every member group k spectators can get they may or may not sit note spectators very they book seats only each member their group can get seat row less than or equal maxrow can vary group case there multiple rows choose row smallest there multiple seats choose same seat smallest implement bookmyshow int initializes object rows m seats per int returns array length denoting row seat first seat being allocated k members who must sit other returns smallest possible r c such all c k seats valid empty row r returns case not possible allocate seats boolean int returns true all k members group can allocated seats rows who may or may not sit seats can allocates k seats group smallest row smallest possible seat numbers each returns input output explanation bookmyshow bms new there rows seats each group books seats row there only seat left row so not possible book consecutive true group books seat row seats row false there only one seat left k maxrow most calls total made gather
spiral matrix m x all elements matrix spiral matrix matrix m
number of lines to write string string s lowercase english letters array widths denoting how many pixels wide each lowercase english letter width width so trying write s across several where each line no longer than starting beginning write many letters first line such total width does not exceed where stopped continue writing many letters can second continue this process until have written all array result length total width last line widths s can write s abcdefghij pixels wide klmnopqrst pixels wide uvwxyz pixels wide there total last line pixels widths s can write s bbbcccdddaa pixels wide pixels wide there total last line pixels s contains only lowercase english
find pivot index array integers calculate pivot index this pivot index index where sum all numbers strictly left index equal sum all numbers strictly index left edge then left sum because there no elements this also applies right edge leftmost pivot no such index nums pivot index left sum right sum nums there no index satisfies conditions problem nums pivot index left sum elements left index right sum this question same
equal sum arrays with minimum number of operations two arrays integers possibly different values arrays between one can change any value any arrays any value between minimum operations required make sum values equal sum values not possible make sum two arrays can make sums equal all indices change change change there no way decrease sum or increase sum make them can make sums equal all indices change change change
sum of prefix scores of strings array words size consisting we define score string word strings such word prefix words then score since prefix both array answer size where sum scores every prefix note string considered prefix words answer each string there strings prefix strings prefix string prefix total there strings prefix strings prefix total there strings prefix string prefix total there strings prefix total words each prefix score so total consists lowercase english
count asterisks string where every two consecutive vertical bars grouped into other make make so excluding between each pair note each belong exactly one s considered characters characters between first second excluded characters between third fourth excluded there asterisks we s this there no asterisks we s considered characters there asterisks we s consists lowercase english vertical bars asterisks s contains even vertical bars
check if move is legal x grid where represents cell game free cells represented white cells represented black cells represented each move this game consists choosing free cell changing color playing white or move only legal after changing cell becomes endpoint good line or good line line three or more cells where endpoints line one remaining cells middle opposite color cells line can find examples good lines figure two integers rmove cmove character color representing color playing or true changing cell color color legal or false not board rmove cmove color true represented colors black cell marked two good lines chosen cell endpoint annotated above red board rmove cmove color false while there good lines chosen cell middle there no good lines chosen cell cmove color either or
wildcard matching input string pattern implement wildcard pattern matching support matches any single matches any sequence characters empty matching should cover entire input string s p false does not match entire string s p true matches any s p false matches but second letter which does not match s contains only lowercase english p contains only lowercase english or
pascal's triangle integer first numrows each sum two numbers directly above numrows numrows numrows
the number of good subsets integer array we call subset nums good product can represented product one or more distinct prime nums good subsets products not good subsets products different good subsets nums modulo subset nums any array can obtained deleting some none or elements two subsets different only chosen indices delete nums good subsets product which product distinct prime product which product distinct primes product which product distinct prime product which product distinct prime product which product distinct primes product which product distinct prime nums good subsets product which product distinct prime product which product distinct primes product which product distinct primes product which product distinct prime product which product distinct primes
shortest path with alternating colors integer nodes directed graph where nodes labeled each edge red or blue this there could parallel two arrays rededges blueedges indicates there directed red edge node ai node bi indicates there directed blue edge node uj node vj array answer length where each length shortest path node node x such edge colors alternate along or such path does not rededges blueedges rededges blueedges vj
find original array from doubled array integer array original transformed into doubled array changed appending twice value every element then randomly shuffling resulting array original changed doubled changed not doubled empty elements original may returned any changed one possible original array could twice value twice value twice value other original arrays could or changed changed not doubled changed changed not doubled
user activity for the past 30 days i sql schema activity column name type int int date enum there no primary key this may have duplicate column enum type table shows user activities social media note each session belongs exactly one write sql query find daily active user count period days ending user active someday they made least one activity result table any query result format following activity day note we do not care about days zero active
arithmetic slices ii - subsequence integer array all arithmetic subsequences sequence numbers called arithmetic consists least three elements difference between any two consecutive elements arithmetic not arithmetic subsequence array sequence can formed removing some elements subsequence test cases generated so answer fits nums all arithmetic subsequence slices nums any subsequence this array
longest increasing subsequence integer array length longest strictly increasing subsequence nums longest increasing subsequence therefore length nums nums follow can come up algorithm runs time
largest multiple of three array digits largest multiple three can formed concatenating some digits any there no answer empty since answer may not fit integer data answer note returning answer must not contain unnecessary leading digits digits digits
maximum 69 number positive integer num consisting only digits maximum can get changing most one digit becomes becomes num changing first digit results changing second digit results changing third digit results changing fourth digit results maximum num changing last digit results maximum num better not apply any num num consists only
maximum tastiness of candy basket array positive integers price where denotes price ith candy positive integer store sells baskets k distinct tastiness candy basket smallest absolute difference prices any two candies maximum tastiness candy price k choose candies prices tastiness candy basket can proven maximum tastiness can price k choose candies prices tastiness candy basket can proven maximum tastiness can price k choosing any two distinct candies candies we have result tastiness k
remove letter to equalize frequency string consisting lowercase english need select one index remove letter index word so frequency every letter present word true possible remove one letter so frequency all letters word false frequency letter x times occurs must remove exactly one letter cannot chose do word true select index delete word becomes each character frequency word false we must delete so either frequency frequency or vice impossible make all present letters have equal word consists lowercase english letters
minimum total distance traveled there some robots factories integer array robot where position ith also integer array factory where indicates positionj position jth factory jth factory can repair most limitj positions each robot positions each factory also note robot can same position factory all robots initially they keep moving one direction could negative or positive direction when robot reaches factory did not reach factory repairs stops any can set initial direction moving some your target minimize total distance traveled all minimum total distance traveled all test cases generated such all robots can note all robots move same two robots move same they never two robots move opposite directions they meet some they do not they cross each robot passes factory reached crosses does not robot moved position x position distance moved robot factory shown first robot position moves positive repaired first second robot position moves negative repaired first third robot position repaired second does not need limit first factory fixed limit second factory fixed total distance can shown we cannot achieve better total distance than robot factory shown first robot position moves positive repaired second second robot position moves negative repaired first limit first factory fixed limit second factory fixed total distance can shown we cannot achieve better total distance than positionj limitj input generated such always possible repair every
number of matching subsequences string s array strings subsequence subsequence string new string generated original string some characters deleted without changing relative order remaining subsequence s words there three strings words subsequence s words s consist only lowercase english
lexicographically smallest beautiful string string beautiful consists first k letters english lowercase does not contain any substring length or more which beautiful string s length positive integer lexicographically smallest string length which larger than s there no such empty string lexicographically larger than string b same first position where b character strictly larger than corresponding character lexicographically larger than because first position they differ fourth d greater than s k string beautiful lexicographically larger than string can proven there no string lexicographically larger than string lexicographically smaller than string s k can proven there no string lexicographically larger than string k s beautiful
throne inheritance kingdom consists his his so every once someone family dies or child kingdom order inheritance consists king first define recursive function which person x inheritance order so returns who should next person after x order x no children or all children x king null else else oldest child not curorder assume we have kingdom consists his children alice bob older than finally son curorder calling so we append curorder get calling so we append curorder get calling so we append curorder get calling thus order inheritance using above we can always obtain unique order implement throneinheritance initializes object throneinheritance name king part void string indicates parentname gave birth void indicates death death person affect successor function nor current inheritance can treat just marking person returns list representing current order inheritance excluding dead input output explanation throneinheritance new king king andy king andy bob king andy bob catherine king andy matthew bob catherine king andy matthew bob alex catherine king andy matthew bob alex asha catherine king andy matthew bob alex asha catherine name consist lowercase english letters all arguments childname kingname all name arguments death passed either constructor or childname birth each call guaranteed parentname most calls made birth most calls made
brick wall there rectangular brick wall front rows ith row some bricks each same height one but they can different total width each row draw vertical line top bottom cross least your line goes through edge then brick not considered cannot draw line just along one two vertical edges which case line obviously cross no array wall contains information about minimum crossed bricks after drawing such vertical wall wall same each row
number of unique subjects taught by each teacher sql schema teacher column name type int int int primary key this each row this table indicates teacher teaches subject department write sql query report unique subjects each teacher teaches result table any query result format shown following teacher cnt teacher they teach subject departments they teach subject department teacher they teach subject department they teach subject department they teach subject department they teach subject department
basic calculator string s representing valid implement basic calculator evaluate result not allowed use any function which evaluates strings mathematical such s s s s consists s represents valid not used unary operation could used unary operation there no two consecutive operators every running calculation fit signed
minimum number of removals to make mountain array may recall array arr mountain array only there exists some index i i such integer array minimum elements remove make nums mountain nums array itself mountain array so we do not need remove any nums one solution remove elements indices making array nums guaranteed can make mountain array out
tweet counts per frequency social media company trying monitor activity their site analyzing tweets occur select periods these periods can partitioned into smaller time chunks based certain frequency or period would partitioned into following time chunks these every minute every hour every day notice last chunk may shorter than specified chunk size always end end time period above design implement api help company their implement tweetcounts initializes tweetcounts void int stores tweetname recorded time string int int returns list integers representing tweets tweetname each time chunk period time frequency freq one or representing frequency every or day input output explanation tweetcounts tweetcounts new new tweet time new tweet time new tweet time chunk had tweets chunk had chunk had tweet new tweet time chunk had tweets endtime endtime starttime there most calls total recordtweet
minimum number of operations to sort a binary tree by level root binary tree unique one can choose any two nodes same level swap their minimum operations needed make values each level sorted strictly increasing level node edges along path between root root swap level becomes swap level becomes swap level becomes we used operations so can proven minimum operations root swap level becomes swap level becomes swap level becomes we used operations so can proven minimum operations root each level already sorted increasing order so nodes tree range all values tree
queens that can attack the king x there can multiple black queens ad one white integer array queens where represents position ith black queen also integer array king length where king represents position white coordinates black queens can directly attack may answer any queens king diagram above shows three queens can directly attack king three queens cannot attack king marked red queens king diagram above shows three queens can directly attack king three queens cannot attack king marked red yking all positions
count odd numbers in an interval range two integers low count odd numbers between low high low high odd numbers between low high odd numbers between low high
asteroid collision we array asteroids integers representing asteroids each absolute value represents sign represents direction meaning negative meaning each asteroid moves same find out state asteroids after all two asteroids smaller one both same both two asteroids moving same direction never asteroids collide resulting never asteroids collide exploding each asteroids collide resulting collide resulting
number of subarrays with bounded maximum integer array nums two integers left contiguous subarrays such value maximum array element subarray range test cases generated so answer fit nums left right there three subarrays meet nums left right left right
k closest points to origin array points where represents point plane integer k closest points origin distance between two points plane euclidean distance may answer any answer guaranteed unique order points k distance between origin distance between origin since closer we only want closest k points so answer just points k answer would also k yi
count negative numbers in a sorted matrix m x matrix grid which sorted order both negative numbers grid there negatives grid m follow could find
goat latin string sentence consist words separated each word consists lowercase uppercase letters we would like convert sentence language similar pig rules goat latin word begins vowel or append end word becomes word begins consonant not remove first letter append then add word becomes add one letter end each word per word index starting first word gets added second word gets added so final sentence representing conversion sentence goat sentence speak goat peaksmaaa oatgmaaaa sentence quick brown fox jumped over lazy uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa sentence consists english letters sentence no leading or trailing all words sentence separated single
paths in matrix whose sum is divisible by k m x integer matrix grid integer currently position want reach position moving only down or paths where sum elements path divisible since answer may very modulo grid k there two paths where sum elements path divisible first path highlighted red sum which divisible second path highlighted blue sum which divisible grid k path highlighted red sum which divisible grid k every integer divisible so sum elements every possible path divisible m m k
delete nodes and return forest root binary each node tree distinct after deleting all nodes value we left forest disjoint union roots trees remaining may result any root root nodes tree most each node distinct value between contains distinct values between
repeated substring pattern string check can constructed taking substring appending multiple copies substring s true substring s false s true substring four times or substring s consists lowercase english
find and replace in string string s must perform k replacement operations replacement operations three parallel all length complete ith replacement check substring occurs index original string does not do otherwise does replace substring s then result this replacement all replacement operations must occur meaning replacement operations should not affect indexing each testcases generated such replacements not testcase s indices sources not generated because replacements resulting string after performing all replacement operations substring contiguous sequence characters s indices sources targets occurs index so we replace occurs index so we replace s indices sources targets occurs index so we replace does not occur index so we do k k s consists only lowercase english consist only lowercase english
second largest digit in a string alphanumeric string second largest numerical digit appears or does not alphanumeric string string consisting lowercase english letters s digits appear s second largest digit s digits appear s there no second largest s consists only lowercase english letters
greatest english letter in upper and lower case string english letters greatest english letter which occurs both lowercase uppercase letter returned letter should no such letter empty english letter b greater than another letter b appears after english s letter only letter appear both lower upper s letter greatest letter appear both lower upper note also appear both lower upper but greater than or s there no letter appears both lower upper s consists lowercase uppercase english
valid perfect square positive integer true num perfect square or false perfect square integer square other product some integer must not use any library such num true we true because num false we false because not num
longest subarray of 1's after deleting one element binary array should delete one element size longest subarray containing only resulting there no such nums after deleting position contains numbers value nums after deleting position longest subarray value nums must delete one either or
surface area of 3d shapes x grid where have placed some x x each value v represents tower v cubes placed top cell after placing these have decided glue any directly adjacent cubes each forming several irregular total surface area resulting bottom face each shape counts toward surface grid grid grid
four divisors integer array sum divisors integers array have exactly four there no such integer nums answer sum divisors nums nums
minimum flips to make a or b equal to c positives numbers b minimum flips required some bits b make or b c or flip operation consists change any single bit or change bit their binary b c after flips b c such or b b c b c b c
number of subarrays with lcm equal to k integer array nums integer subarrays nums where least common multiple elements subarray contiguous sequence elements within least common multiple array smallest positive integer divisible all array nums k subarrays nums where least common multiple all elements nums k there no subarrays nums where least common multiple all k
maximum length of repeated subarray two integer arrays maximum length subarray appears both repeated subarray maximum length repeated subarray maximum length
prime number of set bits in binary representation two integers left count numbers inclusive range having prime set bits their binary recall set bits integer present when written written binary which set left right set set set not set set numbers have prime set left right set set set set set set not numbers have prime set left right right left
sum of distances integer array there exists array arr length where sum over all j such j there no such set array nums when i when i because there no other index value when i when i when i because there no other index value nums since each element nums all
palindrome partitioning ii string partition s such every substring partition palindrome minimum cuts needed palindrome partitioning s palindrome partitioning could produced using s s s consists lowercase english letters
binary watch binary watch leds top represent hours leds bottom represent minutes each led represents zero or least significant bit below binary watch reads integer turnedon which represents leds currently all possible times watch could may answer any hour must not contain leading not should minute must consist two digits may contain leading not should turnedon turnedon turnedon
maximum product of the length of two palindromic subsequences string find two disjoint palindromic subsequences s such product their lengths two subsequences disjoint they do not both pick character same maximum possible product lengths two palindromic subsequence string can derived another string deleting some or no characters without changing order remaining string palindromic reads same forward s optimal solution choose subsequence product their lengths s optimal solution choose first subsequence second product their lengths s optimal solution choose subsequence product their lengths s consists lowercase english letters
minimum average difference integer array nums length average difference index i absolute difference between average first i elements nums average last i both averages should rounded down nearest index minimum average there multiple such smallest absolute difference two numbers absolute value their average elements sum elements divided average elements considered nums average difference index average difference index average difference index average difference index average difference index average difference index average difference index minimum average difference so nums only index so average difference index
univalued binary tree binary tree every node tree same root binary true tree or false root true root false nodes tree range
find the substring with maximum cost string string chars distinct characters integer array vals same length cost substring sum values each character cost empty string considered value character defined following character not string then value corresponding position value value so value assuming i index where character occurs string then value maximum cost among all substrings string s chars vals value characters substring maximum cost cost can proven maximum s chars vals value characters substring maximum cost empty substring cost can proven maximum s consist lowercase english chars consist distinct lowercase english
number of pairs satisfying inequality two integer arrays each size integer find pairs such i j pairs satisfy diff there pairs satisfy i j since i j this pair satisfies i j since i j this pair satisfies i j since i j this pair satisfies we diff since there does not exist any pair satisfies we diff
count days spent together alice bob traveling rome separate business strings alice city dates arrivealice leavealice while bob city dates arrivebob leavebob each string format corresponding month day total days alice bob rome can assume all dates occur same calendar which not leap note days per month can represented arrivealice leavealice arrivebob leavebob alice rome august august bob rome august august they both rome together august so answer arrivealice leavealice arrivebob leavebob there no day when alice bob rome so we all dates provided format alice arrival dates earlier than or equal their leaving dates valid dates
distribute money to maximum children integer money denoting amount money have another integer children denoting children must distribute money have distribute money according following all money must everyone must receive least nobody receives maximum children who may receive exactly dollars distribute money according aforementioned there no way distribute money children maximum children dollars one ways distribute money dollars first dollars second dollars third can proven no distribution exists such children getting dollars greater than money children each child can money children
minimum number of operations to convert time two strings current correct representing two times formatted where hh between mm between earliest time latest one operation can increase time current or can perform this operation any minimum operations needed convert current current correct we can convert current correct operations add minutes current becomes add minutes current becomes add minutes current becomes can proven not possible convert current correct fewer than current correct we only have add one minute so minimum operations needed current correct format current correct
merge two 2d arrays by summing values two integer arrays indicate id idi value equal indicate id idi value equal each array contains unique ids sorted ascending order merge two arrays into one array sorted ascending order respecting following only ids appear least one two arrays should included resulting each id should included only once value should sum values this id two id does not exist one two arrays then value array considered resulting returned array must sorted ascending order resulting array contains id value this id id value this id id value this id id value this id there no common so we just include each id value resulting vali both arrays contain unique both arrays strictly ascending order
largest time for given digits array arr find latest time can made using each digit exactly times formatted where hh between mm between earliest time latest latest time no valid time can empty arr valid times these arr there no valid times not
where will the ball fall have grid size m x representing have box open top bottom each cell box diagonal board spanning two corners cell can redirect ball right or board redirects ball right spans corner corner represented grid board redirects ball left spans corner corner represented grid we drop one ball top each column each ball can get stuck box or fall out ball gets stuck hits shaped pattern between two boards or board redirects ball into either wall array answer size where column ball falls out bottom after dropping ball ith column or ball gets stuck grid this shown ball dropped column falls out box column ball dropped column get stuck box between column row ball dropped column get stuck box between column row ball dropped column get stuck box between column row ball dropped column get stuck box between column row grid ball gets stuck against left grid m or
most beautiful item for each query integer array items where denotes price beauty item also integer array each want determine maximum beauty item whose price less than or equal no such item then answer this query array answer same length queries where answer jth items queries only item which price answer this query items which can considered maximum beauty among them items which can considered maximum beauty among them all items can answer them maximum beauty all items queries price every item equal so we choose item maximum beauty note multiple items can have same price items queries no item price less than or equal so no item can answer query
maximum alternating subsequence sum alternating sum array defined sum elements even indices minus sum elements odd alternating sum array maximum alternating sum any subsequence nums reindexing elements subsequence array new array generated original array deleting some elements without changing remaining relative subsequence underlined while nums optimal choose subsequence alternating sum nums optimal choose subsequence alternating sum nums optimal choose subsequence alternating sum
find the difference of two arrays two integer arrays list answer size list all distinct integers which not present list all distinct integers which not present note integers lists may returned any present index whereas not present present index whereas not present not present since their value only included once every integer present
n-ary tree level order traversal level order traversal input serialization represented their level order each group children separated null value root root height tree less than or equal total nodes between
minimum cost to connect two groups of points two groups points where first group second group cost connection between any two points x matrix where cost connecting point i first group point j second groups connected each point both groups connected one or more points opposite other each point first group must connected least one point second each point second group must connected least one point first minimum cost takes connect two cost optimal way connecting groups this results total cost cost optimal way connecting groups this results total cost note there multiple points connected point first group point second this does not matter there no limit points can we only care about minimum total cost
longest word in dictionary array strings words representing english longest word words can built one character time other words there more than one possible longest word smallest lexicographical there no empty note word should built left right each additional character being added end previous words word can built one character time words both can built other words lexicographically smaller than consists lowercase english
sum of left leaves root binary sum all left leaf node no left leaf leaf left child another root there two left leaves binary values root nodes tree range
find the kth largest integer in the array array strings nums integer each string nums represents integer without leading string represents kth largest integer duplicate numbers should counted nums first largest nums k numbers nums sorted order largest integer nums nums k numbers nums sorted order largest integer nums nums k numbers nums sorted order largest integer nums k consists only not have any leading
to lower case string string after replacing every uppercase letter same lowercase s s s s consists printable ascii
house robber ii professional robber planning rob houses along each house certain amount money all houses this place arranged means first house neighbor last adjacent houses have security system automatically contact police two adjacent houses broken into same integer array nums representing amount money each maximum amount money can rob tonight without alerting nums cannot rob house then rob house because they adjacent nums rob house then rob house total amount can rob nums
maximum number of groups getting fresh donuts there donuts shop bakes donuts batches they have rule where they must serve all donuts batch before serving any donuts next integer batchsize integer array where denotes there group customers visit each customer get exactly one when group visits all customers group must served before serving any following group happy they all get fresh first customer group does not receive donut left over previous can freely rearrange ordering maximum possible happy groups after rearranging batchsize groups can arrange groups then groups batchsize groups batchsize
goal parser interpretation own goal parser can interpret string command consists alphabet some goal parser interpret string string string interpreted strings then concatenated original string goal interpretation command goal parser interprets command g g o al final concatenated result command command command consists some
merge in between linked lists two linked sizes m remove nodes ath node bth put their blue edges nodes following figure indicate build result list b we remove nodes put entire their blue edges nodes above figure indicate b blue edges nodes above figure indicate b
convert 1d array into 2d array integer array two m tasked creating array m rows columns using all elements elements indices original should form first row constructed elements indices should form second row constructed so m x array constructed according above or empty array original m constructed array should contain rows first group elements becomes first row constructed second group elements becomes second row constructed original m constructed array should contain row put all three elements original into first row constructed original m there elements impossible fit elements so empty
convert integer to the sum of two no-zero integers integer positive integer does not contain any decimal integer list two integers b b test cases generated so there least one valid there many valid can any let b both b b let b both b b note there other valid answers can
closest prime numbers in range two positive integers left find two integers such left right both prime minimum amongst all other pairs satisfying above positive integer array ans there multiple pairs satisfying these one minimum value or such numbers do not greater than called prime only divisible left right prime numbers between closest gap between any pair which can achieved or since smaller than we first left right there exists only one prime so conditions cannot left right
rotate string two strings s true only s can become goal after some shifts shift s consists moving leftmost character s rightmost s then after one s goal true s goal false s goal consist lowercase english
find the student that will replace the chalk there students class numbered teacher give each student problem starting student then student so until teacher reaches student after teacher restart starting student integer array chalk integer there initially k pieces when student i problem they use pieces chalk solve current chalk pieces strictly less than then student i asked replace index student replace chalk chalk k students go turns student uses so k student uses so k student uses so k student uses so k student uses so k student uses so k student does not have enough so they have replace chalk k students go turns student uses chalk so k student uses chalk so k student uses chalk so k student uses chalk so k student uses chalk so k student uses chalk so k student uses chalk so k student uses chalk so k student uses chalk so k student does not have enough so they have replace k
convert the temperature floating point rounded two decimal places denotes temperature should convert celsius into kelvin fahrenheit array ans array answers within actual answer note kelvin celsius fahrenheit celsius celsius temperature celsius converted kelvin converted fahrenheit celsius temperature celsius converted kelvin converted fahrenheit celsius
map of highest peak integer matrix iswater size m x represents map land water cell land cell water must assign each cell height way follows these height each cell must cell water height must any two adjacent cells must have absolute height difference most cell adjacent another cell former directly or west latter their sides find assignment heights such maximum height matrix integer matrix height size m x where cell there multiple any iswater image shows assigned heights each blue cell water green cells land iswater height maximum possible height any any height assignment maximum height while still meeting rules also m or there least one water
fizz buzz multithreaded have four printfizz prints word printbuzz prints word printfizzbuzz prints word printnumber prints integer instance class fizzbuzz four fizzbuzz same instance fizzbuzz passed four different thread calls should output word thread calls should output word thread calls should output word thread calls should only output modify class output series where ith token series i divisible i divisible not i divisible not or i i not divisible or implement fizzbuzz initializes object represents length sequence should void calls printfizz output void calls printbuzz output void calls printfizzbuzz output void calls printnumber output
jump game vi integer array nums integer initially standing index one can jump most k steps forward without going outside boundaries can jump index i any index range i want reach last index array your score sum all each index j visited maximum score can nums k can choose your jumps forming subsequence sum nums k can choose your jumps forming subsequence sum nums k k
permutations array nums distinct all possible can answer any nums nums nums all integers nums
random pick with blacklist integer array unique integers design algorithm pick random integer range not any integer mentioned range not blacklist should equally likely optimize your algorithm such minimizes calls random function your implement solution initializes object integer blacklisted integers int returns random integer range not input output explanation solution solution new any integer should note every call must equally likely returned probability all values blacklist most calls made
find the longest valid obstacle course at each position want build some obstacle integer array obstacles length where describes height ith every index i between find length longest obstacle course obstacles such choose any obstacles between i must include ith obstacle must put chosen obstacles same order they appear every obstacle taller than or same height obstacle immediately before array ans length where length longest obstacle course index i described obstacles longest valid obstacle course each position i length i length i length i length obstacles longest valid obstacle course each position i length i length i length obstacles longest valid obstacle course each position i length i length i length also i length also i length also i length
find the minimum and maximum number of nodes between critical points critical point linked list defined either local maxima or local node local maxima current node value strictly greater than previous node next node local minima current node value strictly smaller than previous node next note node can only local there exists both previous node next linked list array length containing where mindistance minimum distance between any two distinct critical points maxdistance maximum distance between any two distinct critical there fewer than two critical head there no critical points head there three critical third node local minima because less than fifth node local maxima because greater than sixth node local minima because less than minimum distance between fifth sixth mindistance maximum distance between third sixth maxdistance head there two critical second node local maxima because greater than fifth node local maxima because greater than both minimum maximum distances between second fifth mindistance maxdistance note last node not considered local maxima because does not have next nodes list range
distribute candies alice where ith candy type alice noticed she started gain so she visited doctor advised alice only eat candies she always alice likes her candies very she wants eat maximum different types candies while still following integer array candytype length maximum different types candies she can eat she only eats candytype alice can only eat since there only she can eat one each candytype alice can only eat whether she eats types or she still can only eat different candytype alice can only eat even though she can eat she only
trapping rain water ii m x integer matrix heightmap representing height each unit cell elevation volume water can trap after heightmap after water trapped between we have two small ponds units total volume water trapped heightmap m
longest uncommon subsequence ii array strings length longest uncommon subsequence between longest uncommon subsequence does not uncommon subsequence between array strings string subsequence one string but not subsequence string s string can obtained after deleting any characters subsequence because can delete underlined characters get other subsequences include strs strs consists lowercase english
non-overlapping intervals array intervals intervals where minimum intervals need remove make rest intervals intervals can removed rest intervals intervals need remove two make rest intervals intervals need remove any intervals since already starti endi
binary gap positive integer find longest distance between any two adjacent binary representation there no two adjacent two adjacent there only separating them no distance between two absolute difference between their bit two have distance binary first adjacent pair distance second adjacent pair distance answer largest these two which note not valid pair since there separating two binary there not any adjacent pairs binary representation so we binary
rle iterator we can use encoding encode sequence encoded array even length encoding all even tells us times integer value repeated sequence arr can encoded encoding encoding encoding also valid rle encoded design iterator iterates through implement rleiterator initializes object encoded array int exhausts next elements returns last element exhausted this there no element left input output explanation rleiterator rleiterator new this maps sequence exhausts terms returning remaining sequence now exhausts term returning remaining sequence now exhausts term returning remaining sequence now exhausts returning this because first term exhausted but second term did not since last term exhausted does not we most calls made
minimize xor two positive integers find positive integer x such x same set bits value x xor note xor bitwise xor integer test cases generated such x uniquely set bits integer binary binary representations integer same set bits value xor binary representations integer same set bits value xor
remove duplicates from sorted array integer array nums sorted remove duplicates such each unique element appears only relative order elements should kept then unique elements consider unique elements nums get need do following change array nums such first k elements nums contain unique elements order they present nums remaining elements nums not important well size custom judge test your solution following nums input array expectednums expected answer correct length int k calls your implementation assert k i i assert all assertions then your solution nums nums your function should k first two elements nums being does not matter what leave beyond returned k they nums nums your function should k first five elements nums being does not matter what leave beyond returned k they nums sorted
find missing observations have observations m dice rolls each face numbered observations went only have observations m have also calculated average value m integer array rolls length m where value ith also two integers mean array length containing missing observations such average value m rolls exactly there multiple valid any no such array empty average value set k numbers sum numbers divided note mean so sum m rolls should divisible rolls mean mean all m rolls rolls mean mean all m rolls rolls mean impossible mean no matter what missing rolls m m mean
largest submatrix with rearrangements binary matrix matrix size m x allowed rearrange columns matrix any area largest submatrix within matrix where every element submatrix after reordering columns matrix can rearrange columns shown largest submatrix area matrix can rearrange columns shown largest submatrix area matrix notice must rearrange entire there no way make submatrix larger than area m m either or
best sightseeing pair integer array values where represents value ith sightseeing two sightseeing spots i j have distance j i between score pair sightseeing spots i sum values sightseeing minus distance between maximum score pair sightseeing values i j i j values
detonate the maximum bombs list range bomb defined area where effect can this area shape circle center location bombs represented integer array bombs where xi yi denote location ith whereas ri denotes radius may choose detonate single when bomb detonate all bombs lie these bombs further detonate bombs lie their list maximum bombs can detonated allowed detonate only one bombs above figure shows positions ranges we detonate left right bomb not but we detonate right both bombs so maximum bombs can detonated bombs detonating either bomb not detonate other so maximum bombs can detonated bombs best bomb detonate bomb bomb detonates bombs red circle denotes range bomb bomb detonates bomb blue circle denotes range bomb bomb detonates bomb green circle denotes range bomb thus all bombs ri
smallest number in infinite set have set which contains all positive integers implement smallestinfiniteset initializes smallestinfiniteset object contain all positive int removes returns smallest integer contained infinite void adds positive integer num back into infinite not already infinite input output explanation smallestinfiniteset smallestinfiniteset new already so no change since smallest remove remove remove added back since added back set smallest remove remove remove num most calls made total popsmallest
design graph with shortest path calculator there directed weighted graph consists nodes numbered edges graph initially represented array edges where meaning there edge fromi toi cost implement graph initializes object nodes adds edge list edges where edge guaranteed there no edge between two nodes before adding this int int returns minimum cost path no path cost path sum costs edges input output explanation graph g new shortest path first diagram above total cost there no path we add edge node node we get second diagram shortest path now total cost edgecost there no repeated edges no graph any most calls made most calls made
single number ii integer array nums where every element appears three times except which appears exactly find single element must implement solution linear runtime complexity use only constant extra nums nums each element nums appears exactly three times except one element which appears
strange printer ii there strange printer following two special each printer print solid rectangular pattern single color this cover up existing colors once printer used color above same color cannot used m x matrix where color position true possible print matrix targetgrid true targetgrid true targetgrid false impossible form targetgrid because not allowed print same color different m
largest substring between two equal characters string length longest substring between two equal excluding two there no such substring substring contiguous sequence characters within s optimal substring here empty substring between two s optimal substring here s there no characters appear twice s contains only lowercase english
count anagrams string s containing one or more every consecutive pair words separated single space string t anagram string s ith word t permutation ith word anagram but distinct anagrams since answer may very modulo s some anagrams string s there only one anagram possible s consists lowercase english letters spaces there single space between consecutive
count the number of complete components integer there undirected graph numbered integer array edges where denotes there exists undirected edge connecting vertices ai complete connected components connected component subgraph graph which there exists path between any two no vertex subgraph shares edge vertex outside connected component said complete there exists edge between every pair edges picture one can see all components this graph edges component containing vertices complete since there edge between every pair two other component containing vertices not complete since there no edge between vertices complete components this graph bi ai bi there no repeated
check if numbers are ascending in a sentence sentence list tokens separated single space no leading or trailing every token either positive consisting digits no leading or word consisting lowercase english puppy eyes sentence seven numbers other tokens such string s representing need check all numbers s strictly increasing left right other than last each strictly smaller than right true or false s box blue red green yellow true numbers s they strictly increasing left s world x false numbers s they not strictly s pm overnight lows low false numbers s they not strictly s consists lowercase english digits tokens s between tokens s separated single there least two numbers each s positive less than no leading s contains no leading or trailing
soup servings there two types type type we have ml each type there four kinds serve ml soup ml soup serve ml soup ml soup serve ml soup ml soup serve ml soup ml soup when we serve some we give we no longer have each we choose four operations equal probability remaining volume soup not enough complete we serve much we stop once we no longer have some quantity both types note we do not have operation where all soup b used probability soup empty plus half probability b become empty same answers within actual answer we choose first two become empty third b become empty same fourth b become empty so total probability becoming empty first plus half probability b become empty same
flip binary tree to match preorder traversal root binary tree where each node uniquely assigned value also sequence values which desired traversal binary any node binary tree can flipped swapping left right flipping node have following flip smallest nodes so traversal tree matches list values all flipped may answer any impossible flip nodes tree make traversal match list root voyage impossible flip nodes such traversal matches root voyage flipping node swaps nodes so traversal matches root voyage traversal already matches so no nodes need nodes tree all values tree all values voyage
rotate image x matrix representing rotate image degrees have rotate image which means have modify input matrix do not allocate another matrix do matrix matrix
additive number additive string whose digits can form additive valid additive sequence should contain least three except first two each subsequent sequence must sum preceding string containing only true additive or false numbers additive sequence cannot have leading so sequence or true digits can form additive true additive sequence num consists only follow how would handle overflow very large input
sqrt(x) integer square root x rounded down nearest returned integer should must not use any exponent function or do not use or x x square root so we x square root since we round down nearest x
stone game iii alice bob continue their games piles there several stones arranged each stone associated value which integer array alice bob take alice starting each player can take or stones first remaining stones score each player sum values stones score each player objective game end highest winner player highest score there could game continues until all stones have been assume alice bob play alice bob or they end game same stonevalue alice always her best move take three piles score become now score bob bob stonevalue alice must choose all three piles first move win leave bob negative alice chooses one pile her score next move score becomes next alice take pile value alice chooses two piles her score next move score becomes next alice take pile value also remember both play optimally so here alice choose scenario makes her stonevalue alice cannot win this she can end game draw she decided choose all first three otherwise she
destination city array where means there exists direct path going cityai destination city without any path outgoing another guaranteed graph paths forms line without any there exactly one destination paths starting city reach city which destination your trip consist paths all possible trips clearly destination city paths cityai citybi all strings consist lowercase uppercase english letters space
number of enclaves m x binary matrix where represents sea cell represents land move consists walking one land cell another adjacent land cell or walking off boundary land cells grid which we cannot walk off boundary grid any grid there three enclosed one not enclosed because grid all either boundary or can reach m either or
number of nodes in the sub-tree with the same label tree undirected graph no consisting nodes numbered exactly root tree node each node tree label which character string labels node i label edges array form which means there edge between nodes ai bi array size where nodes subtree ith node which have same label node subtree tree t tree consisting node t all descendant edges labels node label node label thus answer notice any node part node label node contains nodes nodes have different labels than node answer just node edges labels node contains only node so answer node contains only node so answer node contains nodes both have label thus answer node contains nodes all label thus answer edges labels bi ai bi labels consisting only lowercase english
sum of number and its reverse integer true num can expressed sum any integer or false num true so we num false cannot expressed sum integer reverse so we num true so we note when there may leading num
find triangular sum of an array integer array where digit between triangular sum nums value only element present nums after following process let nums comprise end create new integer array newnums length each index where i assign value where denotes modulo replace array nums repeat entire process starting step triangular sum nums above diagram depicts process which we obtain triangular sum nums since there only one element triangular sum value element
valid mountain array array integers true only valid mountain recall arr mountain array only there exists some i i such arr false arr false arr true
minimum absolute difference array distinct integers find all pairs elements minimum absolute difference any two list pairs ascending respect each pair follows b arr b b equals minimum absolute difference any two elements arr arr minimum absolute difference list all pairs difference equal ascending arr arr
find the pivot integer positive integer find pivot integer x such sum all elements between x inclusively equals sum all elements between x pivot integer no such integer guaranteed there most one pivot index pivot integer pivot integer can proved no such integer
path sum iii root binary tree integer paths where sum values along path equals path does not need start or end root or but must go downwards traveling only parent nodes child root targetsum paths sum root targetsum nodes tree range targetsum
longest substring of one repeating character string also string querycharacters length k array integer indices queryindices length both which used describe k ith query updates character s index character array lengths length k where length longest substring s consisting only one repeating character after ith query s querycharacters queryindices query updates s longest substring consisting one repeating character length query updates s longest substring consisting one repeating character can or length query updates s longest substring consisting one repeating character length we s querycharacters queryindices query updates s longest substring consisting one repeating character length query updates s longest substring consisting one repeating character length we s consists lowercase english k k querycharacters consists lowercase english
ways to make a fair array integer array can choose exactly one index remove notice index elements may change after nums choosing remove index results nums choosing remove index results nums choosing remove index results nums array fair sum values equals sum indices could choose such after nums nums remove index even odd not remove index even odd remove index even odd not remove index even odd not there index can remove make nums nums can remove any index remaining array nums cannot make fair array after removing any
shortest distance to target string in a circular array circular string array words string circular array means end connects next element previous element where length starting can move either next word or previous word step shortest distance needed reach string string target does not exist words target startindex we start index can reach moving units right reach index moving units left reach index moving units right reach index moving unit left reach index shortest distance reach words target startindex we start index can reach moving units right reach index moving unit left reach index shortest distance reach words target startindex since does not exist we target consist only lowercase english startindex
shortest cycle in a graph there graph where each vertex labeled edges graph represented integer array where denotes edge between vertex ui vertex every vertex pair connected most one no vertex edge length shortest cycle no cycle cycle path starts ends same each edge path used only edges cycle smallest length edges there no cycles this vi ui vi there no repeated
encrypt and decrypt strings character array keys containing unique characters string array values containing strings length also another string array dictionary contains all permitted original strings after should implement data structure can encrypt or decrypt string encrypted following each character c we find index i satisfying c replace c note case character string not present encryption process cannot carried empty string string decrypted following each substring s length occurring even index we find i such there multiple valid we choose any one this means string could have multiple possible strings can decrypt replace s implement encrypter initializes encrypter class string encrypts encryption process described above returns encrypted int returns possible strings could decrypt also appear input output explanation encrypter encrypter new maps maps maps maps can map or maps maps possible strings after decryption those appear so answer all all appear only contain lowercase english most calls made encrypt decrypt
make two arrays equal by reversing subarrays two integer arrays equal length target one can select any subarray arr reverse allowed make any true can make arr equal target or false target arr true can follow next steps convert arr reverse subarray arr becomes reverse subarray arr becomes reverse subarray arr becomes there multiple ways convert arr this not only way do target arr true arr equal target without any target arr false arr does not have value can never converted
maximum number of fish in a grid matrix grid size m x where land cell or water cell containing fisher can start any water cell can do following operations any catch all fish cell or move any adjacent water maximum fish fisher can catch chooses his starting cell or no water cell adjacent cell cell one cells c c or grid fisher can start cell collect then move cell collect grid fisher can start cells or collect single m
maximum frequency stack design data structure push elements stack pop most frequent element implement freqstack constructs empty frequency void pushes integer val onto top int removes returns most frequent element there tie most frequent element closest top removed input output explanation freqstack freqstack new stack stack stack stack stack stack most stack becomes most but closest stack becomes most stack becomes most but closest stack becomes val most calls made push guaranteed there least one element stack before calling
replace elements with greatest element on right side array replace every element array greatest element among elements replace last element after doing arr index greatest element right index index index greatest element right index index index greatest element right index index index greatest element right index index index greatest element right index index index there no elements right index so we put arr there no elements right index
walking robot simulation robot infinite starts point facing robot can receive sequence these three possible types turn left turn right k move forward k one unit some grid squares ith obstacle grid point robot runs into then instead stay current location move next maximum euclidean distance robot ever gets origin squared distance north means east means south means west means commands obstacles robot starts move north units turn move east units furthest point robot ever gets origin which squared units commands obstacles robot starts move north units turn move east unit get blocked obstacle robot turn move north units furthest point robot ever gets origin which squared units commands obstacles robot starts move north units turn turn move south units furthest point robot ever gets origin which squared units either or integer range yi answer guaranteed less than
minimum distance between bst nodes root binary search tree minimum difference between values any two different nodes root root nodes tree range this question same
merge strings alternately two strings merge strings adding letters alternating starting string longer than append additional letters onto end merged merged merged string merged b c p q r p b q c r notice appended b p q r s p b q r s notice appended b c d p q p b q c d consist lowercase english
max number of k-sum pairs integer array nums integer one can pick two numbers array whose sum equals k remove them maximum operations can perform nums k starting nums remove numbers then nums remove numbers then nums there no more pairs sum up hence total nums k starting nums remove first two then nums there no more pairs sum up hence total k
find closest node to given two nodes directed graph nodes numbered where each node most one outgoing graph represented array edges size indicating there directed edge node i node there no outgoing edge then also two integers index node can reached both such maximum between distance node there multiple node smallest no possible answer note edges may contain edges distance node node distance node node maximum those two distances can proven we cannot get node smaller maximum distance than so we node edges distance node node distance node itself maximum those two distances can proven we cannot get node smaller maximum distance than so we node i
maximal rectangle rows x cols binary matrix filled find largest rectangle containing only matrix maximal rectangle shown above matrix matrix rows cols cols or
most frequent number following key in an array integer array also integer which present every unique integer target count times target immediately follows occurrence key other count indices i such i key target maximum test cases generated such target maximum count nums key target there occurrences indices which follow occurrence no other integers follow occurrence so we nums key target there occurrences indices which follow occurrence target there only one occurrence index which follows occurrence target maximum occurrences following occurrence so we test cases generated such answer
count servers that communicate map server represented m integer matrix where means cell there server means no two servers said communicate they same row or same servers communicate any other grid no servers can communicate grid all three servers can communicate least one other grid two servers first row can communicate each two servers third column can communicate each server right bottom corner communicate any other m m or
longest subsequence with limited sum integer array nums length integer array queries length array answer length m where maximum size subsequence can take nums such sum elements less than or equal subsequence array can derived another array deleting some or no elements without changing order remaining nums queries we answer queries subsequence sum less than or equal can proven maximum size such so subsequence sum less than or equal can proven maximum size such so subsequence sum less than or equal can proven maximum size such so nums queries empty subsequence only subsequence sum less than or equal so m m
design browser history have browser one tab where start homepage can visit another get back history steps or move forward history implement browserhistory initializes object homepage void visits url current clears up all forward string move steps back can only x steps history steps only x current url after moving back history most string move steps forward can only forward x steps history steps forward only x current url after forwarding history most browserhistory browserhistory new visit visit visit move back move back move forward visit cannot move forward any move back two steps then can move back only one step steps homepage url consist or lower case english most calls made
counter ii write function should accept initial integer should object three three functions increases current value then returns reduces current value then returns sets current value init then returns init calls const counter init calls const counter init total calls not exceed
robot return to origin there robot starting position sequence judge this robot ends up after completes string moves represents move sequence robot where represents ith valid moves true robot returns origin after finishes all or false way robot always make robot move right always make move assume magnitude movement same each moves true robot moves up then down all moves have same so ended up origin where we moves false robot moves left ends up two left we false because not origin end moves only contains characters
sum of square numbers integer decide whether two integers b such c true c false c
maximum ice cream bars sweltering summer boy wants buy some ice cream there ice cream array costs length where price ith ice cream bar boy initially coins coins wants buy many ice cream bars boy can buy ice cream bars any maximum ice cream bars boy can buy coins must solve problem counting costs coins boy can buy ice cream bars indices total price costs coins boy cannot afford any ice cream costs coins boy can buy all ice cream bars total price coins
max value of equation array points containing coordinates points sorted where such xi xj all i j also integer maximum value equation yi yj where k i j guaranteed there exists least one pair points satisfy constraint points k first two points satisfy condition we calculate equation we get third fourth points also satisfy condition give value no other pairs satisfy so we max points k only first two points have absolute difference or less give value yi k xi xj all i j xi form strictly increasing
maximum number of non-overlapping subarrays with sum equals target array nums integer maximum subarrays such sum values each subarray equal nums target there subarrays sum equals nums target there subarrays sum equal but only first target
restore the array from adjacent pairs there integer array nums consists unique but have forgotten do remember every pair adjacent elements integer array adjacentpairs size where each indicates elements ui vi adjacent guaranteed every adjacent pair elements exist either or pairs can appear any original array there multiple any adjacentpairs this array all adjacent pairs notice may not adjacentpairs there can negative another solution which would also adjacentpairs vi there exists some nums adjacentpairs
design circular deque design your implementation circular queue implement mycirculardeque initializes deque maximum size boolean adds item front returns true operation or false boolean adds item rear returns true operation or false boolean deletes item front returns true operation or false boolean deletes item rear returns true operation or false int returns front item returns deque int returns last item returns deque boolean returns true deque or false boolean returns true deque or false input output explanation mycirculardeque mycirculardeque new true true true queue true true true k value most calls made
calculate money in leetcode bank hercy wants save money his first puts money leetcode bank every starts putting first every day tuesday put more than day every subsequent put more than previous total amount money have leetcode bank end nth after total after total notice hercy only puts after total
remove nodes from linked list head linked remove every node which node strictly greater value anywhere right side head modified linked head nodes should removed node right node node right node node right node head every node value so no nodes nodes list range
path sum ii root binary tree integer all paths where sum node values path equals each path should returned list node not node path path starting root ending any leaf leaf node no root targetsum there two paths whose sum equals root targetsum root targetsum nodes tree range targetsum
find all lonely numbers in the array integer array x lonely when appears only no adjacent numbers x x appear all lonely numbers may answer any nums lonely since appears exactly once does not appear lonely since appears exactly once does not appear not lonely since appears nums vice lonely numbers nums note may also nums lonely since appears exactly once does not appear lonely since appears exactly once does not appear not lonely since appears lonely numbers nums note may also
minimum absolute difference in bst root binary search tree minimum absolute difference between values any two different nodes root root nodes tree range this question same
convert sorted list to binary search tree head singly linked list where elements sorted ascending convert binary search head one possible answer which represents shown height balanced head nodes head range
maximum sum of two non-overlapping subarrays integer array nums two integers firstlen maximum sum elements two subarrays lengths firstlen array length firstlen could occur before or after array length but they have subarray contiguous part nums firstlen secondlen one choice subarrays length length nums firstlen secondlen one choice subarrays length length nums firstlen secondlen one choice subarrays length length secondlen firstlen secondlen firstlen secondlen
lexicographical numbers integer all numbers range sorted lexicographical must write algorithm runs time uses extra
minimum operations to make the array increasing integer array nums one can choose element array increment nums can choose increment make nums minimum operations needed make nums strictly array nums strictly increasing all i array length trivially strictly nums can do following increment so nums becomes increment so nums becomes increment so nums becomes nums nums
number of great partitions array nums consisting positive integers integer partition array into two ordered groups such each element exactly one partition called great sum elements each group greater than or equal distinct great since answer may too modulo two partitions considered distinct some element different groups two nums k great partitions nums k there no great partitions this nums k we can either put first partition or second great partitions k
max consecutive ones binary array maximum consecutive nums first two digits or last three digits consecutive maximum consecutive nums either or
maximum xor for each query sorted array nums integers integer want perform following query find integer k such xor xor xor xor k k answer ith remove last element current array array where answer ith nums maximumbit queries answered nums k since xor xor xor xor nums k since xor xor xor nums k since xor xor nums k since xor nums maximumbit queries answered nums k since xor xor xor xor nums k since xor xor xor nums k since xor xor nums k since xor nums maximumbit maximumbit nums sorted ascending
matrix diagonal sum square matrix sum matrix only include sum all elements primary diagonal all elements secondary diagonal not part primary mat diagonals notice element counted only mat mat
number of ways where square of number is equal to product of two numbers two arrays integers triplets formed type under following type triplet where i j k type triplet where i j k type all triplets because type type there valid type type
distinct echo substrings distinct substrings text can written concatenation some string itself can written where some text substrings text substrings text only lowercase english
maximum length of subarray with positive product array integers find maximum length subarray where product all elements subarray array consecutive sequence zero or more values taken out maximum length subarray positive nums array nums already positive product nums longest subarray positive product which product notice we cannot include subarray since make product which not nums longest subarray positive product or
check if there is a valid path in a grid m x each cell grid represents street can which means street connecting left cell right which means street connecting upper cell lower which means street connecting left cell lower which means street connecting right cell lower which means street connecting left cell upper which means street connecting right cell upper initially start street cell valid path grid path starts upper left cell ends cell path should only follow notice not allowed change any true there valid path grid or false grid true shown can start cell visit all cells grid reach grid false shown street cell not connected any street any other cell get stuck cell grid false get stuck cell cannot reach cell m
mean of array after removing some elements integer array mean remaining integers after removing smallest largest answers within actual answer considered arr after erasing minimum maximum values this all elements equal so mean arr arr multiple
super egg drop k identical eggs have access building floors labeled know there exists floor f where f such any egg dropped floor higher than f any egg dropped or below floor f not each may take unbroken egg drop any floor x x egg can no longer use egg does not may reuse future minimum moves need determine certainty what value f k drop egg floor we know f drop egg floor we know f does not then we know f we need minimum moves determine certainty what value f k k k
all ancestors of a node in a directed acyclic graph positive integer representing nodes directed acyclic graph nodes numbered also integer array where denotes there unidirectional edge fromi toi list where list ancestors ith sorted ascending node u ancestor another node v u can reach v via set edgelist above diagram represents input nodes do not have any node two ancestors node two ancestors node three ancestors node five ancestors node four ancestors edgelist above diagram represents input node does not have any node one ancestor node two ancestors node three ancestors node four ancestors toi fromi toi there no duplicate graph directed
using a robot to print the lexicographically smallest string string s robot currently holds empty string apply one following operations until s t both remove first character string s give robot append this character string remove last character string t give robot write this character lexicographically smallest string can written s let p denote written initially perform first operation three times perform second operation three times s let p denote written perform first operation twice perform second operation twice perform first operation perform second operation s let p denote written initially perform first operation four times perform second operation four times s consists only english lowercase
create sorted array through instructions integer array asked create sorted array elements start empty container each element left right insert into cost each insertion minimum elements currently nums strictly less than elements currently nums strictly greater than inserting element into nums cost insertion less than element greater than nums become total cost insert all elements instructions into since answer may modulo instructions begin nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums total cost instructions begin nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums total cost instructions begin nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums insert cost now nums total cost
insufficient nodes in root to leaf paths root binary tree integer delete all insufficient nodes tree root resulting binary node insufficient every root leaf path intersecting this node sum strictly less than leaf node no root limit root limit root limit nodes tree range limit
students and examinations sql schema students column name type int varchar primary key this each row this table contains id name one student subjects column name type varchar primary key this each row this table contains name one subject examinations column name type int varchar there no primary key this may contain each student students table takes every course subjects each row this table indicates student id attended exam write sql query find times each student attended each result table ordered query result format following students alice bob john alex subjects math physics programming examinations math physics programming programming physics math math programming physics math math alice math alice physics alice programming bob math bob physics bob programming alex math alex physics alex programming john math john physics john programming result table should contain all students all alice attended math exam physics exam programming exam bob attended math exam programming exam did not attend physics alex did not attend any john attended math exam physics exam programming exam
first day where you have been in all the rooms there rooms need labeled each day starting go visit one room initially day visit room order visit rooms coming days determined following rules array nextvisit length assuming visit room have been room i odd times current next day visit room lower or equal room specified where have been room i even times current next day visit room mod label first day where have been all can shown such day since answer may very modulo nextvisit day visit room total times have been room which next day visit room day visit room total times have been room which next day visit room mod day visit room this first day where have been all nextvisit your room visiting order each day day first day where have been all nextvisit your room visiting order each day day first day where have been all i
determine if string halves are alike string s even split this string into two halves equal let first half b second two strings alike they have same vowels notice s contains uppercase lowercase true b s true b vowel b they s false b vowel whereas b they not notice vowel o counted s consists uppercase lowercase
simplified fractions integer list all simplified fractions between such denominator can answer any only unique fraction denominator not simplified fraction because can simplified
maximum units on a truck assigned put some amount boxes onto one array where numberofboxesi boxes type numberofunitsperboxi units each box type also integer which maximum boxes can put can choose any boxes put truck long boxes does not exceed maximum total units can put boxtypes trucksize there box first type contains boxes second type contain units boxes third type contain unit can take all boxes first second one box third total units boxtypes trucksize numberofunitsperboxi trucksize
maximum number of moves in a grid m x matrix grid consisting positive can start any cell first column traverse grid following cell can move any col col col such value cell move should strictly bigger than value current maximum moves can grid we can start cell make following can shown maximum moves can grid starting any cell first column we cannot perform any m m
check if two string arrays are equivalent two string arrays true two arrays represent same false string represented array array elements concatenated order forms true represents string represents string strings so false true consist lowercase
count numbers with unique digits integer count all numbers unique where x answer should total numbers range x excluding
minimum elements to add to form a given sum integer array nums two integers limit array nums interesting property minimum elements need add make sum array equal array must maintain property note equals x x nums limit goal can add then sum array nums limit goal limit limit goal
binary search tree to greater sum tree root binary search tree convert greater tree such every key original bst changed original key plus sum all keys greater than original key binary search tree tree satisfies these left subtree node contains only nodes keys less than right subtree node contains only nodes keys greater than both left right subtrees must also binary search root root nodes tree range all values tree this question same
time needed to inform all employees company employees unique id each employee head company one each employee one direct manager manager array where direct manager guaranteed subordination relationships have tree head company wants inform all company employees urgent piece inform his direct they inform their so until all employees know about urgent employee needs minutes inform all his direct subordinates after all his direct subordinates can start spreading minutes needed inform all employees about urgent headid manager informtime head company only employee headid manager informtime head company id direct manager all employees company needs minute inform them tree structure employees company headid employee i no guaranteed all employees can
ugly number ii ugly positive integer whose prime factors limited integer nth ugly sequence first ugly no prime therefore all prime factors limited
find the smallest divisor given a threshold array integers nums integer we choose positive integer divide all array sum find smallest divisor such result mentioned above less than or equal each result division rounded nearest integer greater than or equal test cases generated so there nums threshold we can get sum divisor divisor we can get sum divisor sum nums threshold threshold
smallest subtree with all the deepest nodes root binary depth each node shortest distance smallest subtree such contains all deepest nodes original node called deepest largest depth possible among any node entire subtree node tree consisting plus set all descendants root we node value colored yellow nodes coloured blue deepest nodes notice nodes contain deepest nodes tree but node smallest subtree among so we root root deepest node root deepest node tree valid subtrees subtrees nodes but subtree node nodes tree range values nodes tree this question same
long pressed name your friend typing his name into when typing character key might get long character typed or more examine typed characters true possible your friends some characters being long name typed true long name typed false must have been pressed but not typed name typed consist only lowercase english
final prices with a special discount in a shop integer array prices where price ith item there special discount items buy ith then receive discount equivalent where j minimum index such j i not receive any discount integer array answer where final price pay ith item considering special prices item receive discount equivalent final price pay item receive discount equivalent final price pay item receive discount equivalent final price pay items not receive any discount prices this all not receive any discount prices
find array given subset sums integer representing length unknown array trying also array sums containing values all subset sums unknown array no particular array ans length representing unknown multiple answers any array sub subset array arr sub can obtained arr deleting some zero or elements sum elements sub one possible subset sum sum empty array considered test cases generated such there always least one correct sums able achieve subset sum sum sum sum sum sum sum sum note any permutation also any permutation also sums only correct answer sums able achieve subset
building boxes have cubic storeroom where height room all equal asked place boxes this room where each box cube unit side there however some rules placing can place boxes anywhere box x placed top box then each side four vertical sides box y must either adjacent another box or integer minimum possible boxes touching figure above placement three these boxes placed corner where corner left figure above placement four these boxes placed corner where corner left figure above placement ten these boxes placed corner where corner back
longest cycle in a graph directed graph nodes numbered where each node most one outgoing graph represented array edges size indicating there directed edge node i node there no outgoing edge node then length longest cycle no cycle cycle path starts ends same edges longest cycle graph length this cycle so edges there no cycles this i
base 7 integer string base num num num
smallest string with a given numeric value numeric value lowercase character defined position so numeric value numeric value b numeric value c so numeric value string consisting lowercase characters defined sum numeric numeric value string equal two integers lexicographically smallest string length equal numeric value equal note string x lexicographically smaller than string y x comes before y dictionary either x prefix or i first position such then comes before alphabetic k numeric value string smallest string such value length equal k k
words within two edits of dictionary two string queries all words each array comprise lowercase english letters have same one edit can take word change any letter any other find all words queries after maximum two equal some word list all words match some word dictionary after maximum two words same order they appear queries dictionary changing allows equal dictionary word changing changes would take more than edits equal dictionary can remain unchanged match corresponding dictionary we queries dictionary applying any two edits cannot make equal we empty all composed lowercase english
find nearest point that has the same x or y coordinate two x which represent your current location cartesian also array points where each represents point exists point valid shares same or same your index valid point smallest manhattan distance your current there valid point smallest there no valid manhattan distance between two points x y points all only valid have smallest manhattan distance your current distance smallest so x y points answer allowed same location your current x y points there no valid bi
check if word equals summation of two words letter value letter position alphabet starting numerical value some string lowercase english letters s concatenation letter values each letter which then converted into s we concatenate each letter resulting after converting we get three strings each consisting lowercase english letters through true summation numerical values firstword secondword equals numerical value or false firstword secondword targetword true numerical value firstword numerical value secondword numerical value targetword we true because firstword secondword targetword false numerical value firstword numerical value secondword numerical value targetword we false because firstword secondword targetword true numerical value firstword numerical value secondword numerical value targetword we true because targetword consist lowercase english letters
earliest possible day of full bloom have flower every seed must planted first before can begin then planting seed takes time so does growth two integer arrays planttime length full days takes plant ith every can work planting exactly one do not have work planting same seed consecutive but planting seed not complete until have worked days planting full days takes ith seed grow after being completely after last day flower blooms stays bloomed beginning day can plant seeds any earliest possible day where all seeds planttime growtime grayed out pots represent planting colored pots represent growing flower represents day one optimal way day plant seed grows full days blooms day days plant seed grows full days blooms day days plant seed grows full day blooms day day all seeds planttime growtime grayed out pots represent planting colored pots represent growing flower represents day one optimal way day plant seed grows full days blooms day days plant seed grows full day blooms day days plant seed grows full days blooms day days plant seed grows full day blooms day day all seeds planttime growtime day plant seed grows full day blooms day day all seeds
minimum number of steps to make two strings anagram ii two strings s one can append any character either s or minimum steps make s t anagrams each anagram string string contains same characters different s t we can append letters onto s forming s we can append letters onto t forming t now anagrams each we used total can shown there no way make them anagrams each other less than s t strings already anagrams each we do not need any further s t consist lowercase english
determine color of a chessboard square string represents coordinates square below chessboard your true square false square coordinate always represent valid chessboard coordinate always have letter coordinates false chessboard square coordinates so coordinates true chessboard square coordinates so coordinates false
count primes integer prime numbers strictly less than there prime numbers less than they
ways to split array into three subarrays split integer array good array split into three contiguous subarrays named right respectively left sum elements left less than or equal sum elements sum elements mid less than or equal sum elements array good ways split may too modulo nums only good way split nums nums there three good ways splitting nums there no good way split
burst balloons indexed each balloon painted represented array asked burst all burst ith get i or i goes out bounds then treat there balloon painted maximum coins can collect bursting balloons nums nums coins nums
kth smallest instructions bob standing cell wants reach can only travel right going help bob providing instructions him reach instructions represented where each character meaning move horizontally or meaning move vertically multiple instructions lead bob destination both valid bob very bob lucky wants kth lexicographically smallest instructions lead him k integer array destination integer kth lexicographically smallest instructions take bob destination k all instructions reach lexicographic order destination k destination k column k where denotes choose
get the maximum score two sorted arrays distinct integers valid path defined choose array or traverse traverse current array left reading any value present allowed change your path other one repeated value considered valid score defined sum uniques values valid maximum score can obtain all possible valid since answer may too modulo valid maximum obtained path green maximum sum obtained path there no common elements between maximum sum obtained path strictly
increasing triplet subsequence integer array true there exists triple indices such i j k no such indices nums true any triplet where i j k nums false no triplet nums true triplet valid because follow could implement solution runs time complexity space
construct quad tree matrix grid we want represent grid root representing tree data structure which each internal node exactly four each node two true node represents grid or false node represents grid notice can assign val true or false when isleaf both accepted true node leaf node tree or false node four class node public boolean public boolean public node public node public node public node we can construct area using following current grid same value all or all set isleaf true set val value grid set four children null current grid different set isleaf false set val any value divide current grid into four shown recurse each children proper want know more about can refer need read this section solving this only want understand output format output represents serialized format using level order where null signifies path terminator where no node exists very similar serialization binary only difference node represented list value isleaf or val true we represent list value isleaf or val false we represent grid explanation this shown notice represnts false represents true photo representing grid all values grid not we divide grid into four bottomleft bottomright each same topright have different values so we divide into where each same explanation shown photo where x
4sum array nums array all unique quadruplets such d d target may answer any nums target nums target target
multiply strings two integers represented product also represented must not use any biginteger library or convert inputs integer consist digits both do not contain any leading except
number of strings that appear as substrings in word array strings patterns string strings patterns exist substring substring contiguous sequence characters within patterns word appears substring appears substring appears substring does not appear substring strings patterns appear substring patterns word appears substring appears substring does not appear substring strings patterns appear substring patterns word each patterns appears substring word word consist lowercase english
minimum number of vertices to reach all nodes directed acyclic vertices numbered array edges where represents directed edge node fromi node find smallest set vertices which all nodes graph guaranteed unique solution notice can vertices any edges not possible reach all nodes single we can reach we can reach so we output edges notice vertices not reachable any other so we must include also any these vertices can reach nodes toi all pairs
find if path exists in graph there graph where each vertex labeled edges graph represented integer array where each denotes edge between vertex ui vertex every vertex pair connected most one no vertex edge want determine there valid path exists vertex source vertex edges integers true there valid path source or false edges source destination true there two paths vertex vertex edges source destination false there no path vertex vertex vi ui vi destination there no duplicate there no self
reordered power of 2 integer we reorder digits any order original such leading digit not true only we can do this so resulting power true false
lexicographically smallest string after applying operations string s even length consisting digits two integers can apply either following two operations any times any order add all odd indices s digits post cycled back s s becomes rotate s right b s b s becomes lexicographically smallest string can obtain applying above operations any times string lexicographically smaller than string b same first position where b string letter appears earlier alphabet than corresponding letter lexicographically smaller than because first position they differ third comes before s b we can apply following there no way obtain string lexicographically smaller then s b we can apply following there no way obtain string lexicographically smaller then s b there no sequence operations give us lexicographically smaller string than s consists digits b
count nodes with the highest score there binary tree rooted consisting nodes labeled integer array parents representing where parent node since node each node find score consider node edges connected tree would become one or more size subtree nodes score node product sizes all those nodes have highest parents score node score node score node score node score node highest score three nodes node node have highest parents score node score node score node highest score two nodes node have highest i parents represents valid binary
daily temperatures array integers temperatures represents daily array answer such days have wait after ith day get warmer there no future day which this keep temperatures temperatures temperatures
kids with the greatest number of candies there kids integer array where each represents candies ith kid integer denoting extra candies boolean array result length where true after giving ith kid all they have greatest candies among all or false note multiple kids can have greatest candies extracandies give all extracandies kid they have which greatest among kid they have which greatest among kid they have which greatest among kid they have which not greatest among kid they have which greatest among candies extracandies there only extra kid always have greatest even different kid extra candies extracandies extracandies
data stream as disjoint intervals data stream input integers summarize numbers seen so far list disjoint implement summaryranges initializes object empty void adds integer value returns summary integers stream currently list disjoint intervals answer should sorted input output explanation summaryranges summaryranges new arr arr arr arr arr value most calls made addnum most calls made follow what there lots merges disjoint intervals small compared size data
calculate amount paid in taxes integer array brackets where means ith tax bracket upper bound upperi taxed rate brackets sorted upper bound upperi i tax calculated first dollars earned taxed rate next dollars earned taxed rate next dollars earned taxed rate so integer income representing amount money amount money have pay answers within actual answer brackets income based your have dollars tax dollars tax dollars tax tax rate three tax brackets pay brackets income based your have dollar tax bracket dollar tax tax rate two tax brackets pay brackets income have no income so have pay total upperi percenti income upperi sorted ascending all values upperi upper bound last tax bracket greater than or equal
minimum moves to convert string string s consisting characters which either or move defined selecting three consecutive characters s converting them note move applied character stay minimum moves required so all characters s converted s xxx ooo we select all characters convert them one s xxox ooox oooo we select first characters first convert them then we select last characters convert them so final string contains all s there no s either or
count ways to build good strings integers we can construct string starting empty then each step perform either append character zero append character one this can performed any good string string constructed above process having length between low high different good strings can constructed satisfying these since answer can modulo low high zero one one possible valid good string can constructed all binary strings good strings this low high zero one good strings low high one low
minimum addition to make integer beautiful two positive integers integer considered beautiful sum digits less than or equal minimum integer x such x input generated such always possible make target initially digit sum after adding becomes digit sum becomes can shown we can not make beautiful adding integer less than target initially digit sum after adding becomes digit sum becomes can shown we can not make beautiful adding integer less than target initially digit sum which already smaller than or equal target input generated such always possible make
rectangle area coordinates two rectilinear rectangles total area covered two first rectangle defined corner corner second rectangle defined corner corner
duplicate zeros integer array duplicate each occurrence shifting remaining elements note elements beyond length original array not do above modifications input array place do not arr after calling your input array modified arr after calling your input array modified
number of paths with max score square board can move board starting bottom right square marked character need reach top left square marked character rest squares labeled either numeric character or obstacle one move can go left or only there no obstacle list two first integer maximum sum numeric characters can second such paths can take get maximum taken modulo case there no board board board
employees whose manager left the company sql schema employees column name type int name varchar int salary int primary key this this table contains information about their id their some employees do not have manager write sql query report ids employees whose salary strictly less than whose manager left when manager leaves their information deleted employees but reports still have their set manager result table ordered query result format following employees name salary mila antonella null emery null kalel mikaela null joziah employees salary less than manager employee who still company manager employee who left company because there no row employee
print binary tree root binary construct m x string matrix res represents formatted layout formatted layout matrix should constructed using following height tree height rows m should equal height columns should equal place root node middle top row location each node been placed matrix position place left child right child continue this process until all nodes tree have been any empty cells should contain empty string constructed matrix root root nodes tree range depth tree range
number of ways to reconstruct a tree array where there no xi yi let ways rooted trees satisfy following tree consists nodes whose values appeared pair exists pairs only xi ancestor yi or yi ancestor tree does not have binary two ways considered different there least one node different parents both ways ways ways rooted tree tree single root all edges oriented outgoing ancestor node any node path root node node root no pairs there exactly one valid rooted which shown above pairs there multiple valid rooted three them shown above pairs there no valid rooted xi yi elements pairs
sort integers by the number of 1 bits integer array sort integers array ascending order their binary representation case two or more integers have same have sort them ascending array after sorting arr only integer all have have sorted array bits arr all integers have bit binary should just sort them ascending
maximum bags with full capacity of rocks have bags numbered two integer arrays capacity ith bag can hold maximum rocks currently contains also integer additional rocks can place any maximum bags could have full capacity after placing additional rocks some capacity rocks additionalrocks place rock bag rock bag rocks each bag now bags have full there bags full so we can shown not possible have more than bags full note there may other ways placing rocks result answer capacity rocks additionalrocks place rocks bag rocks bag rocks each bag now bags have full there bags full so we can shown not possible have more than bags full note we did not use all additional additionalrocks
longest chunked palindrome decomposition string should split k substrings such subtexti concatenation all substrings equal text subtextk subtexti subtextk i all valid values i i largest possible value text we can split string text we can split string text we can split string text consists only lowercase english
smallest subarrays with maximum bitwise or array nums length consisting each index i must determine size minimum sized subarray nums starting i maximum possible bitwise other let bij bitwise or subarray need find smallest subarray starting such bitwise or this subarray equal where i k bitwise or array bitwise or all numbers integer array answer size where length minimum sized subarray starting i maximum bitwise subarray contiguous sequence elements within nums maximum possible bitwise or starting any index starting index shortest subarray yields starting index shortest subarray yields maximum bitwise or starting index shortest subarray yields maximum bitwise or starting index shortest subarray yields maximum bitwise or starting index shortest subarray yields maximum bitwise or we nums starting index shortest subarray yields maximum bitwise or length starting index shortest subarray yields maximum bitwise or length we
minimize malware spread ii network nodes represented x adjacency matrix where ith node directly connected jth node some nodes initial initially infected whenever two nodes directly least one those two nodes infected both nodes infected this spread malware continue until no more nodes can infected this suppose final nodes infected malware entire network after spread malware we remove exactly one node completely removing any connections this node any other node would minimize multiple nodes could removed minimize such node smallest graph initial graph initial graph initial or all integers initial
largest 1-bordered square grid elements largest square subgrid all or such subgrid exist grid grid or
plates between candles there long table line plates candles arranged top string s consisting characters where represents plate represents also integer array queries where denotes substring each need find plates between candles plate considered between candles there least one candle left least one candle right s query denotes substring plates between candles this substring each two plates least one candle substring left integer array answer where answer ith s queries two plates between three plates between s queries nine plates between other queries have zero plates between s consists lefti righti
minimum number of days to make m bouquets integer array integer m integer want make m make need use k adjacent flowers garden consists ith flower bloom then can used exactly one minimum days need wait able make m bouquets impossible make m bouquets bloomday m k let us see what happened first three x means flower bloomed means flower did not bloom we need bouquets each should contain after day we can only make one after day we can only make two after day we can make answer bloomday m k we need bouquets each means we need we only have flowers so impossible get needed bouquets we bloomday m k we need bouquets each should have here garden after after day we can make one bouquet first three flowers we cannot make another bouquet last three flowers bloomed because they not after day obvious we can make two bouquets different m k
champagne tower we stack glasses where first row second row so until each glass holds one cup some champagne poured into first glass when topmost glass any excess liquid poured fall equally glass immediately left right when those glasses become any excess champagne fall equally left right those so glass bottom row excess champagne fall after one cup champagne top most glass after two cups champagne two glasses second row half after three cups champagne those two cups become full there full glasses total after four cups champagne third row middle glass half two outside glasses quarter pictured now after pouring some integer cups how full jth glass ith row i j poured we poured cup champange top glass tower indexed there no excess liquid so all glasses under top glass remain poured we poured cups champange top glass tower indexed there one cup excess glass indexed glass indexed share excess liquid each get half cup poured poured
reconstruct itinerary list airline tickets where represent departure arrival airports one reconstruct itinerary order all tickets belong man who departs itinerary must begin there multiple valid should itinerary smallest lexical order when read single itinerary smaller lexical order than may assume all tickets form least one valid must use all tickets once only tickets tickets another possible reconstruction but larger lexical fromi toi consist uppercase english fromi toi
number of students unable to eat lunch school cafeteria offers circular square sandwiches lunch referred numbers all students stand each student either prefers square or circular sandwiches cafeteria equal sandwiches placed each student front queue prefers sandwich top they take leave they leave go this continues until none queue students want take top sandwich thus unable two integer arrays students sandwiches where type ith sandwich stack top preference jth student initial queue front students unable students sandwiches front student leaves top sandwich returns end line making students front student leaves top sandwich returns end line making students front student takes top sandwich leaves line making students sandwiches front student leaves top sandwich returns end line making students front student takes top sandwich leaves line making students sandwiches front student leaves top sandwich returns end line making students front student takes top sandwich leaves line making students sandwiches front student takes top sandwich leaves line making students sandwiches hence all students able students sandwiches or or
best time to buy and sell stock iii array prices where price stock ith find maximum profit can may complete most two may not engage multiple transactions simultaneously must sell stock before buy prices buy day sell day profit then buy day sell day profit prices buy day sell day profit note cannot buy day buy day sell them engaging multiple transactions same must sell before buying prices this no transaction max profit
count total number of colored cells there exists infinitely large grid uncolored unit positive integer indicating must do following routine first color any arbitrary unit cell every minute color blue every uncolored cell touches blue below pictorial representation state grid after minutes colored cells end after there only blue so we after there colored cells boundary so we
remove duplicates from sorted array ii integer array nums sorted remove some duplicates such each unique element appears most relative order elements should kept since impossible change length array some must instead have result placed first part array more there k elements after removing then first k elements nums should hold final does not matter what leave beyond first k k after placing final result first k slots do not allocate extra space another must do this modifying input array extra custom judge test your solution following nums input array expectednums expected answer correct length int k calls your implementation assert k i i assert all assertions then your solution nums nums your function should k first five elements nums being does not matter what leave beyond returned k they nums nums your function should k first seven elements nums being does not matter what leave beyond returned k they nums sorted
maximize number of subsequences in a string string text another string pattern length both which consist only lowercase english can add either or anywhere text exactly note character can added even beginning or end maximum times pattern can occur subsequence modified subsequence string can derived another string deleting some or no characters without changing order remaining text pattern we add between we get times occurs subsequence some other strings which have subsequences after adding character text strings such although have only subsequences thus can shown not possible get more than subsequences adding only one text pattern some strings which can obtained text have subsequences text pattern consist only lowercase english
best time to buy and sell stock with cooldown array prices where price stock ith find maximum profit can may complete many transactions like buy one sell one share stock multiple following after sell your cannot buy stock next day cooldown one may not engage multiple transactions simultaneously must sell stock before buy prices transactions prices
path crossing string where or each representing moving one unit or start origin plane walk path specified true path crosses itself any any time location have previously false path false notice path cross any point more than path true notice path visits origin either or
promise time limit asynchronous function fn time t new time limited version input fn takes arguments provided time limited time limited function should follow these fn completes within time limit t time limited function should resolve execution fn exceeds time time limited function should reject string limit fn async await new inputs t limit const limited const start let try const res await result catch result output provided function set resolve after time limit set rejects because time limit fn async await new inputs t function resolved time limit never fn async await new inputs t function resolved time limit never fn async throw inputs t function immediately throws t fn returns promise
delete the middle node of a linked list head linked delete middle head modified linked middle node linked list size node start using where denotes largest integer less than or equal middle nodes head above figure represents linked indices nodes written since node value middle which marked we new list after removing this head above figure represents linked node value middle which marked head above figure represents linked node value middle which marked node value only node remaining after removing node nodes list range
divide array into equal pairs integer array nums consisting need divide nums into pairs such each element belongs exactly one elements present pair true nums can divided into otherwise nums true there elements so they should divided into nums divided into pairs satisfy all nums false there no way divide nums into pairs such pairs satisfy every
valid tic-tac-toe state board string array true only possible reach this board position during course valid board x array consists characters character represents empty here rules players take turns placing characters into empty squares first player always places while second player always places characters always placed into empty never filled game ends when there three same character filling any or game also ends all squares no more moves can played game board false first player always plays board x false players take turns making board true either or
task scheduler ii array positive integers representing tasks need completed where represents type ith also positive integer which represents minimum days must pass after completion task before another task same type can each until all tasks have been must complete next task or take minimum days needed complete all tasks space one way complete all tasks days day complete day complete day take day take day complete day complete day take day complete day complete can shown tasks cannot completed less than tasks space one way complete all tasks days day complete day complete day take day take day complete day complete can shown tasks cannot completed less than space
maximum points in an archery competition alice bob opponents archery competition set following alice first shoots numarrows arrows then bob shoots numarrows points then calculated target integer scoring sections ranging each section target score k between say alice bob have shot ak bk arrows section ak then alice takes k ak then bob takes k ak bk then nobody takes k alice bob both shot arrows section score then alice takes other alice shot arrows section score bob shot arrows same then bob takes integer numarrows integer array alicearrows size which represents arrows alice shot each scoring section bob wants maximize total points can array bobarrows which represents arrows bob shot each scoring section sum values bobarrows should equal there multiple ways bob earn maximum total any one numarrows alicearrows table above shows how competition bob earns total point can shown bob cannot obtain score higher than numarrows alicearrows table above shows how competition bob earns total point can shown bob cannot obtain score higher than numarrows numarrows numarrows
shortest path visiting all nodes have connected graph nodes labeled array graph where list all nodes connected node i length shortest path visits every may start stop any may revisit nodes multiple may reuse graph one possible path graph one possible path does not contain contains then contains input graph always
search suggestions system array strings products string design system suggests most three product names products after each character searchword suggested products should have common prefix there more than three products common prefix three lexicographically minimums list lists suggested products after each character searchword products searchword products sorted lexicographically after typing m mo all products match we show user after typing mous mouse system suggests products searchword only word always suggested while typing search all strings products consists lowercase english searchword consists lowercase english
optimal division integer array adjacent integers nums perform float nums we evaluate expression can add any parenthesis any position change priority want add these parentheses such value expression after evaluation corresponding expression maximum value string your expression should not contain redundant nums bold parenthesis redundant since they do not influence operation so should other nums can shown after trying all we cannot get expression evaluation greater than there only one optimal division
find all good indices integer array nums size positive integer we call index i range k i k good following conditions k elements just before index i k elements just after index i array all good indices sorted increasing nums k there two good indices index subarray subarray index subarray subarray note index not good because not nums k there no good indices this k
count all valid pickup and delivery options each order consist pickup delivery count all valid possible sequences such always after since answer may too modulo unique order delivery always after pickup all possible this invalid order because pickup after delivery
minimum obstacle removal to reach corner integer array grid size m x each cell one two represents empty represents obstacle may can move or right empty minimum obstacles remove so can move upper left corner lower right corner grid we can remove obstacles create path can shown we need remove least so we note there may other ways remove obstacles create grid we can move without removing any so we m m either or
find three consecutive integers that sum to a given number integer three consecutive integers sorted sum num cannot expressed sum three consecutive empty num can expressed consecutive so we num there no way express sum consecutive num
total hamming distance hamming distance between two integers positions which corresponding bits integer array sum hamming distances between all pairs integers nums binary showing four bits relevant this answer nums answer input fit
range sum query - mutable integer array handle multiple queries following update value element calculate sum elements nums between indices left right inclusive where left implement numarray initializes object integer array void int updates value int int returns sum elements nums between indices left right inclusive input output explanation numarray numarray new nums index val left right most calls made update
01 matrix m x binary matrix distance nearest each distance between two adjacent cells mat mat m m either or there least one
sum of subsequence widths width sequence difference between maximum minimum elements array integers sum widths all subsequences since answer may very modulo subsequence sequence can derived array deleting some or no elements without changing order remaining subsequence array nums subsequences corresponding widths sum these widths nums
k-similar strings strings some integer we can swap positions two letters exactly k times so resulting string equals two anagrams smallest k which two string because we can use one swap change two strings because we can use two swaps change contain only lowercase letters set anagram
max area of island m x binary matrix island group connected or may assume all four edges grid surrounded area island cells value maximum area island there no grid answer not because island must connected grid m either or
zuma game playing variation game this variation there single row colored balls where each ball can colored red yellow blue green or white also have several colored balls your your goal clear all balls each pick any ball your hand insert between two balls row or either end there group three or more consecutive balls same remove group balls this removal causes more groups three or more same color then continue removing each group until there none there no more balls then win repeat this process until either win or do not have any more balls your string representing row balls string representing balls your minimum balls have insert clear all balls cannot clear all balls board using balls your board hand impossible clear all best can do insert so board becomes wrrrbbw insert so board becomes wbbbw there still balls remaining out balls board hand make board insert so board becomes wwrrrbbww insert so board becomes wwbbbww wwww balls your hand needed clear board hand make board insert so board becomes insert so board becomes ggg balls your hand needed clear board hand consist characters initial row balls board not have any groups three or more consecutive balls same
replace the substring for balanced string string s length containing only four kinds string said balanced each characters appears times where length minimum length substring can replaced any other string same length make s s already s s already s we need replace so s we can replace first multiple s contains only
24 game integer array cards length have four each containing range should arrange numbers these cards mathematical expression using operators parentheses get value restricted following division operator represents real not integer every operation done between two we cannot use unary cards expression not cannot concatenate numbers together cards expression not true can get such expression evaluates false cards true cards false
how many numbers are smaller than the current number array each find out how many numbers array smaller than each have count valid such j i answer nums there exist four smaller numbers than does not exist any smaller than there exist one smaller than there exist one smaller than there exist three smaller numbers than nums nums
single number array integers every element appears twice except find single must implement solution linear runtime complexity use only constant extra nums nums nums each element array appears twice except one element which appears only
process restricted friend requests integer indicating people each person labeled also integer array where means person xi person yi cannot become either directly or indirectly through other no one friends each list friend requests integer array where friend request between person uj person friend request successful uj vj can each friend request processed order occurs before upon successful uj vj become direct friends all future friend boolean array where each true jth friend request successful or false uj vj already direct request still restrictions requests request person person can so they become direct request person person cannot friends since person person would indirect friends restrictions requests request person person can so they become direct request person person cannot friends since person person would indirect friends restrictions requests request person person can so they become direct request person person cannot friends since they directly request person person can so they become direct request person person cannot friends since person person would indirect friends yi xi yi vj uj vj
find duplicate subtrees root binary all duplicate each kind duplicate only need root node any one two trees duplicate they have same structure same node root root root nodes tree range
min max game integer array nums whose length power apply following algorithm let length end create new integer array newnums length every even index i where i assign value i every odd index i where i assign value i replace array nums repeat entire process starting step last remains nums after applying nums following arrays results applying algorithm nums nums nums last remaining so we nums already last remaining so we power
check if it is a good array array nums positive your task select some subset multiply each element integer add all these array said good can obtain sum array any possible subset true array good otherwise nums true pick numbers nums true pick numbers nums false
clumsy factorial factorial positive integer product all positive integers less than or equal we make clumsy factorial using integers decreasing order swapping out multiply operations fixed rotation operations multiply divide add subtract this these operations still applied using usual order operations we do all multiplication division steps before any addition or subtraction multiplication division steps processed left division we use floor division such integer clumsy factorial
count number of possible root nodes alice undirected tree nodes labeled tree represented integer array edges length where indicates there edge between nodes ai bi alice wants bob find root she allows bob make several guesses about her one does chooses two distinct integers u v such there exists edge tells alice u parent v guesses represented integer array guesses where indicates bob guessed uj parent alice being does not reply each but just says least k his guesses integer arrays guesses integer possible nodes can root there no such edges guesses k root correct guesses root correct guesses root correct guesses root correct guesses root correct guesses considering or root node leads correct edges guesses k root correct guesses root correct guesses root correct guesses root correct guesses root correct guesses considering any node root give least correct vj ai bi uj vj edges represents valid edge guesses k
create maximum number two integer arrays lengths m represent digits two also integer create maximum length k m digits two relative order digits same array must array k digits representing k k k m k m
pairs of songs with total durations divisible by 60 list songs where ith song duration pairs songs which their total duration seconds divisible we want indices j such i j time three pairs have total duration divisible total duration total duration total duration time all three pairs have total duration which divisible
increasing decreasing string string reorder string using following pick smallest character s append pick smallest character s which greater than last appended character result append repeat step until cannot pick more pick largest character s append pick largest character s which smaller than last appended character result append repeat step until cannot pick more repeat steps until pick all characters each smallest or largest character appears more than once can choose any occurrence append result string after sorting s this s after steps first result after steps first result first iteration now s we go back step after steps second result after steps second result s word becomes after mentioned s consists only lowercase english
find substring with given hash value hash string s length integers p computed using following mod where represents index alphabet string s integers first substring s length k such test cases generated such answer always substring contiguous sequence characters within s power modulo k hashvalue hash can computed mod mod first substring length hashvalue we s power modulo k hashvalue hash can computed mod mod hash can computed mod mod first substring length hashvalue we note also hash but appears later than k modulo hashvalue modulo s consists lowercase english letters test cases generated such answer always
game play analysis iv sql schema activity column name type int int date int primary key this this table shows activity players some each row record player who logged played games before logging out someday using some write sql query report fraction players logged again day after day they first logged rounded decimal other need count players logged least two consecutive days starting their first login then divide total query result format following activity fraction only player id logged back after first day had logged so answer
decrease elements to make array zigzag array nums move consists choosing any element decreasing array zigzag array every element greater than adjacent every element greater than adjacent minimum moves transform array nums into zigzag nums we can decrease or nums
the latest login in 2020 sql schema logins column name type int datetime primary key this each row contains information about login time user id write sql query report latest login all users year do not include users who did not login result table any query result format following logins user logged into their account times but only once so we include this login result user logged into their account times once february once we include only latest one result user logged into their account times but only once so we include this login result user did not login so we do not include them result
count vowel strings in ranges array strings words array integers each query asks us find strings present range li ri words start end array ans size where answer ith note vowel letters words queries strings starting ending vowel answer query query query we words queries every string satisfies so we consists only lowercase english li ri
find the maximum divisibility score two integer arrays nums divisibility score indices j such divisible integer maximum divisibility there more than one integer maximum minimum nums divisors divisibility score every element divisors divisibility score since no nums divisible divisibility score since divisible divisibility score since divisible since maximum divisibility we nums divisors divisibility score every element divisors divisibility score since divisible divisibility score since divisible divisibility score since divisible since all have maximum divisibility we minimum them nums divisors divisibility score every element divisors divisibility score since no nums divisible divisibility score since no nums divisible since both have maximum divisibility we minimum them
minesweeper play minesweeper game online m x char matrix board representing game board represents unrevealed represents unrevealed empty represents revealed blank square no adjacent mines all digit represents how many mines adjacent this revealed represents revealed also integer array click where click represents next click position among all unrevealed squares or board after revealing this position according following mine then game should change empty square no adjacent mines then change revealed blank all adjacent unrevealed squares should revealed empty square least one adjacent mine then change digit representing adjacent board when no more squares board click board click m either or digit clickr m clickc either or
camelcase matching array strings queries string boolean array answer where true matches false query word matches pattern can insert lowercase english letters pattern so equals may insert each character any position may not insert any queries pattern can generated like this can generated like this can generated like this queries pattern can generated like this can generated like this queries pattern can generated like this pattern consist english
number of sub-arrays of size k and average greater than or equal to threshold array integers arr two integers k size k average greater than or equal arr k threshold have averages all other size have averages less than arr k threshold first size have averages greater than note averages not k threshold
minimum cost to set cooking time generic microwave supports cooking times least most minutes set cooking push most four microwave normalizes what push four digits prepending interprets first two digits minutes last two digits then adds them up cooking push normalized interpreted minutes push interpreted minutes push interpreted minutes push interpreted minutes integers your finger digit moving finger above any specific digit costs movecost units pushing digit below finger once costs pushcost units there can multiple ways set microwave cook targetseconds seconds but interested way minimum minimum cost set targetseconds seconds cooking remember one minute consists startat movecost pushcost targetseconds following possible ways set cooking interpreted minutes finger already digit pushes cost moves cost pushes cost pushes cost pushes cost cost this minimum interpreted minutes also finger moves cost pushes cost moves cost pushes cost moves cost pushes cost moves cost pushes cost cost normalized interpreted minutes finger moves cost pushes cost moves cost pushes cost moves cost pushes cost cost startat movecost pushcost targetseconds optimal way push two interpreted finger moves cost pushes cost moves cost pushes cost total cost note other possible ways but none them produces minimum startat pushcost targetseconds
pascal's triangle ii integer rowindexth row each sum two numbers directly above rowindex rowindex rowindex rowindex follow could optimize your algorithm use only extra
number of ways to form a target string given a dictionary list strings same length words string your task form target using words under following target should formed left form ith character can choose kth character jth string words once use kth character jth string can no longer use xth character any string words where x other all characters left or index k become unusuable every repeat process until form string notice can use multiple characters same string words provided conditions above ways form target since answer may too modulo words target there ways form index index index index index index index index index index index index index index index index index index words target there ways form index index index index index index index index index index index index all strings words have same target contain only lowercase english
find closest number to zero integer array nums size value closest there multiple largest nums distance distance distance distance distance closest array nums both closest numbers so being larger
palindrome partitioning iv string true possible split string s into three palindromic string said palindrome same string when s true all three substrings s false s cannot split into s consists only lowercase english
all divisions with the highest score of a binary array binary array nums length nums can divided index i i into two arrays numsleft numsleft all elements nums between index i while numsright all elements nums between index i i numsleft while numsright all elements i numsleft all elements while numsright division score index i sum numsleft all distinct indices have highest possible division may answer any nums division index numsleft numsright score numsleft numsright score numsleft numsright score numsleft numsright score numsleft numsright score indices both have highest possible division score note answer would also nums division index numsleft numsright score numsleft numsright score numsleft numsright score numsleft numsright score only index highest possible division score nums division index numsleft numsright score numsleft numsright score numsleft numsright score only index highest possible division score either or
gcd sort of an array integer array can perform following operation any times swap positions two elements where greatest common divisor true possible sort nums order using above swap or false nums true we can sort performing following swap because nums swap because nums nums false impossible sort array because cannot swapped any other nums true we can sort performing following swap because nums swap because nums swap because nums
serialize and deserialize bst serialization converting data structure or object into sequence bits so can stored file or memory or transmitted across network connection link reconstructed later same or another computer design algorithm serialize deserialize binary search there no restriction how your algorithm should need ensure binary search tree can serialized this string can deserialized original tree encoded string should compact root root nodes tree range input tree guaranteed binary search
h-index array integers citations where citations researcher received their ith according definition defined maximum value h such researcher published least h papers have each been cited least h citations means researcher papers total each them had received citations since researcher papers least citations each remaining two no more than citations their citations
article views i sql schema views column name type int int int date there no primary key this may have duplicate each row this table indicates some viewer viewed article some some note equal indicate same write sql query find all authors viewed least one their own result table sorted id ascending query result format following views id
array nesting integer array nums length where nums permutation numbers range should build set subjected following first element starts selection element index next element should then so we stop adding right before duplicate element occurs longest length set nums one longest sets nums all values nums
largest magic square k x k magic square k x k grid filled integers such every row every column both diagonal sums all integers magic square do not have every x grid trivially magic m x integer size side length largest magic square can found within this grid largest magic square size every row column diagonal sum this magic square equal row column diagonal grid m
bitwise and of numbers range two integers left right represent range bitwise all numbers this left right left right left right left right
query kth smallest trimmed number array strings where each string equal length consists only also integer array queries where each need trim each nums rightmost trimi determine index kith smallest trimmed two trimmed numbers lower index considered reset each nums original array answer same length where answer ith trim rightmost x digits means keep removing leftmost until only x digits strings nums may contain leading nums queries after trimming last nums smallest index trimmed last nums smallest index trimmed last nums smallest trimmed last smallest index note trimmed evaluated nums queries trimmed last nums smallest index there two occurrences but one index considered smaller than one index trimmed last nums smallest consists only all ki trimi follow could use radix sort algorithm solve this what complexity
maximum candies allocated to k children integer array each element array denotes pile candies size can divide each pile into any sub but cannot merge two piles also integer should allocate piles candies k children such each child gets same each child can take most one pile candies some piles candies may go maximum candies each child can candies k we can divide into piles size into piles size we now have five piles candies sizes we can allocate piles size can proven each child cannot receive more than candies k there children but only candies so impossible ensure each child receives least one each child gets no candy answer k
erect the fence array trees where represents location tree fence entire garden using minimum length garden only all trees coordinates trees exactly located fence may answer any trees all trees perimeter fence except tree which inside trees fence forms line passes through all yi all positions
minimum penalty for a shop customer visit log shop represented string customers consisting only characters ith character means customers come ith hour whereas indicates no customers come ith shop closes jth hour j penalty calculated every hour when shop open no customers penalty increases every hour when shop closed customers penalty increases earliest hour which shop must closed incur minimum note shop closes jth means shop closed hour customers closing shop hour incurs closing shop hour incurs closing shop hour incurs closing shop hour incurs closing shop hour incurs closing shop or hour gives minimum since optimal closing time customers best close shop hour no customers customers best close shop hour customers arrive each customers consists only characters
flipping an image x binary matrix flip image then invert resulting flip image horizontally means each row image flipping horizontally results invert image means each replaced each replaced inverting results image first reverse each invert image first reverse each then invert either or
my calendar i implementing program use your we can add new event adding event not cause double double booking happens when two events have some intersection some moment common both event can represented pair integers start end represents booking interval range real numbers x such start x implement mycalendar initializes calendar boolean int returns true event can added calendar successfully without causing double false do not add event input output explanation mycalendar mycalendar new true can not booked because time already booked another event can first event takes every time less than but not including start end most calls made
regular expression matching input string s pattern implement regular expression matching support matches any single matches zero or more preceding matching should cover entire input string s p false does not match entire string s p true means zero or more preceding repeating becomes s p true means or more any character s contains only lowercase english p contains only lowercase english guaranteed each appearance character there previous valid character
interval list intersections two lists closed firstlist where each list intervals pairwise disjoint sorted intersection these two interval closed interval denotes set real numbers x x intersection two closed intervals set real numbers either empty or represented closed intersection firstlist secondlist firstlist secondlist starti endi endi startj endj endj
sum of beauty in the array integer array each index i i beauty all j i all i k previous condition not none previous conditions sum beauty all where i nums each index i range i beauty equals nums each index i range i beauty equals beauty equals nums each index i range i beauty equals
find kth bit in nth binary string two positive integers binary string sn formed si si i where denotes concatenation returns reversed string inverts all bits x changes changes first four strings above sequence kth bit guaranteed k valid k bit k bit k
number of beautiful partitions string s consists digits two integers k partition s called beautiful s partitioned into k each substring length least each substring starts prime digit ends prime digits rest digits beautiful partitions since answer may very modulo substring contiguous sequence characters within s k minlength there exists three ways create beautiful s k minlength there exists one way create beautiful s k minlength there exists one way create beautiful minlength s consists digits
check completeness of a binary tree root binary determine complete binary complete binary every except possibly completely all nodes last level far left can have between nodes inclusive last level root true every level before last full levels all nodes last level far left root false node value far left nodes tree range
split array into consecutive subsequences integer array nums sorted determine possible split nums into one or more subsequences such both following conditions each subsequence consecutive increasing sequence each integer exactly one more than previous all subsequences have length or true can split nums according above or false subsequence array new array formed original array deleting some elements without disturbing relative positions remaining subsequence while nums true nums can split into following nums true nums can split into following nums false impossible split nums into consecutive increasing subsequences length or nums sorted
difference between ones and zeros in row and column m x binary matrix m x difference matrix diff created following let ones ith row let ones jth column let zeros ith row let zeros jth column onesrowi onescolj zerosrowi zeroscolj difference matrix grid grid m m either or
minimum incompatibility integer array nums integer asked distribute this array into k subsets equal size such there no two equal elements same incompatibility difference between maximum minimum elements minimum possible sum incompatibilities k subsets after distributing array or not subset group integers appear array no particular nums k optimal distribution subsets incompatibility note would result smaller but first subset contains equal nums k optimal distribution subsets incompatibility nums k impossible distribute nums into subsets where no two elements equal same k divisible k
available captures for rook x there exactly one white rook some white bishops black pawns empty squares when rook chooses one four cardinal directions or then moves direction until chooses reaches edge captures black or blocked white rook considered attacking pawn rook can capture pawn available captures white rook pawns rook available captures white board this rook attacking all board bishops blocking rook attacking any board rook attacking pawns positions either or there exactly one cell
tiling a rectangle with the fewest squares rectangle size x minimum squares tile m squares necessary cover m m m
find words that can be formed by characters array strings words string string good can formed characters chars character can only used sum lengths all good strings words chars strings can formed so answer words chars strings can formed so answer chars consist lowercase english
minimum cost homecoming of a robot in a grid there m x where cell integer array startpos where startpos indicates robot cell also integer array homepos where homepos indicates home cell robot needs go can move one cell four or can not move outside every move incurs some further two integer rowcosts length m colcosts length robot moves up or down into cell whose row then this move costs robot moves left or right into cell whose column then this move costs minimum total cost this robot startpos homepos rowcosts colcosts one optimal path starting goes down this move costs goes right this move costs goes right this move costs goes right this move costs total cost startpos homepos rowcosts colcosts robot already since no moves total cost m homerow m homecol
recyclable and low fat products sql schema products column name type int enum recyclable enum primary key this enum type where means this product low fat means recyclable enum types where means this product recyclable means write sql query find ids products both low fat result table any query result format following products recyclable y y y y y y only products both low fat
count items matching a rule array where each describes name ith also rule represented two rulekey ith item said match rule one following rulekey rulevalue rulekey rulevalue rulekey rulevalue items match items rulekey rulevalue there only one item matching which items rulekey rulevalue there only two items matching which note item does not rulekey equal either or all strings consist only lowercase
maximum number of points with cost m x integer matrix points starting want maximize points can get gain must pick one cell each picking cell coordinates add your lose points pick cell too far cell picked previous every two adjacent rows r r r m picking cells coordinates subtract your maximum points can defined x x x points blue cells denote optimal cells which have coordinates add your must subtract your your final score points blue cells denote optimal cells which have coordinates add your must subtract your your final score m m
kth largest element in an array integer array nums integer kth largest element note kth largest element sorted not kth distinct must solve time nums k nums k k
count number of texts alice texting bob using her mapping digits letters shown figure order add alice press key corresponding digit i where i position letter add letter alice press four add letter alice press note digits do not map any so alice does not use due error bob did not receive text message but received string pressed keys when alice sent message bob received string string pressedkeys representing string received total possible text messages alice could have since answer may very modulo pressedkeys possible text messages alice could have sent since there possible we pressedkeys there possible text messages alice could have since we need answer modulo we pressedkeys only consists digits
longest consecutive sequence unsorted array integers length longest consecutive elements must write algorithm runs nums longest consecutive elements sequence therefore length nums
minimize the difference between target and chosen elements m x integer matrix mat integer choose one integer each row matrix such absolute difference between target sum chosen elements minimum absolute absolute difference between two numbers b absolute value mat target one possible choice choose first choose second choose third sum chosen elements which equals so absolute difference mat target best possible choice choose first choose second choose third sum chosen elements absolute difference mat target best choice choose first absolute difference m target
minimum moves to reach target with rotations there snake spans cells starts moving top left corner grid empty cells represented zeros blocked cells represented snake wants reach lower right corner one move snake move one cell right there no blocked cells this move keeps position snake move down one cell there no blocked cells this move keeps position snake rotate clockwise horizontal position two cells under both case snake moves rotate counterclockwise vertical position two cells right both case snake moves minimum moves reach there no way reach grid one possible solution rotate rotate grid guaranteed snake starts empty
number of flowers in full bloom integer array where means ith flower full bloom starti endi also integer array people size where time ith person arrive see integer array answer size where flowers full bloom when ith person flowers poeple figure above shows times when flowers full bloom when people each we flowers full bloom during their flowers poeple figure above shows times when flowers full bloom when people each we flowers full bloom during their starti endi
chunk array array arr chunk size chunked chunked array contains original elements but consists subarrays each length length last subarray may less than size not evenly divisible may assume array output other valid please solve without using arr size arr been split into subarrays each arr size arr been split into subarrays only two elements left arr size size greater than thus all elements first arr size there no elements chunked so empty array arr valid json array size
sum root to leaf numbers root binary tree containing digits each path tree represents path represents total sum all test cases generated so answer fit leaf node node no root path represents path represents sum root path represents path represents path represents sum nodes tree range depth tree not exceed
three equal parts array arr which consists only zeros divide array into three parts such all these parts represent same binary any i such first second third all three parts have equal binary not note entire part used when considering what binary value represents not leading zeros so represent same arr arr arr or
generate random point in a circle radius position center implement function randpoint which generates uniform random point inside implement solution double double initializes object radius circle radius position center returns random point inside point circumference circle considered answer returned array input output explanation solution solution new radius most calls made
loud and rich there group people labeled where each person different amount money different level array richer where indicates ai more money than bi integer array quiet where quietness ith all data richer logically correct data not lead situation where x richer than y y richer than x same integer array answer where y y least quiet person person y smallest value among all people who definitely have equal or more money than person richer quiet person more money than which more money than which more money than only person who quieter lower person but not clear they have more money than person among all people definitely have equal or more money than person could persons or person who quietest lower person other answers can filled out similar richer quiet all values quiet bi ai bi all pairs richer observations richer all logically
number of ways to reach a position after exactly k steps two positive integers startpos standing position startpos infinite one can move either one position or one position positive integer different ways reach position endpos starting such perform exactly k since answer may very modulo two ways considered different order steps made not exactly note line includes negative startpos endpos k we can reach position exactly steps three can proven no other way so we startpos endpos k impossible reach position position exactly k
maximum nesting depth of the parentheses string valid parentheses string meets one empty string or single character not equal or can written ab concatenated where b or can written where we can similarly define nesting depth any vps s where c string single character not equal or where b where nesting depths not vps represented string nesting depth s digit inside nested parentheses s s consists digits characters guaranteed parentheses expression s
find all numbers disappeared in an array array nums integers where range array all integers range do not appear nums nums follow could do without extra space may assume returned list does not count extra
beautiful array array nums length beautiful nums permutation integers range every i j there no index k i k j where integer any beautiful array nums length there least one valid answer
remove linked list elements head linked list integer remove all nodes linked list new head val head val head val nodes list range val
flip columns for maximum number of equal rows m x binary matrix can choose any columns matrix flip every cell column change value cell or vice maximum rows have all values equal after some matrix after flipping no row all values matrix after flipping values first both rows have equal matrix after flipping values first two last two rows have equal m either or
sort even and odd indices independently integer array rearrange values nums according following sort values odd indices nums nums before this becomes values odd indices sorted sort values even indices nums nums before this becomes values even indices sorted array formed after rearranging values nums we sort values present odd indices nums changes we sort values present even indices nums changes array formed after rearranging values nums since there exactly one odd index one even no rearrangement values takes resultant array formed which same initial
find a corresponding node of a binary tree in a clone of that tree two binary trees original cloned reference node target original cloned tree copy original reference same node cloned note not allowed change any two trees or target node answer must reference node cloned tree target all examples original cloned trees target node green node original answer yellow node cloned tree target tree target nodes tree range values nodes tree target node node original tree not follow could solve problem repeated values tree
maximum number of pairs in array integer array one may do choose two integers nums remove both integers forming operation done nums many times integer array answer size where pairs formed leftover integers nums after doing operation many times nums form pair remove them nums form pair remove them nums form pair remove them nums no more pairs can total pairs have been there leftover nums form pair remove them nums no more pairs can total pair been there numbers leftover nums no pairs can there leftover
decode xored permutation there integer array perm permutation first positive where always encoded into another integer array encoded length such xor perm then encoded encoded original array guaranteed answer exists encoded perm then encoded xor xor encoded
minimum number of operations to make arrays similar two positive integer arrays nums same one can choose any two distinct indices i j where j set set two arrays considered similar frequency each element minimum operations required make nums similar test cases generated such nums can always similar nums target possible make nums similar target two choose i j nums choose i j nums can shown minimum operations nums target we can make nums similar target one choose i j nums nums target array nums already similiar possible make nums similar
number of even and odd bits positive integer let even denote even indices binary representation value let odd denote odd indices binary representation value integer array answer where answer binary representation contains there even odd binary representation contains there even odd
binary tree coloring game two players play turn based game binary we root this binary nodes each node distinct value first player names value x x second player names value y y y first player colors node value x second player colors node value y players take turns starting first each player chooses node their color player blue player colors uncolored neighbor chosen node left right or parent chosen only player cannot choose such node this they must pass their both players pass their game winner player colored more second possible choose such y ensure win not root x true second player can choose node value root x false nodes tree x all values tree
integer to roman roman numerals represented seven different d symbol value i v x l c d m written ii roman just two added written which simply x written which xx v roman numerals usually written largest smallest left numeral four not four written because one before five we subtract making same principle applies which written there six instances where subtraction i can placed before v x make x can placed before l c make c can placed before d m make convert roman num represented num l v iii num m cm xc iv num
k-th smallest in lexicographical order two integers kth lexicographically smallest integer range k lexicographical order so second smallest k k
delete node in a linked list there list head we want delete node node node deleted not access first node all values linked list guaranteed node node not last node linked delete note deleting we do not mean removing we value node should not exist linked nodes linked list should decrease all values before node should same all values after node should same custom should provide entire linked list head node node should not last node list should actual node we build linked list pass node your output entire list after calling your head node second node value linked list should become after calling your head node third node value linked list should become after calling your nodes list range value each node list node deleted list not tail
populating next right pointers in each node ii binary tree struct node int node node node populate each next pointer point next right there no next right next pointer should set all next pointers set root above binary tree your function should populate each next pointer point next right just like figure serialized output level order connected next signifying end each root nodes tree range may only use constant extra recursive approach may assume implicit stack space does not count extra space this
house robber iv there several consecutive houses along each which some money there also who wants steal money but refuses steal adjacent capability robber maximum amount money steals one house all houses integer array nums representing how much money stashed each more ith house left also integer representing minimum houses robber steal always possible steal least k minimum capability robber out all possible ways steal least k nums k there three ways rob least rob houses indices capability rob houses indices capability rob houses indices capability we nums k there ways rob way which leads minimum capability rob house index k
minimum score by changing two elements integer array low score nums minimum value over all i j high score nums maximum value over all i j score nums sum high low scores minimize score we can change value most two elements minimum possible score after changing value most two elements note denotes absolute value nums change value so nums becomes value always equal so we nums change now nums becomes our low score achieved when i j which case our high score achieved when i j which case sum our high low score which we can prove
shortest distance to a character string s character c occurs array integers answer where distance index i closest occurrence character c distance between two indices i j where abs absolute value s c character appears indices closest occurrence index index so distance closest occurrence index index so distance index there tie between index index but distance still closest occurrence index index so distance s c c lowercase english guaranteed c occurs least once
design parking system design parking system parking parking lot three kinds parking fixed slots each implement parkingsystem int int initializes object parkingsystem slots each parking space part bool checks whether there parking space cartype car wants get into parking cartype can three or which represented car can only park parking space there no space else park car size space input output explanation parkingsystem parkingsystem new true because there available slot big car true because there available slot medium car false because there no available slot small car false because there no available slot big already small cartype or most calls made addcar
number of dice rolls with target sum have each die k faces numbered three integers possible ways kn total roll so sum numbers equals since answer may too modulo k target throw one die there only one way get sum k target throw two each there ways get sum k target answer must returned modulo k target
longer contiguous segments of ones than zeros binary string true longest contiguous segment strictly longer than longest contiguous segment or false s longest continuous segment length longest continuous segment length note there no then longest continuous segment considered have length same applies there no s true longest contiguous segment length longest contiguous segment length segment so s false longest contiguous segment length longest contiguous segment length segment not so s false longest contiguous segment length longest contiguous segment length segment not so either or
positions of large groups string s lowercase these letters form consecutive groups same string like s groups group identified interval where start end denote start end indices above interval group considered large or more intervals every large group sorted increasing order start s only large group start index end index s we have groups none which large s large groups s contains lowercase english letters
reverse nodes in k-group head linked reverse nodes list k modified k positive integer less than or equal length linked nodes not multiple k then should remain may not alter values only nodes themselves may head k head k nodes list k can solve problem extra memory
find critical and pseudo-critical edges in minimum spanning tree weighted undirected connected graph vertices numbered array edges where represents bidirectional weighted edge between nodes ai minimum spanning tree subset edges connects all vertices without cycles minimum possible total edge find all critical edges minimum spanning tree mst edge whose deletion graph would cause mst weight increase called critical other edge which can appear some msts but not note can indices edges any edges figure above describes following figure shows all possible notice two edges appear all therefore they critical so we them first list edges only part some therefore they considered we add them second list edges we can observe since all edges have equal choosing any edges yield therefore all edges ai bi weighti all pairs
minimum garden perimeter to collect enough apples garden represented infinite there apple tree planted every integer apple tree planted integer coordinate apples growing buy square plot land centered integer minimum perimeter plot such least neededapples apples inside or perimeter value defined x x x neededapples square plot side length does not contain any square plot side length apples inside depicted image perimeter neededapples neededapples neededapples
unique morse code words international morse code defines standard encoding where each letter mapped series dots maps maps maps so full table letters english alphabet array strings words where each word can written concatenation morse code each can written which concatenation we call such concatenation transformation different transformations among all words we words transformation each word there different words consists lowercase english
regions cut by slashes x grid composed x squares where each x square consists or blank space these characters divide square into contiguous grid grid represented string note backslash characters so represented grid grid grid recall because characters refers refers either or
minimum non-zero product of the array elements positive integer consider array nums consists integers inclusive range their binary allowed do following operation any choose two elements x y choose bit x swap corresponding bit corresponding bit refers bit same position other x y after swapping bit we have x y find minimum product nums after performing above operation any this product modulo answer should minimum product before modulo operation p nums there only one so product equals p nums any swap would either make product or stay array product already p nums first operation we can swap leftmost bit second fifth resulting array second operation we can swap middle bit third fourth resulting array array product which minimum possible p
reverse integer signed integer x digits reversing x causes value go outside signed integer range then assume environment does not allow store integers or x x x x
guess number higher or lower we playing guess game i pick have guess which i every time guess i tell whether i picked higher or lower than your call api int which returns three possible your guess higher than i picked num your guess lower than i picked num your guess equal i picked num i pick pick pick pick
odd string difference array strings assume length each string each string can converted into difference integer array length where where j note difference between two letters difference between their positions alphabet position string difference integer array all strings words have same difference integer except should find string words different difference integer words difference integer array difference integer array difference integer array odd array out so we corresponding words all integer arrays except which corresponds consists lowercase english
falling squares there several squares being dropped onto integer array positions where represents ith square side length sidelengthi dropped left edge aligned each square dropped one time height above any landed then falls downward y until either lands top side another square or square brushing side another square does not count landing once freezes place cannot after each square must record height current tallest stack integer array ans where represents height described above after dropping ith positions after first tallest stack square height after second tallest stack squares height after third tallest stack still squares height we answer positions after first tallest stack square height after second tallest stack either square or square both heights we answer note square only brushes right side square which does not count landing lefti sidelengthi
construct the lexicographically largest valid sequence integer find sequence satisfies all integer occurs once each integer between occurs twice every integer i between distance between two occurrences i exactly distance between two numbers absolute difference their lexicographically largest guaranteed under there always sequence lexicographically larger than sequence b same first position where b sequence greater than corresponding lexicographically larger than because first position they differ third greater than also valid but lexicographically largest valid
maximum score after splitting a string string s zeros maximum score after splitting string into two substrings left substring right score after splitting string zeros left substring plus ones right s all possible ways splitting s into two substrings left right score left right score left right score left right score left right score s when left right we get maximum score s string s consists characters
maximum xor after operations integer array one select any integer x index then update equal xor note bitwise operation xor bitwise xor maximum possible bitwise xor all elements nums after applying operation any nums apply operation x i xor nums bitwise xor all elements xor xor xor can shown maximum possible bitwise note other operations may used achieve bitwise xor nums apply operation zero bitwise xor all elements xor xor xor xor can shown maximum possible bitwise
course schedule iii there different online courses numbered array courses where indicate ith course should taken continuously durationi days must finished before or start day cannot take two or more courses maximum courses can courses there totally but can take courses take costs days so finish ready take next course take costs days so finish ready take next course take costs days so finish course cannot taken since finish which exceeds closed courses courses lastdayi
find the maximum number of marked indices integer array all indices allowed make this operation any pick two different unmarked indices i j such then mark i maximum possible marked indices nums using above operation any nums first pick i j operation allowed because then mark index can shown no other valid operation so answer nums first pick i j operation allowed because then mark index second pick i j operation allowed because then mark index since there no other answer nums there no valid operation so answer
minimum possible integer after at most k adjacent swaps on digits string num representing digits very large integer integer allowed swap any two adjacent digits integer most k minimum integer can obtain also num k steps obtain minimum integer adjacent swaps num k ok output have leading but input guaranteed not have any leading num k we can keep without any num consists only digits does not contain leading k
sum of absolute differences in a sorted array integer array nums sorted build integer array result same length nums such equal summation absolute differences between all other elements other equal where j j i nums assuming arrays then nums
largest number at least twice of others integer array nums where largest integer determine whether largest element array least twice much every other index largest or nums largest every other array least twice big index value so we nums less than twice value so we largest element nums
selling pieces of wood two integers m represent height width rectangular piece also integer array where indicates can sell rectangular piece wood height hi width wi pricei cut piece must make vertical or horizontal cut across entire height or width piece split into two smaller after cutting piece wood into some smaller can sell pieces according may sell multiple pieces same do not have sell all grain wood makes so cannot rotate piece swap height maximum money can earn after cutting m x piece note can cut piece wood many times m prices diagram above shows possible consists pieces wood shaped x selling price piece wood shaped x selling price piece wood shaped x selling price this obtains total money can shown maximum amount money can m prices diagram above shows possible consists pieces wood shaped x selling price piece wood shaped x selling price this obtains total money can shown maximum amount money can notice we cannot rotate x piece wood obtain x piece hi m wi pricei all shapes wood pairwise
min cost climbing stairs integer array cost where cost ith step once pay can either climb one or two can either start step index or step index minimum cost reach top cost start index pay climb two steps reach total cost cost start index pay climb two steps reach index pay climb two steps reach index pay climb two steps reach index pay climb one step reach index pay climb two steps reach index pay climb one step reach total cost
modify graph edge weights undirected weighted connected graph containing nodes labeled integer array edges where indicates there edge between nodes ai bi weight some edges have weight while others have positive weight your task modify all edges weight assigning them positive integer values range so shortest distance between nodes source destination becomes equal integer there multiple modifications make shortest distance between source destination equal any them considered array containing all edges unmodified any order possible make shortest distance source destination equal or empty array not allowed modify weights edges initial positive edges source destination target graph above shows possible modification making distance equal edges source destination target graph above contains initial not possible make distance equal modifying edge weight empty array edges source destination target graph above shows modified graph having shortest distance bi wi or wi ai bi destination source destination target graph there no or repeated edges
compare strings by frequency of the smallest character let function frequency lexicographically smallest character string s then because lexicographically smallest character which frequency array strings words another array query strings each query count words words such each w integer array where each answer ith queries words first query we have so queries words first query only second query both both consist lowercase english
squares of a sorted array integer array nums sorted array squares each sorted nums after array becomes after becomes nums nums sorted follow squaring each element sorting new array very could find solution using different
array prototype last write code enhances all arrays such can call method any array last there no elements should may assume array output nums calling should last nums because there no
maximum depth of n-ary tree find maximum maximum depth nodes along longest path root node down farthest leaf input serialization represented their level order each group children separated null value root root total nodes range depth tree less than or equal
subarray sums divisible by k integer array nums integer subarrays have sum divisible subarray contiguous part nums k there subarrays sum divisible k nums k k
percentage of letter in string string s character percentage characters s equal letter rounded down nearest whole s letter percentage characters s equal letter when rounded so we s letter percentage characters s equal letter so we s consists lowercase english letter lowercase english
rectangle overlap rectangle represented list where coordinate coordinate top bottom edges parallel left right edges parallel two rectangles overlap area their intersection two rectangles only touch corner or edges do not two rectangles true they otherwise true false false represent valid rectangle
number of ways to buy pens and pencils integer total indicating amount money also two integers indicating price pen pencil can spend part or all your money buy multiple quantities each kind writing distinct ways can buy some pens total price pen price pencil buy can buy or buy can buy or buy cannot buy any total ways buy pens pencils total price both pens pencils which cost more than so cannot buy any writing there only buy pens
count number of bad pairs integer array pair indices bad pair i j j i total bad pairs nums pair bad pair since pair bad pair since pair bad pair since pair bad pair since pair bad pair since there total bad so we nums there no bad
online election two integer arrays persons ith vote cast time each query time find person leading election time votes cast time t count towards our case most recent vote tied implement topvotedcandidate initializes object persons times int returns person leading election time t according mentioned input output explanation topvotedcandidate topvotedcandidate new time votes time votes time votes leading ties go most recent times sorted strictly increasing t most calls made
maximum ascending subarray sum array positive integers maximum possible sum ascending subarray subarray defined contiguous sequence numbers subarray ascending all i where l i numsi note subarray size nums ascending subarray maximum sum nums ascending subarray maximum sum nums ascending subarray maximum sum
patients with a condition sql schema patients column name type int varchar conditions varchar primary key this contains or more code separated this table contains information patients write sql query report conditions patients who have type i type i diabetes always starts result table any query result format following patients conditions daniel yfev cough alice bob myop george acne alain conditions bob myop george acne bob george both have condition starts
minimum number of food buckets to feed the hamsters string hamsters where indicating there hamster index or indicating index i add some food buckets empty indices order feed hamster can fed there least one food bucket left or more hamster index i can fed place food bucket index i index i minimum food buckets should place empty indices feed all hamsters or impossible feed all hamsters we place two food buckets indices can shown we place only one food one hamsters not hamsters we place one food bucket index hamsters we place food bucket every empty index hamster index not able or
count collisions of monkeys on a polygon there regular convex polygon vertices labeled clockwise each vertex exactly one following figure shows convex polygon each monkey moves simultaneously neighboring neighboring vertex vertex i can vertex clockwise or vertex collision happens least two monkeys reside same vertex after movement or intersect ways monkeys can move so least one collision since answer may very modulo note each monkey can only move there total possible two ways such they collide some point monkey moves clockwise monkey moves anticlockwise monkey moves clockwise monkeys monkey moves anticlockwise monkey moves anticlockwise monkey moves clockwise monkeys can shown total movements result can shown there ways monkeys
apply operations to an array array nums size consisting need apply operations this array ith operation apply following ith element then multiply set skip this after performing all shift all end array after shifting all resulting note operations applied not all nums we do following i not so we skip this i we multiply change array becomes i not so we skip this i we multiply change array becomes i we multiply change array becomes after we shift which gives array nums no operation can we just shift
smallest range ii integer array nums integer each index i where i change either k or score nums difference between maximum minimum elements minimum score nums after changing values each nums k score nums k change nums score nums k change nums score k
k radius subarray averages array nums integer average subarray nums centered some index i radius k average all elements nums between indices i k i k there less than k elements before or after index then average build array avgs length where average subarray centered index average x elements sum x elements divided using integer integer division truncates toward which means losing fractional average four elements which truncates nums k because there less than k elements before each sum subarray centered index radius using integer subarray centered index subarray centered index because there less than k elements after each nums k sum subarray centered index radius nums k because there less than k elements before after index k
minimum rounds to complete all tasks integer array where represents difficulty level each can complete either or tasks same difficulty minimum rounds required complete all or not possible complete all tasks complete all possible plan first complete tasks difficulty level second complete tasks difficulty level third complete tasks difficulty level fourth complete tasks difficulty level can shown all tasks cannot completed fewer than so answer tasks there only task difficulty level but each can only complete either or tasks same difficulty cannot complete all answer
optimal partition of string string partition string into one or more substrings such characters each substring no letter appears single substring more than minimum substrings such note each character should belong exactly one substring s two possible partitions can shown minimum substrings s only valid partition s consists only english lowercase
scramble string we can scramble string s get string t using following length string length string do split string into two substrings random string divide x y where s x randomly decide swap two substrings or keep them same after this s may become s x y or s y apply step recursively each two substrings x two strings same true scrambled string true one possible scenario applied divide random random decision not swap two substrings keep them apply same algorithm recursively both divide random index each random decision swap first substring keep second substring same again apply algorithm divide random decision keep both substrings same algorithm stops result string which one possible scenario led scrambled we false true consist lowercase english
check whether two strings are almost equivalent two strings considered almost equivalent differences between frequencies each letter between most two strings each length true almost or false frequency letter x times occurs false there but difference which more than allowed true differences between frequencies each letter most appears time times difference appears time time difference appears time times difference appears time times difference appears times times difference appears time times difference true differences between frequencies each letter most appears times times difference appears times times difference appears times times difference appears times times difference consist only lowercase english
remove digit from number to maximize result string representing positive integer character resulting string after removing exactly one occurrence digit such value resulting string decimal form test cases generated such digit occurs least once digit there only one after removing result digit we can remove first get or remove second get since we digit we can remove either first or second both result string consists digits digit digit digit occurs least once
single element in a sorted array sorted array consisting only integers where every element appears exactly except one element which appears exactly single element appears only your solution must run time nums nums
number of different integers in a string string word consists digits lowercase english replace every character become notice left some integers separated least one different integers after performing replacement operations two integers considered different their decimal representations without any leading zeros word three different integers notice only counted word word three integers all represent same integer because leading zeros ignored when comparing their decimal word consists digits lowercase english
maximum total importance of roads integer denoting cities cities numbered also integer array roads where denotes there exists bidirectional road connecting cities ai need assign each city integer value where each value can only used importance road then defined sum values two cities maximum total importance all roads possible after assigning values roads figure above shows country assigned values road importance road importance road importance road importance road importance road importance total importance all roads can shown we cannot obtain greater total importance than roads figure above shows country assigned values road importance road importance road importance total importance all roads can shown we cannot obtain greater total importance than bi ai bi there no duplicate
minimum cost to cut a stick wooden stick length stick labelled stick length labelled integer array cuts where denotes position should perform cut should perform cuts can change order cuts cost one cut length stick total cost sum costs all when cut split into two smaller sticks sum their lengths length stick before please refer first better minimum total cost cuts using cuts order input leads following first cut done rod length so cost second cut done rod length second part first third done rod length last cut rod length total cost rearranging cuts lead scenario total cost shown photo cuts try cuts ordering cost there much ordering total cost order total cost which minimum all integers cuts array
add digits integer repeatedly add all digits until result only one num process since only one num num follow could do without any
find users with valid e-mails sql schema users column name type int name varchar mail varchar primary key this this table contains information users signed up some write sql query find users who have valid valid prefix name domain prefix name string may contain letters or lower underscore period dash prefix name must start domain result table any query result format following users name mail winston jonathan jonathanisgreat annabelle sally marwan david shapiro name mail winston annabelle sally mail user does not have mail user sign which not mail user does not have leetcode mail user starts
largest color value in a directed graph there directed graph colored nodes m nodes numbered string colors where lowercase english letter representing color ith node this graph also array edges where indicates there directed edge node aj node valid path graph sequence nodes xk such there directed edge xi every i color value path nodes colored most frequently occurring color along largest color value any valid path or graph contains colors edges path contains nodes colored above colors edges there cycle m m colors consists lowercase english bj
number of days between two dates write program count days between two two dates their format shown dates valid dates between years
largest perimeter triangle integer array largest perimeter triangle formed three these impossible form any triangle nums can form triangle three side nums cannot use side lengths form cannot use side lengths form cannot use side lengths form we cannot use any three side lengths form triangle we
largest number after digit swaps by parity positive integer may swap any two digits num have same parity both odd digits or both even largest possible value num after any num swap digit digit this results swap digit digit this results note there may other sequences swaps but can shown largest possible also note we may not swap digit digit since they different num swap digit digit this results swap first digit digit this results note there may other sequences swaps but can shown largest possible num
parallel courses ii integer which indicates there courses labeled also array relations where representing prerequisite relationship between course prevcoursei course course prevcoursei taken before course integer one can take most k courses long have taken all prerequisites previous semesters courses minimum semesters needed take all testcases generated such possible take every relations k figure above represents first can take courses second can take course third can take course relations k figure above represents first can only take courses since cannot take more than two per second can take course third can take course fourth can take course k nextcoursei prevcoursei nextcoursei all pairs graph directed acyclic
reveal cards in increasing order integer array there deck cards where every card unique integer ith card can order deck any order all cards start face down one do following steps repeatedly until all cards take top card reveal take out there still cards deck then put next top card deck bottom there still unrevealed go back step ordering deck would reveal cards increasing note first entry answer considered top deck we get deck order order does not reorder after deck starts where top we reveal move deck now we reveal move deck now we reveal move deck now we reveal move deck now we reveal move deck now we reveal move deck now we reveal since all cards revealed increasing answer deck all values deck
split a string in balanced strings balanced strings those have equal quantity balanced string split into some substrings such each substring maximum balanced strings can s s can split into each substring contains same s s can split into each substring contains same note s cannot split into because substrings not s s can split into either or s balanced
word break ii string s dictionary strings add spaces s construct sentence where each word valid dictionary all such possible sentences any note same word dictionary may reused multiple times s worddict sand s worddict apple pen pen applepen note allowed reuse dictionary s worddict s consist only lowercase english all strings worddict input generated way length answer exceed
maximize greatness of an array integer array allowed permute nums into new array perm your we define greatness nums indices i which maximum possible greatness can achieve after permuting nums one optimal rearrangements perm indices we nums we can prove optimal perm indices we
minimize maximum of array array nums comprising one choose integer i such i decrease increase minimum possible value maximum integer nums after performing any nums one set optimal operations choose i nums becomes choose i nums becomes choose i nums becomes maximum integer nums can shown maximum cannot less than we nums optimal leave nums since maximum we
subsets ii integer array nums may contain all possible subsets power solution set must not contain duplicate solution any nums nums
minimum time to complete trips array time where denotes time taken ith bus complete one each bus can make multiple trips next trip can start immediately after completing current each bus operates trips one bus do not influence trips any other also integer which denotes trips all buses should make minimum time required all buses complete least totaltrips time totaltrips time t trips completed each bus total trips completed time t trips completed each bus total trips completed time t trips completed each bus total trips completed so minimum time needed all buses complete least trips time totaltrips there only one complete first trip t so minimum time needed complete trip totaltrips
market analysis i sql schema users column name type int date varchar primary key this this table info users online shopping website where users can sell buy orders column name type int date int int int primary key this foreign key items foreign keys users items column name type int varchar primary key this write sql query find each join date orders they made buyer result table any query result format following users lenovo samsung lg hp orders items samsung lenovo lg hp
permutations ii collection might contain all possible unique permutations any nums nums
first bad version product manager currently leading team develop new latest version your product fails quality since each version developed based previous all versions after bad version also suppose have versions want find out first bad which causes all following ones api bool which returns whether version implement function find first bad should minimize calls bad call false call true call true then first bad bad bad
power of four integer true power integer power there exists integer x such true false true follow could solve without
strange printer there strange printer following two special printer can only print sequence same character each each printer can print new characters starting ending any place cover original existing string minimum turns printer needed print s print first then print s print first then print second place which cover existing character s consists lowercase english
reverse only letters string reverse string according following all characters not english letters remain same all english letters or should s after reversing s s s s consists characters ascii values range s does not contain or
chalkboard xor game array integers nums represents numbers written alice bob take turns erasing exactly one alice starting erasing causes bitwise xor all elements chalkboard become then player bitwise xor one element element bitwise xor no elements any player starts their turn bitwise xor all elements chalkboard equal then player true only alice wins assuming both players play nums false alice two erase or erase she erases nums array becomes bitwise xor all elements chalkboard xor now bob can remove any element because alice one erase last element she alice erases now nums become bitwise xor all elements chalkboard xor alice nums true nums true
design hashmap design hashmap without using any hash table implement myhashmap initializes object empty void int inserts pair into key already exists update corresponding int returns value which specified key or this map contains no mapping void removes key corresponding value map contains mapping input output explanation myhashmap myhashmap new map now map now map now not map now map now update existing map now remove mapping map now not map now value most calls made
count of matches in tournament integer teams tournament strange current teams each team gets paired another total matches teams advance next current teams one team randomly advances rest gets total matches teams advance next matches played tournament until winner details teams matches teams teams matches teams teams matches team declared total matches details teams matches teams teams matches teams teams matches teams teams matches team declared total matches
largest palindromic number string num consisting digits largest palindromic integer form can formed using digits taken should not contain leading do not need use all digits but must use least one digits can num use digits form palindromic integer can shown largest palindromic integer can num can shown largest palindromic integer can note integer returned should not contain leading num consists
top k frequent elements integer array nums integer k most frequent may answer any nums k nums k k range unique elements guaranteed answer follow your time complexity must better than log where
event emitter design eventemitter this interface similar some one found or event target interface eventemitter should allow subscribing events emitting your eventemitter class should have following two subscribe this method takes two name event string callback this callback function later called when event event should able have multiple listeners same when emitting event multiple each should called order which they array results should can assume no callbacks passed subscribe referentially subscribe method should also object unsubscribe method enables user when callback should removed list subscriptions undefined should emit this method takes two name event string optional array arguments passed there no callbacks subscribed empty array results all callback calls order they actions values const emitter new no callback subscribed yet function function returns output actions values note emit method should able accept optional array const emitter new function actions values const emitter new const sub undefined there no subscriptions actions values x x const emitter new const x x const x x undefined all test cases need handle scenarios when unsubscribing there only different eventemitter action take any emit action takes between either or first argument name event we want argument passed callback subscribe action takes where first one event name second callback unsubscribe action takes one which order subscription made
score of parentheses balanced parentheses string score score balanced parentheses string based following score ab score where b balanced parentheses score where balanced parentheses s s s s consists only s balanced parentheses
count hills and valleys in an array integer array index i part hill nums closest neighbors i smaller than index i part valley nums closest neighbors i larger than adjacent indices i j part same hill or valley note index part hill or must have neighbor both left right hills valleys nums index there no neighbor so index neither hill nor index closest neighbors since index index closest neighbors since index index closest neighbors since index but note part same valley index index closest neighbors since index index there no neighbor so index neither hill nor there hills valleys so we nums index there no neighbor so index neither hill nor index there no neighbor so index neither hill nor index closest neighbors since index neither hill nor index closest neighbors since index neither hill nor index closest neighbors since index neither hill nor index there no neighbor so index neither hill nor there hills valleys so we
h-index ii array integers citations where citations researcher received their ith paper citations sorted ascending according definition defined maximum value h such researcher published least h papers have each been cited least h must write algorithm runs logarithmic citations means researcher papers total each them had received citations since researcher papers least citations each remaining two no more than citations their citations citations sorted ascending
maximum xor with an element from array array nums consisting also queries where answer ith query maximum bitwise xor value xi any element nums does not exceed other answer xor all j such all elements nums larger than then answer integer array answer where answer ith nums queries only two integers not greater than xor xor larger two xor xor nums queries mi
remove outermost parentheses valid parentheses string either empty or where b valid parentheses represents string all valid parentheses valid parentheses string s primitive there does not exist way split into s b nonempty valid parentheses valid parentheses string consider primitive s where pi primitive valid parentheses s after removing outermost parentheses every primitive string primitive decomposition s input string primitive decomposition after removing outer parentheses each this s input string primitive decomposition after removing outer parentheses each this s input string primitive decomposition after removing outer parentheses each this either or s valid parentheses
palindrome pairs array unique strings palindrome pair pair integers such j i concatenation two palindrome array all palindrome pairs words palindromes words palindromes words palindromes consists lowercase english
sum of floored pairs integer array sum all pairs indices j since answer may too modulo function returns integer part nums we calculate floor division every pair indices array then sum them nums
employees with missing information sql schema employees column name type int name varchar primary key this each row this table indicates name employee whose id salaries column name type int salary int primary key this each row this table indicates salary employee whose id write sql query report ids all employees missing information employee missing name or salary result table ordered ascending query result format following employees name crew haven kristian salaries salary employees working this name employee salary employee
seat reservation manager design system manages reservation state seats numbered implement seatmanager initializes seatmanager object manage seats numbered all seats initially int fetches unreserved reserves returns void unreserves seat input output explanation seatmanager seatmanager new initializes seatmanager all seats so lowest numbered which available seats so lowest which unreserve seat so now available seats available seats so lowest which available seats so lowest which available seats so lowest which only available seat seat so unreserve seat so now available seats seatnumber each call guaranteed there least one unreserved each call guaranteed seatnumber most calls total made reserve
count subtrees with max distance between cities there cities numbered array edges size where represents bidirectional edge between cities ui there exists unique path between each pair other cities form subtree subset cities where every city reachable every other city where path between each pair passes through only cities two subtrees different there city one subtree not present each d find subtrees which maximum distance between any two cities subtree equal array size where dth element subtrees which maximum distance between any two cities equal notice distance between two cities edges path between edges subtrees subsets have max distance subtrees subsets have max distance no subtree two nodes where max distance between them edges edges vi all pairs
satisfiability of equality equations array strings equations represent relationships between variables where each string length takes one two different or xi yi lowercase letters necessarily represent variable true possible assign integers variable names so satisfy all or false equations false we assign b then first equation but not there no way assign variables satisfy both equations true we could assign b satisfy both lowercase either or lowercase
longest uncommon subsequence i two strings length longest uncommon subsequence between longest uncommon subsequence does not uncommon subsequence between two strings string subsequence one but not subsequence string s string can obtained after deleting any characters subsequence because can delete underlined characters get other subsequences include b one longest uncommon subsequence because subsequence but not note also longest uncommon b longest uncommon subsequences b every subsequence string also subsequence string every subsequence string b also subsequence string b consist english
maximal square m x binary matrix filled find largest square containing only matrix matrix matrix m or
find followers count sql schema followers column name type int int primary key this this table contains ids user follower social media app where follower follows write sql query each result table ordered ascending query result format following followers followers followers followers
memoize function memoized version memoized function function never called twice same instead cached can assume there possible input sum accepts two integers b returns fib accepts single integer returns or factorial accepts single integer returns or input output explanation const sum const memoizedsum returns called not seen returns however not called because same inputs seen total call returns called not seen total call input output explanation const factorial const memofactorial returns returns returns however factorial not called because seen total call returns however factorial not called because seen total call input output explanation total call b most function calls most attempts access callcount input function or factorial
arithmetic subarrays sequence numbers called arithmetic consists least two difference between every two consecutive elements more sequence s arithmetic only all valid these arithmetic following sequence not array two arrays m integers l representing m range where ith query range all arrays list boolean elements where true subarray can rearranged form arithmetic false nums l r subarray this can rearranged which arithmetic subarray this cannot rearranged arithmetic subarray this can rearranged which arithmetic nums l r m m m
find servers that handled most number of requests have k servers numbered being used handle multiple requests each server infinite computational capacity but cannot handle more than one request requests assigned servers according specific ith request all servers request dropped handled server assign request assign request next available server around list servers starting ith server try assign request then so strictly increasing array arrival positive where represents arrival time ith another array where represents load ith request time takes your goal find busiest server considered busiest handled most requests successfully among all list containing ids busiest may ids any k arrival load all servers start out first requests handled first servers request comes server so assigned next available which request comes cannot handled since all servers so servers handled one request while server handled two hence server busiest k arrival load first requests handled first request comes handled server since server server handled two while servers handled one request hence server busiest k arrival load each server handles single so they all considered k arrival strictly
minimum number of refueling stops car travels starting position destination which target miles east starting there gas stations along gas stations represented array stations where indicates ith gas station positioni miles east starting position fueli liters car starts infinite tank which initially startfuel liters fuel uses one liter gas per one mile when car reaches gas may stop transferring all gas station into minimum refueling stops car must make order reach cannot reach note car reaches gas station fuel car can still refuel car reaches destination fuel still considered have target startfuel stations we can reach target without target startfuel stations we can not reach target even first gas target startfuel stations we start liters we drive position expending liters we refuel liters liters we drive position position liters refuel liters liters we then drive reach we made refueling stops along so we startfuel positioni target fueli
remove one element to make the array strictly increasing integer array true can made strictly increasing after removing exactly one or false array already strictly array nums strictly increasing each index i nums true removing index becomes strictly so nums false result removing element index result removing element index result removing element index result removing element index no resulting array strictly so nums false result removing any element not strictly so
largest values from labels there set two integer arrays values labels where value label ith element also two integers numwanted choose subset s elements such size subset s less than or equal there most uselimit items same label score subset sum values maximum score subset values labels numwanted uselimit subset chosen fifth values labels numwanted uselimit subset chosen third values labels numwanted uselimit subset chosen first fourth uselimit
n-ary tree postorder traversal root postorder traversal input serialization represented their level order each group children separated null value root root nodes tree range height tree less than or equal follow recursive solution could do
sales person sql schema salesperson column name type int name varchar salary int int date primary key column this each row this table indicates name id salesperson alongside their commission hire company column name type int name varchar city varchar primary key column this each row this table indicates name id company city which company orders column name type int date int int amount int primary key column this foreign key company foreign key salesperson each row this table contains information about one this includes id id date amount write sql query report names all salespersons who did not have any orders related company name result table any query result format following salesperson name salary john amy mark pam alex company name city red boston orange new york yellow boston green austin orders amount name amy mark alex according orders orders easy tell only salesperson john pam have sales company so we report all other names table
minimum swaps to make strings equal two strings equal length consisting letters your task make these two strings equal each can swap any two characters belong different which swap minimum swaps required make or impossible do swap swap swap note cannot swap make equal cause we can only swap chars different only contain or
count subarrays with fixed bounds integer array nums two integers mink subarray nums subarray satisfies following minimum value subarray equal maximum value subarray equal subarray contiguous part nums mink maxk subarrays nums mink maxk every subarray nums there possible maxk
poor pigs there buckets buckets where exactly one buckets figure out which one feed some pigs liquid see whether they die or only have minutestotest minutes determine which bucket can feed pigs according these choose some live pigs each choose which buckets feed pig consume all chosen buckets simultaneously take no each pig can feed any each bucket can fed any wait minutestodie may not feed any other pigs during this after minutestodie minutes have any pigs have been fed poisonous bucket all others repeat this process until run out minimum pigs needed figure out which bucket poisonous within allotted buckets minutestodie minutestotest we can determine poisonous bucket time feed first pig buckets feed second pig buckets time there possible only first pig then bucket must only second pig then bucket must both pigs then bucket must neither pig then bucket must buckets minutestodie minutestotest we can determine poisonous bucket time feed first pig bucket feed second pig bucket time there possible either pig then poisonous bucket one neither pig then feed first pig bucket feed second pig bucket time one two pigs must poisonous bucket one buckets minutestodie minutestotest
reduce array size to the half integer array can choose set integers remove all occurrences these integers minimum size set so least half integers array arr choosing make new array which size equal half size old possible sets size choosing set not possible make new array which size greater than half size old arr only possible set can choose this make new array
maximum subarray min-product array equal minimum value array multiplied array value array integers maximum any subarray since answer may modulo note should maximized before performing modulo testcases generated such maximum without modulo fit signed subarray contiguous part nums maximum achieved subarray value nums maximum achieved subarray value nums maximum achieved subarray value
n-th tribonacci number tribonacci sequence tn defined tn value answer guaranteed fit within answer
sort colors array nums objects colored or sort them so objects same color colors order we use integers represent color must solve this problem without using sort nums nums either or follow could come up algorithm using only constant extra
largest 3-same-digit number in string string num representing large integer good meets following substring num length consists only one unique maximum good integer string or empty string no such integer substring contiguous sequence characters within there may leading zeroes num or good num there two distinct good so we num only good num no substring length consists only one unique there no good num only consists
constrained subsequence sum integer array nums integer maximum sum subsequence array such every two consecutive integers where i condition j i k subsequence array obtained deleting some elements leaving remaining elements their original nums k subsequence nums k subsequence must so we choose largest nums k subsequence k
reorder list head singly list can represented ln ln reorder list following ln ln ln may not modify values only nodes themselves may head head nodes list range
split message based on limit positive must split message into one or more parts based each resulting part should have suffix where replaced total parts replaced index starting going up length each resulting part should equal except last part whose length can most resulting parts should formed such when their suffixes removed they all concatenated they should equal result should contain few parts parts message would split into array impossible split message empty message really very awesome limit first parts take characters each beginning next parts take characters each finish splitting this each including length can shown not possible split message into less than message limit under string can split into two first part comprises first length next part comprises last length message consists only lowercase english letters limit
cut off trees for golf event asked cut off all trees forest golf forest represented m x this means cell cannot walked represents empty cell can walked greater than represents tree cell can walked this one can walk any four standing cell can choose whether cut must cut off trees order shortest when cut off value cell becomes empty starting point minimum steps need walk cut off all cannot cut off all input generated such no two trees have same there least one tree needs cut forest following path above allows cut off trees shortest tallest forest trees bottom row cannot accessed middle row forest can follow same path cut off all note can cut off first tree before making any m heights all trees
convert an array into a 2d array with conditions integer array need create array nums satisfying following array should contain only elements array each row array contains distinct rows array should resulting there multiple any note array can have different elements each nums we can create array contains following all elements nums each row array contains distinct so valid can shown we cannot have less than rows valid nums all elements array so we can keep all them first row
beautiful arrangement suppose have integers labeled through permutation those integers perm considered beautiful arrangement every i i either following divisible i divisible integer beautiful arrangements can first beautiful arrangement divisible i divisible i second beautiful arrangement divisible i i divisible
longest subsequence repeated k times string s length integer tasked find longest subsequence repeated k times string subsequence string can derived another string deleting some or no characters without changing order remaining subsequence seq repeated k times string s seq k subsequence where seq k represents string constructed concatenating seq k repeated times string because string constructed concatenating subsequence string longest subsequence repeated k times string multiple such subsequences lexicographically largest there no such empty s k there two longest subsequences repeated lexicographically largest s k longest subsequence repeated times s k there no subsequence repeated empty string k k s consists lowercase english
count lattice points inside a circle integer array circles where represents center radius ri ith circle drawn lattice points present inside least one lattice point point integer points lie circumference circle also considered inside circles figure above shows lattice points present inside circle shown other points such which shown not considered inside lattice points present inside least one circle circles figure above shows there exactly lattice points which present inside least one some them yi ri
binary tree zigzag level order traversal root binary zigzag level order traversal left then right left next level alternate root root root nodes tree range
hand of straights alice some cards she wants rearrange cards into groups so each group size consists groupsize consecutive integer array hand where value written ith card integer true she can rearrange or false hand groupsize true hand can rearranged hand groupsize false hand can not rearranged into groups groupsize this question same
find winner on a tic tac toe game played two players b x rules players take turns placing characters into empty squares first player always places while second player b always places characters always placed into empty never filled game ends when there three same character filling any or game also ends all squares no more moves can played game integer array moves where indicates ith move played winner game exists or case game ends draw there still movements play can assume moves valid follows rules grid initially play moves they always play moves b moves game ends draw since there no moves coli there no repeated elements moves follow rules tic tac
simplify path string which absolute path slash file or directory file convert simplified canonical file period refers current double period refers directory up any multiple consecutive slashes treated single slash this any other format periods such treated canonical path should have following path starts single slash any two directories separated single slash path does not end trailing path only contains directories path root directory target file or directory no period or double period simplified canonical path note there no trailing slash after last directory path going one level up root directory root level highest level can path canonical multiple consecutive slashes replaced single path consists english period slash or path valid absolute unix
maximum and sum of array integer array nums length integer numslots such numslots there numslots slots numbered have place all integers into slots such each slot contains most two sum placement sum bitwise every respective slot sum placing numbers into slot into slot equal maximum possible sum nums numslots nums numslots one possible placement into slot into slot into slot this gives maximum sum nums numslots one possible placement into slot into slot into slot into slot into slot this gives maximum sum note slots empty which numslots numslots
insert interval array intervals intervals where represent start end ith interval intervals sorted ascending order also interval newinterval represents start end another insert newinterval into intervals such intervals still sorted ascending order starti intervals still does not have any overlapping intervals overlapping intervals intervals after intervals newinterval intervals newinterval because new interval overlaps starti endi intervals sorted starti ascending start end
minimum operations to halve array sum array nums positive one can choose any nums reduce exactly half may choose this reduced future minimum operations reduce sum nums least nums initial sum nums equal following one ways reduce sum least pick reduce pick reduce pick reduce final array total sum sum nums been reduced which least half initial operations used so we can shown we cannot reduce sum least half less than nums initial sum nums equal following one ways reduce sum least pick reduce pick reduce pick reduce final array total sum sum nums been reduced which least half initial operations used so we can shown we cannot reduce sum least half less than
max points on a line array points where represents point maximum points lie same straight points points yi all points
shortest common supersequence two strings shortest string both there multiple valid any string s subsequence string t deleting some characters t results string subsequence because we can delete first subsequence because we can delete last answer provided shortest such string satisfies these consist lowercase english
greatest sum divisible by three integer array maximum possible sum elements array such divisible nums pick numbers their sum sum divisible nums since not divisible do not pick any nums pick numbers their sum sum divisible
sum of distances in tree there undirected connected tree nodes labeled integer array edges where indicates there edge between nodes ai bi array answer length where sum distances between ith node tree all other edges tree shown we can see equals so edges edges bi ai bi input represents valid
furthest building you can reach integer array heights representing heights some some start your journey building move next building possibly using bricks or while moving building i building current height greater than or equal next do not need ladder or current height less than next can either use one ladder or furthest building index can reach use ladders bricks heights bricks ladders starting building can follow these go building without using ladders nor bricks since go building using must use either bricks or ladders because go building without using ladders nor bricks since go building using your only must use either bricks or ladders because impossible go beyond building because do not have any more bricks or heights bricks ladders heights bricks ladders bricks ladders
partition array according to given pivot integer array nums integer rearrange nums such following conditions every element less than pivot appears before every element greater than every element equal pivot appears between elements less than greater than relative order elements less than pivot elements greater than pivot more consider every pj where pi new position ith element pj new position jth elements less than i j pivot then pi similarly elements greater than i j pivot then pi nums after nums pivot elements less than pivot so they left side elements greater than pivot so they right side relative ordering elements less than greater than pivot also respective nums pivot element less than pivot so left side elements greater than pivot so they right side relative ordering elements less than greater than pivot also respective pivot equals element
frog jump frog crossing river divided into some each there may or may not exist frog can jump but must not jump into list positions sorted ascending determine frog can cross river landing last frog first stone assumes first jump must last jump k next jump must either k or k frog can only jump forward stones true frog can jump last stone jumping unit then units then units then units units units stones false there no way jump last stone gap between stone too stones sorted strictly increasing
find center of star graph there undirected star graph consisting nodes labeled star graph graph where there one center node exactly edges connect center node every other integer array edges where each indicates there edge between nodes ui center star edges shown figure node connected every other so edges vi ui vi edges represent valid star
longest palindrome string s which consists lowercase or uppercase length longest palindrome can built those letters case not considered palindrome s one longest palindrome can built whose length s longest palindrome can built whose length s consists lowercase uppercase english letters
numbers with same consecutive differences two integers array all integers length where difference between every two consecutive digits may answer any note integers should not have leading integers not k note not valid because leading k k
sum of subarray minimums array integers find sum where b ranges over every subarray since answer may answer modulo arr subarrays minimums sum arr
count array pairs divisible by k integer array nums length integer pairs such i j divisible nums k pairs indices whose corresponding products divisible their products other pairs such have products which not divisible nums k there does not exist any pair indices whose corresponding product divisible k
find the longest substring containing vowels in even counts string size longest substring containing each vowel even must appear even s longest substring which contains two each i o zero s longest substring which contains two s this string longest because all o u appear zero x s contains only lowercase english
middle of the linked list head singly linked middle node linked there two middle second middle head middle node list node head since list two middle nodes values we second nodes list range
longest binary subsequence less than or equal to k binary string s positive integer length longest subsequence s makes up binary less than or equal subsequence can contain leading empty string considered equal subsequence string can derived another string deleting some or no characters without changing order remaining s k longest subsequence s makes up binary less than or equal this equal note also which equal length this subsequence so s k longest subsequence s makes up binary less than or equal this equal length this subsequence so either or k
verify preorder serialization of a binary tree one way serialize binary tree use preorder when we encounter we record null we record using sentinel value such above binary tree can serialized string where represents null string values true correct preorder traversal serialization binary guaranteed each value string must either integer or character representing null may assume input format always could never contain two consecutive such not allowed reconstruct preorder true preorder false preorder false preorder consist integers range separated commas
the score of students solving math expression string s contains digits addition symbols multiplication symbols representing valid math expression single digit numbers this expression elementary school students instructed get answer expression following this order compute reading left compute reading left integer array answers length which submitted answers students no particular asked grade following these answer equals correct answer this student rewarded answer could interpreted student applied operators wrong order but had correct this student rewarded this student rewarded sum points s answers illustrated correct answer expression therefore one student rewarded student might have applied operators this wrong therefore one student rewarded points students sum points s answers correct answer expression therefore three students rewarded points student might have applied operators this wrong therefore two students rewarded points students sum points s answers correct answer expression student had incorrectly done answer would also rules students still rewarded points they got correct not points students sum points s represents valid expression contains only digits all integer operands expression inclusive range count all operators math expression test data generated such correct answer expression range
power of heroes integer array nums representing strength some power group heroes defined let indices heroes power this group sum power all groups heroes since sum could very modulo nums power power power power power power power sum powers all groups nums total groups power each group sum powers all groups
subdomain visit count website domain consists various top we have next we have lowest when we visit domain like we also visit parent domains domain domain one two formats or where rep visits domain domain domain indicates visited array domains array domains each subdomain may answer any cpdomains we only have one website discussed subdomain also so they all visited cpdomains we visit once we visit follows either format or repi integer range consist lowercase english
decode ways message containing letters can encoded into numbers using following decode encoded all digits must grouped then mapped back into letters using reverse mapping above may multiple can mapped grouping grouping note grouping invalid because cannot mapped into since different string s containing only ways decode test cases generated so answer fits s could decoded or s could decoded or s cannot mapped because leading zero different s contains only digits may contain leading
maximum repeating substring string string word word concatenated k times substring maximum value highest value k where word word not substring maximum value strings sequence maximum value word sequence word substring sequence word substring not substring sequence word not substring sequence word contains only lowercase english
find k closest elements sorted integer array two integers k k closest integers x result should also sorted ascending integer closer x than integer b or b arr k x arr k x k arr sorted ascending x
maximum absolute sum of any subarray integer array absolute sum subarray maximum absolute sum any subarray note defined x negative then x then nums subarray absolute sum nums subarray absolute sum
maximize win from two segments there some prizes integer array prizepositions sorted where position ith there could different prizes same position also integer allowed select two segments integer length each segment must collect all prizes whose position falls within least one two selected segments endpoints two selected segments may k can choose segments win any prize i satisfies or maximum prizes can win choose two segments prizepositions k this can win all prizes selecting two segments prizepositions k this one choice segments able get k prizepositions sorted
shortest subarray with sum at least k integer array nums integer length shortest subarray nums sum least there no such subarray contiguous part nums k nums k nums k k
number of operations to make network connected there computers numbered connected ethernet cables connections forming network where represents connection between computers ai any computer can reach any other computer directly or indirectly through initial computer network can extract certain cables between two directly connected place them between any pair disconnected computers make them directly minimum times need do this order make all computers not connections remove cable between computer place between computers connections connections there not enough bi ai bi there no repeated no two computers connected more than one
validate ip address string ip valid ip valid address or ip not correct ip any valid address ip form where xi xi cannot contain leading valid addresses while invalid valid address ip form xi hexadecimal string which may contain lowercase english letter english letters leading zeros allowed valid while invalid queryip this valid queryip this valid queryip this neither address nor queryip consists only english digits characters
1-bit and 2-bit characters we have two special first character can represented one bit second character can represented two bits or binary array bits ends true last character must bits true only way decode character so last character bits false only way decode character so last character not either or
remove k digits string num representing integer integer smallest possible integer after removing k digits num k remove three digits form new which num k remove leading note output must not contain leading num k remove all digits left nothing which k num consists only num does not have any leading zeros except zero
binary tree pruning root binary same tree where every subtree not containing been subtree node node node plus every node descendant root only red nodes satisfy property subtree not containing diagram right represents root root nodes tree range either or
can convert string in k moves two strings s your goal convert s into t k moves or during ith i move choose any index j such j j not been chosen any previous shift character index i do shifting character means replacing next letter alphabet around so becomes shifting character i means applying shift operations i remember any index j can picked most true possible convert s into t no more than k otherwise s t k true we shift times get move we shift get s t k false we need shift each character s one time convert into we can shift during there no way shift other characters remaining moves obtain t s t k true we shift first time get we shift second times get k t contain only lowercase english
calculate digit sum of a string string s consisting digits integer round can completed length s greater than one do divide s into consecutive groups size k such first k characters first next k characters second so note size last group can smaller than replace each group s string representing sum all replaced because merge consecutive groups together form new length string greater than repeat step s after all rounds have been s k first we divide s into groups size then we calculate digit sum each s becomes after first second we divide s into then we calculate digit sum each s becomes after second so we s k we divide s into then we calculate digit sum each s becomes whose length equal so we k s consists digits
construct k palindrome strings string s integer true can use all characters s construct k palindrome strings or false s k true can construct two palindromes using all characters some possible constructions s k false impossible construct palindromes using all characters s k true only possible solution put each character separate s consists lowercase english k
minimum number of operations to reinitialize a permutation even integer initially have permutation perm size where i one create new array each i then i then then assign arr minimum operations need perform perm permutation initial perm after perm so takes only perm after perm after perm so takes only
maximum number of removable characters two strings s p where p subsequence also distinct integer array removable containing subset indices s also want choose integer k k such after removing k characters s using first k indices p still subsequence more mark character each i then remove all marked characters check p still maximum k can choose such p still subsequence s after subsequence string new string generated original string some characters deleted without changing relative order remaining s p removable after removing characters indices becomes subsequence we remove characters indices becomes no longer maximum k s p removable after removing character index becomes subsequence s p removable remove first index array no longer p subsequence s p both consist lowercase english elements removable
longest absolute file path suppose we have file system stores both files one system represented following we have dir only directory dir contains two contains file subdirectory contains subdirectory which contains file text looks like this representing tab dir we write this representation look like note tab every file directory unique absolute path file which order directories must opened reach all concatenated using above absolute path each directory name consists each file name form where name extension consist string input representing file system explained length longest absolute path file abstracted file there no file note testcases generated such file system valid no file or directory name length input we have only one absolute path length input we have two length length we since longest absolute path input we do not have any just single directory named input may contain lowercase or uppercase english new line character tab character dot space all file directory names have positive
number of equivalent domino pairs list equivalent only either c b or d b one domino can rotated equal another pairs which i j equivalent dominoes dominoes
count salary categories sql schema accounts column name type int income int primary key this each row contains information about monthly income one bank write sql query report bank accounts each salary salary categories all salaries strictly less than all salaries inclusive range all salaries strictly greater than result table must contain all three there no accounts then report result table any query result format following accounts income category low salary average salary high salary low account average no high accounts
find minimum time to finish all jobs integer array where amount time takes complete ith there k workers can assign jobs each job should assigned exactly one working time worker sum time takes complete all jobs assigned your goal devise optimal assignment such maximum working time any worker minimum possible maximum working time any jobs k assigning each person one maximum time jobs k assign jobs following worker time worker time maximum working time k
design a stack with increment operation design stack supports increment operations implement customstack initializes object maxsize which maximum elements void adds x top stack stack not reached int pops returns top stack or stack void int increments bottom k elements stack there less than k elements increment all elements input output explanation customstack stk new stack empty stack becomes stack becomes top stack stack becomes stack becomes stack becomes stack still do not add another elements size stack becomes stack becomes top stack stack becomes top stack stack becomes top stack stack becomes stack empty k val most calls made each method push pop each
largest combination with bitwise and greater than zero bitwise array nums bitwise all integers nums bitwise equal nums bitwise array positive integers evaluate bitwise every combination numbers each candidates may only used once each size largest combination candidates bitwise greater than candidates combination bitwise size combination can shown no combination size greater than bitwise greater than note more than one combination may have largest combination bitwise candidates largest combination bitwise size combination so we
count number of pairs with absolute difference k integer array nums integer pairs where i j such value defined x x x nums k pairs absolute difference nums k there no pairs absolute difference nums k pairs absolute difference k
can place flowers have long flowerbed which some plots some flowers cannot planted adjacent integer array flowerbed containing where means empty means not integer true new flowers can planted flowerbed without violating rule false flowerbed true flowerbed false or there no two adjacent flowers
minimum operations to make a subsequence array target consists distinct integers another integer array arr can have one can insert any integer any position arr can add middle make note can insert integer very beginning or end minimum operations needed make target subsequence subsequence array new array generated original array deleting some elements without changing remaining relative subsequence underlined while target arr can add such way makes arr then target subsequence target arr target contains no
largest divisible subset set distinct positive integers largest subset answer such every pair elements this subset or there multiple any nums also nums all integers nums
number of ways to split array integer array nums length nums contains valid split index i following sum first i elements greater than or equal sum last i there least one element right i valid splits nums there three ways splitting nums into two split nums index first part sum second part sum since i valid split nums index first part sum second part sum since i valid split nums index first part sum second part sum since i not valid valid splits nums nums there two valid splits split nums index first part sum second part sum since i valid split nums index first part sum second part sum since i valid
number of good ways to split a string string split called good can split s into two strings sleft sright where their concatenation equal s sleft sright distinct letters sleft sright good splits can make s there ways split them left string right string contains different letters left string right string contains different letters left string right string contains different letters respectively left string right string contains different letters respectively left string right string contains different letters s split string follows s consists only lowercase english
all possible full binary trees integer list all possible full binary trees each node each tree answer must have each element answer root node one possible may final list trees any full binary tree binary tree where each node exactly or
utf-8 validation integer array data representing whether valid encoding translates sequence valid encoded character can bytes subjected following first bit followed unicode first bits all bit followed bytes most significant bits being this how encoding would bytes octet sequence x denotes bit binary form byte may either or input array only least significant bits each integer used store this means each integer represents only byte data true data represents octet valid encoding character followed data false data represented octet first bits all bit means next byte continuation byte which starts but second continuation byte does not start so
group the people given the group size they belong to there people split into some unknown each person labeled unique id integer array where size group person i then person must group size list groups such each person i group size each person should appear exactly one every person must there multiple any guaranteed there least one valid solution groupsizes first group size second group size third group size other possible solutions groupsizes
short encoding of words valid encoding array words any reference string s array indices indices such reference string s ends each index substring s starting up not next character equal array length shortest reference string s possible any valid encoding words valid encoding would s indices substring s starting next underlined substring s starting next underlined substring s starting next underlined words valid encoding would s indices consists only lowercase
smallest k-length subsequence with occurrences of a letter string integer letter integer lexicographically smallest subsequence s length k letter letter appear least repetition test cases generated so letter appears s least repetition subsequence string can derived another string deleting some or no characters without changing order remaining string lexicographically smaller than string b first position where b string letter appears earlier alphabet than corresponding letter s k letter repetition there four subsequences length have letter appear least lexicographically smallest subsequence among them s k letter repetition lexicographically smallest subsequence length letter appear least s k letter repetition only subsequence length letter appear least repetition k s consists lowercase english letter lowercase english appears s least repetition
minimum time to remove all cars containing illegal goods binary string s which represents sequence train denotes ith car does not contain illegal goods denotes ith car does contain illegal train would like get rid all cars containing illegal can do any following three operations any remove train car left end remove which takes unit remove train car right end remove which takes unit remove train car anywhere sequence which takes units minimum time remove all cars containing illegal note empty sequence cars considered have no cars containing illegal s one way remove all cars containing illegal goods sequence remove car left end time taken remove car right time taken remove car containing illegal goods found time taken this obtains total time alternative way remove car left end time taken remove car right end time taken this also obtains total time minimum time taken remove all cars containing illegal there no other ways remove them less s one way remove all cars containing illegal goods sequence remove car left end time taken this obtains total time another way remove all cars containing illegal goods sequence remove car containing illegal goods found time taken this obtains total time another way remove all cars containing illegal goods sequence remove car right end time taken this obtains total time minimum time taken remove all cars containing illegal there no other ways remove them less either or
determine the winner of a bowling game two integer arrays represent pins player player hit bowling bowling game consists pins each turn exactly assume player hit xi pins ith value ith turn player player hit pins any previous two score player sum values their score player more than score player score player more than score player case score score score more than score answer score score score more than score answer score score score equals score there answer
subarray with elements greater than varying threshold integer array nums integer find any subarray nums length k such every element subarray greater than threshold size any such there no such subarray contiguous sequence elements within nums threshold subarray size every element greater than note this only valid nums threshold subarray size so note subarray size every element greater than subarrays also satisfy or may also threshold
split array with same average integer array should move each element nums into one two arrays b such b true possible achieve false note array sum all elements arr over length nums true we can split array into both them have average nums false
unique binary search trees ii integer all structurally unique search which exactly nodes unique values answer any
count good triplets in an array two arrays length both which permutations good triplet set distinct values which present increasing order position both other we consider index value v index value v then good triplet set where z such total good there triplets such they out those only triplet satisfies there only good good triplets permutations
validate stack sequences two integer arrays pushed popped each distinct true this could have been result sequence push pop operations initially empty or false pushed popped true we might do following pushed popped false cannot popped before all elements pushed popped permutation
reverse odd levels of binary tree root perfect binary reverse node values each odd level suppose node values level then should become root reversed binary tree perfect all parent nodes have two children all leaves same level node edges along path between root root tree only one odd nodes level which reversed become root nodes level which reversed become root odd levels have nodes level after nodes level after nodes tree range root perfect binary
find a value of a mysterious function closest to target winston above mysterious function integer array arr integer target wants find values l r make value minimum minimum possible value notice func should called values l r where r arr target calling func all pairs winston got following results value closest thus minimum difference arr target winston called func all possible values always got thus min difference arr target target
running sum of 1d array array we define running sum array running sum nums running sum obtained nums running sum obtained nums
number of pairs of strings with concatenation equal to target array digit strings nums digit string pairs indices i such concatenation equals nums target valid pairs nums target valid pairs nums target valid pairs target consist target do not have leading
count triplets that can form two arrays of equal xor array integers we want select three indices j k where i j k define b b note denotes triplets j where arr triplets arr
count and say sequence sequence digit strings defined recursive way would digit string which then converted into different digit determine how digit split into minimal substrings such each substring contains exactly one unique then each say then say concatenate every said saying conversion digit string positive integer nth term this base say one say two say one one
random pick with weight array positive integers w where describes weight ith need implement function which randomly picks index range returns probability picking index i w probability picking index probability picking index input output explanation solution solution new only option since there only one element input output explanation solution solution new returning second element probability returning first element probability since this randomization multiple answers all following outputs can considered so pickindex called most
build array from permutation permutation nums build array ans same length where each i permutation nums array distinct integers nums array ans built ans nums array ans built ans elements nums can solve without using extra space
minimum height trees tree undirected graph which any two vertices connected exactly one other any connected graph without simple cycles tree nodes labelled array edges where indicates there undirected edge between two nodes ai bi can choose any node tree when select node x result tree height among all possible rooted those minimum height called minimum height trees list all root can answer any height rooted tree edges longest downward path between root edges height tree when root node label which only edges bi ai bi all pairs input guaranteed tree there no repeated
average selling price sql schema prices column name type int date date price int primary key this each row this table indicates price period each there no two overlapping means there no two intersecting periods same unitssold column name type int date units int there no primary key this may contain each row this table indicates each product write sql query find average selling price each should rounded decimal result table any query result format following prices price unitssold units average selling price total price product products average selling price product average selling price product
word search ii m x board characters list strings all words each word must constructed letters sequentially adjacent where adjacent cells horizontally or vertically same letter cell may not used more than once board words board words m lowercase english consists lowercase english all strings words
build an array with stack operations integer array target integer have empty stack two following pushes integer top removes integer top also have stream integers range use two stack operations make numbers stack bottom equal should follow following stream integers not pick next integer stream push top stack not pop integer top any elements stack bottom equal do not read new integers stream do not do more operations stack operations needed build target following mentioned there multiple valid any target initially stack s last element top read stream push s read stream push s pop integer top s read stream push s target initially stack s last element top read stream push s read stream push s read stream push s target initially stack s last element top read stream push s read stream push s since stack bottom equal we stop stack answers read integer stream not target strictly
insert delete getrandom o(1) - duplicates allowed randomizedcollection data structure contains collection possibly duplicates should support inserting removing specific elements also reporting random implement randomizedcollection initializes empty randomizedcollection bool inserts item val into even item already returns true item not false bool removes item val multiset returns true item false note val multiple occurrences we only remove one int returns random element current multiset probability each element being returned linearly related same values multiset must implement functions class such each function works average time test cases generated such getrandom only called there least one item input output explanation randomizedcollection randomizedcollection new true since collection does not contain inserts into false since collection contains inserts another into collection now contains true since collection does not contain inserts into collection now contains getrandom probability or probability true since collection contains removes collection now contains getrandom should or both equally val most calls total made there least one element data structure when getrandom
check if array is sorted and rotated array true array originally sorted then rotated some positions there may duplicates original array rotated x positions results array b same length such where modulo nums true original sorted can rotate array x positions begin element value nums false there no sorted array once rotated can make nums true original sorted can rotate array x positions no make
minimum time to type word using special typewriter there special typewriter lowercase english letters arranged circle character can only typed pointer pointing pointer initially pointing character each may perform one following move pointer one character counterclockwise or type character pointer currently string minimum seconds type out characters word characters printed type character second since pointer initially move pointer clockwise type character move pointer clockwise type character word characters printed move pointer clockwise type character move pointer counterclockwise type character move pointer clockwise type character word characters printed move pointer counterclockwise type character move pointer clockwise type character move pointer clockwise type character move pointer counterclockwise type character word consists lowercase english
diagonal traverse ii integer array all elements nums diagonal order shown below nums nums
unique length-3 palindromic subsequences string unique palindromes length three subsequence note even there multiple ways obtain same still only counted palindrome string reads same forwards subsequence string new string generated original string some characters deleted without changing relative order remaining subsequence s palindromic subsequences length s there no palindromic subsequences length s palindromic subsequences length s consists only lowercase english
take k of each character from left and right string s consisting characters integer each may take either leftmost character or rightmost character minimum minutes needed take least k each or not possible take k each s k take three characters left now have two one take five characters right now have four two two total minutes can proven minimum minutes s k not possible take one or so s consists only letters k
break a palindrome palindromic string lowercase english letters replace exactly one character any lowercase english letter so resulting string not palindrome lexicographically smallest one resulting there no way replace character make not empty string lexicographically smaller than string b same first position where b character strictly smaller than corresponding character lexicographically smaller than because first position they differ fourth smaller than palindrome there many ways make not such all lexicographically palindrome there no way replace single character make not so empty palindrome consists only lowercase english
smallest rotation with highest score array can rotate integer k so array becomes any entries less than or equal their index worth one we have nums we rotate k becomes this worth points because rotation index k corresponds highest score we can achieve we rotated nums there multiple smallest such index nums scores each k listed k nums score k nums score k nums score k nums score k nums score so we should choose k which highest nums nums always have points no matter how so we choose smallest which
sum of numbers with units digit k two integers num consider set positive integers following units digit each integer sum integers minimum possible size such or no such set set can contain multiple instances same sum empty set considered units digit rightmost digit num k one valid set sum each integer units digit another valid set can shown minimum possible size valid num k not possible obtain sum using only integers have units digit num k sum empty set considered num k
linked list components head linked list containing unique integer values integer array nums subset linked list connected components nums where two values connected they appear consecutively linked head nums so two connected head nums so two connected nodes linked list all values all values nums
split a string into the max number of unique substrings string maximum unique substrings string can split can split string s into any list where concatenation substrings forms original must split substrings such all them substring contiguous sequence characters within s one way split maximally splitting like not valid have multiple s one way split maximally s impossible split string any s contains only lower case english
clone graph reference node connected undirected deep copy each node graph contains value list class node public int public test case each value same index first node val second node val so graph represented test case using adjacency adjacency list collection unordered lists used represent finite each list describes set neighbors node node always first node val must copy node reference cloned adjlist there nodes node neighbors node node node neighbors node node node neighbors node node node neighbors node node adjlist note input contains one empty graph consists only one node val does not have any adjlist this empty does not have any nodes graph range unique each there no repeated edges no graph connected all nodes can visited starting
palindrome partitioning string partition s such every substring partition palindrome all possible palindrome partitioning s s s contains only lowercase english
sum of mutated array closest to target integer array arr target value integer value such when we change all integers larger than value array equal sum array gets close possible absolute case minimum such notice answer not neccesarilly arr target when using arr converts which sums optimal arr target arr target target
gas station there gas stations along circular where amount gas ith station have car unlimited gas tank costs gas travel ith station next begin journey empty tank one gas two integer arrays gas starting gas index can travel around circuit once clockwise otherwise there exists guaranteed unique gas cost start station fill up unit your tank travel station your tank travel station your tank travel station your tank travel station your tank travel station cost your gas just enough travel back station starting gas cost start station or there not enough gas travel next start station fill up unit your tank travel station your tank travel station your tank cannot travel back station requires unit gas but only have travel around circuit once no matter where
reaching points four integers true possible convert point point through some or false allowed operation some point convert either x or sx sy tx ty true one series moves transforms starting point target sx sy tx ty false sx sy tx ty true ty
all nodes distance k in binary tree root binary value target node integer array values all nodes have distance k target can answer any root target k nodes distance target node value have values root target k nodes tree range all values target value one nodes k
maximum sum obtained of any permutation we have array array requests where ith request asks sum both starti endi maximum total sum all requests among all permutations since answer may too modulo nums requests one permutation nums following total permutation higher total sum following total which best can nums requests permutation max total sum request sums nums requests permutation max total sum request sums starti endi
rearrange words in a sentence sentence text sentence string following first letter upper each word text separated single your task rearrange words text such all words rearranged increasing order their two words have same arrange them their original new text following format shown text cool there length length length output ordered length new first word starts capital text calm code keep calm output ordered letters case tie order position original text or not or text begins capital letter then contains lowercase letters single space between
recover a tree from preorder traversal we run preorder search root binary each node this we output d dashes d depth this then we output value this depth node depth immediate child d depth root node node only one child guaranteed left output traversal this recover tree traversal traversal traversal nodes original tree range
minimize the maximum of two arrays we have two arrays which initially need add positive integers them such they satisfy all following contains distinct positive each which not divisible contains distinct positive each which not divisible no integer present both minimum possible maximum integer can present either we can distribute first natural numbers into we can see both arrays satisfy all since maximum value we here satisfy all since maximum value we final possible arrays can can shown not possible obtain lower maximum satisfying all
two city scheduling company planning interview array costs where cost flying ith person city cost flying ith person city b minimum cost fly every person city such exactly people arrive each costs first person goes city cost second person goes city cost third person goes city b cost fourth person goes city b cost total minimum cost have half people interviewing each costs costs bcosti
making a large island x binary matrix allowed change most one size largest island grid after applying this island connected group grid change one connect two then we get island area grid change make island only one island area grid change any only one island area either or
k-th smallest prime fraction sorted integer array arr containing prime where all integers arr also integer every i j where i j we consider fraction kth smallest fraction your answer array integers size where arr k fractions considered sorted order third fraction arr k prime i all numbers arr unique sorted strictly increasing k follow can solve problem better than
check if number is a sum of powers of three integer true possible represent sum distinct powers integer y power three there exists integer x such y true true false
next greater element ii circular integer array nums next element next greater every element next greater x first greater next which means could search circularly find next greater this nums first next greater find next greater second next greater needs search which also nums
complete binary tree inserter complete binary tree binary tree which every except possibly completely all nodes far left design algorithm insert new node complete binary tree keeping complete after implement cbtinserter initializes data structure root complete binary int inserts treenode into tree value val so tree remains returns value parent inserted treenode returns root node input output explanation cbtinserter cbtinserter new nodes tree range root complete binary val most calls made insert
maximum sum circular subarray circular integer array nums length maximum possible sum subarray circular array means end array connects beginning next element previous element subarray may only include each element fixed buffer nums most subarray there does not exist i j nums subarray maximum sum nums subarray maximum sum nums subarray maximum sum
lowest common ancestor of a binary search tree binary search tree find lowest common ancestor node two nodes according definition lca lowest common ancestor defined between two nodes p q lowest node t both p q descendants we allow node descendant root p q lca nodes root p q lca nodes since node can descendant itself according lca root p q nodes tree range all p q p q exist
degree of an array array integers degree this array defined maximum frequency any one your task find smallest possible length subarray same degree nums input array degree because both elements appear subarrays have same shortest length so nums degree because element repeated so shortest therefore returning between integer between
reward top k students two string arrays containing words denoting positive negative note no word both positive initially every student each positive word feedback report increases points student whereas each negative word decreases points feedback represented string array report integer array where represents id student who received feedback report id each student integer top k students after ranking them order their case more than one student same one lower id ranks report student student k both students have positive feedback points but since student lower id ranks report student not student k student id positive feedback negative so student id positive so since student more both consists lowercase english no word present both consists lowercase english letters spaces there single space between consecutive words all values k
tuple with same product array nums distinct positive tuples such b c d where d elements b c nums there valid nums there valid all elements nums
find target indices after sorting array integer array nums target element target index index i such list target indices nums after sorting nums there no target empty returned list must sorted increasing nums target after nums indices where nums target after nums index where nums target after nums index where target
minimum operations to make the array alternating array nums consisting positive array nums called alternating where i where i one can choose index i change into any positive minimum operations required make array nums one way make array alternating converting operations required this case can proven not possible make array alternating less than nums one way make array alternating converting operations required this case note array cannot converted because this case which violates conditions alternating
count number of maximum bitwise-or subsets integer array find maximum possible bitwise or subset nums different subsets maximum bitwise array subset array b can obtained b deleting some elements two subsets considered different indices elements chosen bitwise or array equal or or or nums maximum possible bitwise or subset there subsets bitwise or nums all subsets have bitwise or there total nums maximum possible bitwise or subset there subsets bitwise or
word subsets two string arrays string b subset string every letter b occurs including subset but not subset string universal every string b b subset array all universal strings may answer any consist only lowercase english all strings
classes more than 5 students sql schema courses column name type student varchar class varchar primary key column this each row this table indicates name student class which they write sql query report all classes have least five result table any query result format following courses student class math b english c math d biology e math f computer g math h math i math class math math so we include english so we do not include biology so we do not include computer so we do not include
new 21 game alice plays following loosely based card game alice starts points draws numbers while she less than k during each she gains integer points randomly range where maxpts each draw independent outcomes have equal alice stops drawing numbers when she gets k or more probability alice or fewer answers within actual answer considered k maxpts alice gets single then k maxpts alice gets single then out she or below k maxpts k maxpts
maximum compatibility score sum there survey consists questions where each answer either or survey m students numbered m m mentors numbered m answers students represented integer array students where integer array contains answers ith student answers mentors represented integer array mentors where integer array contains answers jth mentor each student assigned one each mentor have one student assigned compatibility score pair answers same both student answers answers then their compatibility score because only second third answers tasked finding optimal pairings maximize sum compatibility students maximum compatibility score sum can students mentors we assign students mentors following student mentor compatibility score student mentor compatibility score student mentor compatibility score compatibility score sum students mentors compatibility score any pair m either or either or
meeting rooms iii integer there rooms numbered integer array meetings where means meeting held during time interval all values starti meetings allocated rooms following each meeting take place unused room lowest there no available meeting delayed until room becomes delayed meeting should have same duration original when room becomes meetings have earlier original start time should room held most there multiple room lowest interval interval between b including not including meetings time both rooms not being first meeting starts room time only room not being second meeting starts room time both rooms being third meeting time both rooms being fourth meeting time meeting room third meeting starts room time period time meetings both rooms fourth meeting starts room time period both rooms held so we meetings time all three rooms not being first meeting starts room time rooms not being second meeting starts room time only room not being third meeting starts room time all three rooms being fourth meeting time meeting room fourth meeting starts room time period time all three rooms being fifth meeting time meetings rooms fifth meeting starts room time period room held meeting while rooms each held so we starti endi all values starti
design movie rental system have movie renting company consisting want implement renting system supports searching returning system should also support generating report currently rented each movie integer array entries where indicates there copy movie moviei shop shopi rental price each shop carries most one copy movie system should support following finds cheapest shops have unrented copy shops should sorted price ascending case one smaller shopi should appear there less than matching then all them should no shop unrented then empty list should rents unrented copy movie drops off previously rented copy movie returns cheapest rented movies same movie list res where describes jth cheapest rented movie moviej rented shop movies res should sorted price ascending case one smaller shopj should appear there still one smaller moviej should appear there fewer than rented then all them should no movies currently being then empty list should implement movierentingsystem initializes movierentingsystem object shops movies returns list shops have unrented copy movie described void int rents movie void int drops off previously rented movie returns list cheapest rented movies described test cases generated such rent only called shop unrented copy drop only called shop had previously rented out input output explanation movierentingsystem movierentingsystem new movies id unrented shops shop shop same so order shop rent movie shop unrented movies shop now rent movie shop unrented movies shop now movie shop followed movie shop drop off movie shop unrented movies shop now movies id unrented shops shop followed shop shopi pricei each shop carries most one copy movie most calls total made drop
closest subsequence sum integer array nums integer want choose subsequence nums such sum elements closest possible sum elements then want minimize absolute difference minimum possible value note subsequence array array formed removing some elements all or original nums goal choose whole array sum this equal so absolute difference nums goal choose subsequence sum absolute difference which nums goal goal
remove all adjacent duplicates in string string s consisting lowercase english duplicate removal consists choosing two adjacent equal letters removing we repeatedly make duplicate removals s until we no longer final string after all such duplicate removals have been can proven answer s we could remove since letters adjacent this only possible result this move string which only so final string s s consists lowercase english
design a text editor design text editor cursor can do add text where cursor delete text where cursor backspace move cursor either left or when deleting only characters left cursor cursor also remain within actual text cannot moved beyond more we have always implement texteditor initializes object empty void appends text where cursor cursor ends right int deletes k characters left returns characters actually string moves cursor left k returns last characters left where len characters left string moves cursor right k returns last characters left where len characters left input output explanation texteditor texteditor new current text character represents current text current text characters current text current text cursor cannot moved beyond actual text thus did not last characters left current text last characters left current text only characters current text cursor cannot moved beyond actual text thus did not last characters left current text last characters left k text consists lowercase english most calls total made cursorleft could find solution time complexity per
climbing stairs climbing takes steps reach each time can either climb or how many distinct ways can climb there two ways climb step step steps there three ways climb step step step step steps steps step
recover binary search tree root binary search tree where values exactly two nodes tree swapped recover tree without changing root cannot left child because swapping makes bst root cannot right subtree because swapping makes bst nodes tree range follow solution using space pretty could devise constant space
longest continuous subarray with absolute diff less than or equal to limit array integers nums integer size longest subarray such absolute difference between any two elements this subarray less than or equal nums limit all subarrays maximum absolute diff maximum absolute diff maximum absolute diff maximum absolute diff maximum absolute diff maximum absolute diff maximum absolute diff maximum absolute diff maximum absolute diff maximum absolute diff size longest subarray nums limit subarray longest since maximum absolute diff nums limit limit
flood fill image represented m x integer grid image where represents pixel value also three integers should perform flood fill image starting pixel perform flood consider starting plus any pixels connected starting pixel same color starting plus any pixels connected those pixels same so replace color all aforementioned pixels modified image after performing flood image sr sc color center image position red all pixels connected path same color starting pixel blue colored new note bottom corner not colored because not connected starting image sr sc color starting pixel already colored so no changes made m color sr m sc
single-threaded cpu tasks labeled represented integer array where means ith task available process enqueuetimei take processingtimei finish have cpu can process most one task time act following cpu idle there no available tasks cpu remains cpu idle there available cpu choose one shortest processing multiple tasks have same shortest processing choose task smallest once task cpu process entire task without cpu can finish task then start new one order which cpu process tasks events go time task available available tasks also time idle cpu starts processing task available tasks time task available available tasks time task available available tasks also time cpu finishes task starts processing task available tasks time task available available tasks time cpu finishes task starts processing task available tasks time cpu finishes task starts processing task available tasks time cpu finishes task becomes tasks events go time all tasks become available tasks also time idle cpu starts processing task available tasks time cpu finishes task starts processing task available tasks time cpu finishes task starts processing task available tasks time cpu finishes task starts processing task available tasks time cpu finishes task starts processing task available tasks time cpu finishes task becomes processingtimei
minimum time visiting all points there points integer coordinates minimum time seconds visit all points order can move according these can move vertically one move horizontally one or move diagonally units other move one unit vertically then one unit horizontally have visit points same order they appear allowed pass through points appear later but these do not count points one optimal path time seconds time seconds total time seconds points
palindrome linked list head singly linked true palindrome or false head true head false nodes list range follow could do time
check if all 1's are at least length k places away binary array nums integer true all least k places away each otherwise nums k true each least places away each nums k false second third only one apart each k or
binary trees with factors array unique where each integer strictly greater than we make binary tree using these each may used any each value should equal product values binary trees we can answer may too large so answer modulo arr we can make these arr we can make these all values arr
rearrange characters to make target string two strings s can take some letters s rearrange them form new maximum copies target can formed taking letters s rearranging s target first copy take letters indices second copy take letters indices strings formed which can both rearranged into we can make most two copies so we s target we can make one copy taking letters indices we can make most one copy so we note while there extra indices we cannot reuse letter index so we cannot make second copy s target we can make one copy taking letters indices we can make most one copy so we s target consist lowercase english
determine if two events have conflict two arrays strings represent two inclusive events happened same event times valid hours format form conflict happens when two events have some intersection some moment common both true there conflict between two true two events intersect time true two events intersect starting false two events do not all event times follow
longest increasing subsequence ii integer array nums integer find longest subsequence nums meets following subsequence strictly increasing difference between adjacent elements subsequence most length longest subsequence meets subsequence array can derived another array deleting some or no elements without changing order remaining nums k longest subsequence meets requirements subsequence length so we note subsequence does not meet requirements because larger than nums k longest subsequence meets requirements subsequence length so we nums k longest subsequence meets requirements subsequence length so we k
maximum product of three numbers integer array find three numbers whose product maximum maximum nums nums nums
add two numbers two linked lists representing two digits stored reverse each their nodes contains single add two numbers sum linked may assume two numbers do not contain any leading except nodes each linked list range guaranteed list represents does not have leading
di string match permutation perm integers all integers range can represented string s length string reconstruct permutation perm there multiple valid permutations any s s s either or
convert a number to hexadecimal integer string representing hexadecimal negative complement method all letters answer string should lowercase there should not any leading zeros answer except zero not allowed use any library method directly solve this num num num
partition array such that maximum difference is k integer array nums integer may partition nums into one or more subsequences such each element nums appears exactly one minimum subsequences needed such difference between maximum minimum values each subsequence most subsequence sequence can derived another sequence deleting some or no elements without changing order remaining nums k we can partition nums into two subsequences difference between maximum minimum value first subsequence difference between maximum minimum value second subsequence since two subsequences we can shown minimum subsequences nums k we can partition nums into two subsequences difference between maximum minimum value first subsequence difference between maximum minimum value second subsequence since two subsequences we note another optimal solution partition nums into two subsequences nums k we can partition nums into three subsequences difference between maximum minimum value first subsequences difference between maximum minimum value second subsequences difference between maximum minimum value third subsequences since three subsequences we can shown minimum subsequences k
concatenated words array strings words all concatenated words list concatenated word defined string comprised entirely least two shorter words necesssarily words can concatenated can concatenated can concatenated words consists only lowercase english all strings words
circular sentence sentence list words separated single space no leading or trailing world hello all words consist only uppercase lowercase english uppercase lowercase english letters considered sentence circular last character word equal first character next last character last word equal first character first exercises sound eats all circular like not circular string true sentence exercises sound true words sentence last character equal first last character equal first last character equal first last character equal first sentence sentence true words sentence last character equal first sentence sentence false words sentence last character not equal first sentence not sentence consist only lowercase uppercase english letters words sentence separated single there no leading or trailing
length of longest fibonacci subsequence sequence xn xi all i strictly increasing array arr positive integers forming length longest subsequence one does not subsequence derived another sequence arr deleting any elements without changing order remaining subsequence arr longest subsequence arr longest subsequence or
as far from land as possible x grid containing only values where represents water represents find water cell such distance nearest land cell no land or water exists distance used this problem manhattan distance between two cells grid cell far possible all land distance grid cell far possible all land distance or
transpose matrix integer array transpose transpose matrix matrix flipped over main switching row column matrix matrix m m
n-ary tree preorder traversal root preorder traversal input serialization represented their level order each group children separated null value root root nodes tree range height tree less than or equal follow recursive solution could do
rank transform of an array array integers replace each element rank represents how large element rank following rank integer starting larger larger two elements their rank must rank should small arr largest second third arr same elements share same arr
count number of homogenous substrings string homogenous substrings since answer may too modulo string homogenous all characters string substring contiguous sequence characters within s homogenous substrings listed appears appears appears appears appears appears appears s homogenous substrings s s consists lowercase
minimum remove to make valid parentheses string s lowercase english your task remove minimum parentheses or any positions so resulting parentheses string valid any valid parentheses string valid only empty contains only lowercase or can written ab concatenated where b valid or can written where valid s would also s s empty string also or lowercase english
minimum deletions to make array divisible two positive integer arrays nums can delete any elements minimum deletions such smallest element nums divides all elements this not note integer x divides y y x nums numsdivide smallest element which does not divide all elements we use deletions delete elements nums equal which makes nums smallest element which divides all elements can shown minimum deletions nums numsdivide we want smallest element nums divide all elements there no way delete elements nums allow
maximum star sum of a graph there undirected graph consisting nodes numbered integer array vals length where denotes value ith also integer array edges where denotes there exists undirected edge connecting nodes ai star graph subgraph graph having center node containing or more other subset edges graph such there exists common node all image below shows star graphs neighbors centered blue star sum sum values all nodes present star integer maximum star sum star graph containing most k vals edges k above diagram represents input star graph maximum star sum denoted centered includes neighbors can shown not possible get star graph sum greater than vals edges k there only one possible star which node we bi ai bi k
ipo suppose leetcode start ipo order sell good price shares venture leetcode would like work some projects increase capital before since limited can only finish most k distinct projects before help leetcode design best way maximize total capital after finishing most k distinct projects where ith project pure profit minimum capital needed start have w when finish obtain pure profit profit added your total pick list most k distinct projects projects maximize your final final maximized answer guaranteed fit signed k w profits capital since your initial capital can only start project indexed after finishing obtain profit your capital becomes capital can either start project indexed or project indexed since can choose most need finish project indexed get maximum output final maximized which k w profits capital k w
find resultant array after removing anagrams string array where consists lowercase english one select any index i such i delete keep performing this operation long can select index satisfies words after performing all can shown selecting indices each operation any arbitrary order lead same anagram word or phrase formed rearranging letters different word or phrase using all original letters exactly anagram words one ways we can obtain resultant array using following since we choose index delete now words since we choose index delete now words since we choose index delete now words we can no longer perform any so final words no two adjacent strings words anagrams each so no operations consists lowercase english
sort array by parity ii array integers half integers nums other half sort array so whenever i whenever i any answer array satisfies this nums would also have been nums half integers nums follow could solve
accounts merge list accounts where each element list where first element rest elements emails representing emails we would like merge these two accounts definitely belong same person there some common email both note even two accounts have same they may belong different people people could have same person can have any accounts but all their accounts definitely have same after merging accounts following first element each account rest elements emails sorted accounts themselves can returned any accounts first second same person they have common email third john mary different people none their email addresses used other we could these lists any answer would still accounts consists english j valid
removing minimum number of magic beans array positive integers where each integer represents magic beans found particular magic remove any beans each bag such beans each remaining bag containing least one once bean been removed not allowed any minimum magic beans have beans we remove bean bag only this results remaining then we remove beans bag this results remaining then we remove bean bag this results remaining we removed total beans make remaining bags have equal there no other solutions remove beans or beans we remove beans one bags this results remaining then we remove beans other bag this results remaining then we remove beans bag this results remaining we removed total beans make remaining bags have equal there no other solutions removes beans or
unique number of occurrences array integers true occurrences each value array unique or false arr true value no two values have same arr false arr true
count complete tree nodes root complete binary nodes according every except possibly completely filled complete binary all nodes last level far left can have between nodes inclusive last level design algorithm runs less than time root root root nodes tree range tree guaranteed
unique paths there robot m x robot initially located corner robot tries move corner robot can only move either down or right any point two integers m possible unique paths robot can take reach test cases generated so answer less than or equal m m there total ways reach right down down down down right down right down
map sum pairs design map allows do maps string key returns sum values have key prefix equal implement mapsum initializes mapsum void int inserts pair into key already original pair overridden new int returns sum all value whose key starts input output explanation mapsum mapsum new app key prefix consist only lowercase english val most calls made insert
move pieces to obtain a string two strings start both length each string consists only characters characters represent where piece can move left only there blank space directly piece can move right only there blank space directly character represents blank space can occupied any or true possible obtain string target moving pieces string start any start target true we can obtain string target start doing following move first piece one step start becomes equal move last piece one step start becomes equal move second piece three steps start becomes equal since possible get string target we start target false piece string start can move one step right obtain after no pieces can move so impossible obtain string target start target false piece string start can move only so impossible obtain string target start target consist characters
count the number of square-free subsets positive integer array subset array nums product elements integer integer divisible no square other than subsets array since answer may too modulo subset nums array can obtained deleting some none but not elements two subsets different only chosen indices delete nums there subsets this subset consisting element product elements which subset consisting element product elements which subset consisting elements product elements which can proven there no more than subsets nums there subset this subset consisting element product elements which can proven there no more than subset
get maximum in generated array integer integer array nums length generated following when i i when i maximum integer array according nums maximum according nums maximum according nums maximum
shortest impossible sequence of rolls integer array rolls length integer roll k sided dice numbered where result ith roll length shortest sequence rolls cannot taken sequence rolls length len result rolling k sided dice len note sequence taken does not have consecutive long rolls k every sequence rolls length can taken every sequence rolls length can taken sequence cannot taken so we note there other sequences cannot taken rolls k every sequence rolls length can taken sequence cannot taken so we note there other sequences cannot taken rolls but rolls k sequence cannot taken so we note there other sequences cannot taken rolls but k
course schedule there total numcourses courses have labeled numcourses array prerequisites where indicates must take course bi first want take course pair indicates take course have first take course true can finish all numcourses prerequisites true there total courses take course should have finished course so numcourses prerequisites false there total courses take course should have finished course take course should also have finished course so numcourses bi numcourses all pairs
flatten deeply nested array array arr depth flattened version array recursive data structure contains integers or other flattened array version array some or all removed replaced actual elements this flattening operation should only done current depth nesting less than depth elements first array considered please solve without input arr output explanation passing depth always result original this because smallest possible depth subarray not less than no subarray should input arr output explanation subarrays starting all this because their depth less than however remains unflattened because depth input arr output explanation maximum depth any subarray all them count numbers arr count subarrays arr maxdepth each
redundant connection ii this rooted tree directed graph such there exactly one node which all other nodes descendants this plus every node exactly one except root node which no input directed graph started rooted tree nodes distinct values one additional directed edge added edge two different vertices chosen not edge already resulting graph each element edges pair represents directed edge connecting nodes ui where ui parent child edge can removed so resulting graph rooted tree there multiple answer occurs last edges edges vi ui vi
range addition ii m x matrix m initialized all array operations where means should incremented one all x ai y count maximum integers matrix after performing all m ops maximum integer m there four so m ops m ops ai m bi
minimum index sum of two lists two arrays strings find common strings least index common string string appeared both common string least index sum common string such appeared then i j should minimum value among all other common all common strings least index answer any grill torrey hunter only common string common string least index sum index sum there three common index sum index sum index sum strings least index sum consist spaces english all strings all strings there least common string between
maximum side length of a square with sum less than or equal to threshold m x matrix mat integer maximum square sum less than or equal threshold or there no such mat threshold maximum side length square sum less than mat threshold m threshold
closest dessert cost would like make dessert preparing buy have ice cream base flavors m types toppings choose must follow these rules when making your there must exactly one ice cream can add one or more types topping or have no toppings there most two each type three integer array length where each represents price ith ice cream base integer array length where each price one ith integer representing your target price want make dessert total cost close target closest possible cost dessert there lower basecosts toppingcosts target consider following combination choose base cost take topping cost x take topping cost x basecosts toppingcosts target consider following combination choose base cost take topping cost x take topping cost x take topping cost x cannot make dessert total cost basecosts toppingcosts target possible make desserts cost lower m m target
maximum difference between increasing elements integer array nums size find maximum difference between such i j maximum no such i j nums maximum difference occurs i j note i j difference but i so not nums there no i j such i j nums maximum difference occurs i j
minimum number of swaps to make the string balanced string s even length string consists exactly opening brackets closing brackets string called balanced only empty or can written where both b balanced or can written where c balanced may swap brackets any two indices any minimum swaps make s s can make string balanced swapping index index resulting string s can do following make string swap index index s swap index index s resulting string s string already either or opening brackets equals closing brackets equals
remove all adjacent duplicates in string ii string s integer k duplicate removal consists choosing k adjacent equal letters s removing causing left right side deleted substring concatenate we repeatedly make k duplicate removals s until we no longer final string after all such duplicate removals have been guaranteed answer s k nothing s k first delete get then delete get finally delete get s k k s only contains lowercase english
maximum of absolute value expression two arrays integers equal maximum value where maximum taken over all j
convert bst to greater tree root binary search tree convert greater tree such every key original bst changed original key plus sum all keys greater than original key binary search tree tree satisfies these left subtree node contains only nodes keys less than right subtree node contains only nodes keys greater than both left right subtrees must also binary search root root nodes tree range all values tree root guaranteed valid binary search this question same
ambiguous coordinates we had some like or we removed all decimal spaces ended up string becomes s becomes s list strings representing all possibilities what our original coordinates could have our original representation never had extraneous so we never started numbers like or any other can represented fewer decimal point within never occurs without least one digit occurring before so we never started numbers like final answer list can returned any all coordinates final answer have exactly one space between them after s s or not s rest s
binary tree level order traversal ii root binary level order traversal left level level leaf root root root nodes tree range
maximize the topmost element after k moves integer array nums representing contents where topmost element one can perform either pile not remove topmost element there one or more removed add any one them back onto this element becomes new topmost also integer which denotes total moves maximum value topmost element pile possible after exactly k case not possible obtain pile after k nums k one ways we can end top pile after moves step remove topmost element pile becomes step remove topmost element pile becomes step remove topmost element pile becomes step add back onto pile becomes note this not only way end top can shown largest answer possible after nums k first our only option pop topmost element since not possible obtain pile after one we k
number of ways to reorder array to get same bst array nums represents permutation integers we going construct binary search tree inserting elements nums order into initially empty find different ways reorder nums so constructed bst identical formed original array nums we have left right array also yields same bst but yields different ways reorder nums such bst formed identical original bst formed since answer may very modulo nums we can reorder nums which yield same there no other ways reorder nums which yield same nums following arrays yield same nums there no other orderings nums yield same all integers nums
count integers with even digit sum positive integer positive integers less than or equal num whose digit sums digit sum positive integer sum all num only integers less than or equal whose digit sums even num integers less than or equal whose digit sums even num
separate the digits in an array array positive integers array answer consists digits each integer nums after separating them same order they appear separate digits integer get all digits same integer separation digits nums separation separation separation separation answer note answer contains separations same nums separation each integer nums answer
snail traversal write code enhances all arrays such can call method transforms array into array organised pattern known snail traversal invalid input values should output empty rowscount colscount input considered snail traversal order starts top left cell first value current then moves through entire first column top followed moving next column right traversing bottom this pattern alternating direction traversal each until entire current array when input array rowscount colscount desired output matrix shown note iterating matrix following arrows corresponds order numbers original nums rowscount colscount nums rowscount colscount nums rowscount colscount multiplied original array length input rowscount colscount
maximize score after n operations array positive integers size must perform operations this ith operation choose two x receive score i remove x y maximum score can receive after performing function greatest common divisor x nums optimal choice operations nums optimal choice operations nums optimal choice operations
best poker hand integer array ranks character array have cards where ith card rank suit following types poker hands can make best five cards same three cards same two cards same any single string representing best type poker hand can make note values ranks suits hand all cards consists cards same so we have ranks suits hand fourth card consists cards same so we have note we could also make hand but better also note other cards could used make ranks suits hand first second card consists cards same so we have note we cannot make or no two cards have same rank
count integers in intervals empty set implement data structure add interval set count integers present least one implement countintervals initializes object empty set void int adds interval set int returns integers present least one note interval denotes all integers x where left x input output explanation countintervals countintervals new initialize object empty set add set add set integers present interval integers present interval add set integers present interval integers present interval integers present intervals integers present interval left right most calls total made add least one call made
pyramid transition matrix stacking blocks form each block which represented single each row blocks contains one less block than row beneath centered make pyramid aesthetically there only specific triangular patterns triangular pattern consists single block stacked top two patterns list strings where first two characters pattern represent left right bottom blocks third character top represents triangular pattern block stacked top note this different where left bottom right start bottom row blocks single must use base bottom true can build pyramid all way top such every triangular pattern pyramid or false bottom allowed true allowed triangular patterns shown starting bottom we can build level then build level there three triangular patterns which all bottom allowed false allowed triangular patterns shown starting bottom there multiple ways build level but trying all get always stuck before building level letters all input strings set all values allowed
dota2 senate world there two radiant senate consists senators coming two now senate wants decide change voting this change each each senator can exercise one two ban one senator can make another senator lose all his rights this all following announce this senator found senators who still have rights vote all same can announce victory decide change string senate representing each party character represent radiant party dire then there size string procedure starts first senator last senator this procedure last until end all senators who have lost their rights skipped during suppose every senator smart enough play best strategy his own predict which party finally announce victory change output should or senate first senator comes radiant can just ban next right round second senator exercise any rights anymore since his right been round first senator can just announce victory since only guy senate who can senate first senator comes radiant can just ban next right round second senator exercise any rights anymore since his right been third senator comes dire can ban first right round round third senator can just announce victory since only guy senate who can either or
path in zigzag labelled binary tree infinite binary tree where every node two nodes labelled row odd numbered rows labelling left while even numbered rows labelling right label node this labels path root tree node label label label
minimum number of work sessions to finish the tasks there tasks assigned task times represented integer array tasks length where ith task takes hours work session when work most sessiontime consecutive hours then take should finish tasks way satisfies following start task work must complete same work can start new task immediately after finishing previous may complete tasks any tasks minimum work sessions needed finish all tasks following conditions tests generated such sessiontime greater than or equal maximum element tasks sessiontime can finish tasks two work first work finish first second tasks second work finish third task tasks sessiontime can finish tasks two work first work finish all tasks except last one second work finish last task tasks sessiontime can finish all tasks one work sessiontime
maximize the confusion of an exam teacher writing test denoting true denoting wants confuse students maximizing consecutive questions same answer trues or multiple falses string where original answer ith integer maximum times may perform following change answer key any question or set or maximum consecutive or answer key after performing operation most k answerkey k we can replace both make answerkey there four consecutive answerkey k we can replace first make answerkey we can replace second make answerkey both there three consecutive answerkey k we can replace first make answerkey we can replace second make answerkey both there five consecutive either or k
maximize the minimum powered city integer array stations length where represents power stations ith each power station can provide power every city fixed other range denoted then power station city i can provide power all cities j such r j note denotes absolute power city total power stations being provided power government sanctioned building k more power each which can built any have same range two integers r maximum possible minimum power additional power stations built note can build k power stations multiple stations r k one optimal ways install both power stations city so stations become city provided power city provided power city provided power city provided power city provided power so minimum power city since not possible obtain larger we stations r k can proved we cannot make minimum power city greater than r k
create binary tree from descriptions integer array descriptions where indicates parenti parent childi binary tree unique islefti then childi left child islefti then childi right child construct binary tree described descriptions test cases generated such binary tree descriptions root node node value since no resulting binary tree shown descriptions root node node value since no resulting binary tree shown childi islefti binary tree described descriptions
student attendance record ii attendance record student can represented string where each character signifies whether student or present record only contains following three any student eligible attendance award they meet both following student absent strictly fewer than days student never late or more consecutive integer possible attendance records length make student eligible attendance answer may very so modulo there records length eligible only not eligible because there absences need fewer than
sum of digits of string after convert string s consisting lowercase english integer convert s into integer replacing each letter position alphabet replace transform integer replacing sum repeat transform operation k times s k then resulting integer would following transform transform resulting integer after performing operations described s k operations transform thus resulting integer s k operations transform transform thus resulting integer s k k s consists lowercase english
crawler log folder leetcode file system keeps log each time some user performs change folder operations described move parent folder current already main remain same remain same move child folder named x folder guaranteed always list strings logs where operation performed user ith file system starts main then operations logs minimum operations needed go back main folder after change folder logs use this change folder operation times go back main logs logs contains lowercase english follows format described folder names consist lowercase english letters
maximum number of vowels in a substring of given length string s integer maximum vowel letters any substring s length vowel letters english s k substring contains vowel s k any substring length contains s k contain s consists lowercase english k
valid palindrome ii string true s can palindrome after deleting most one character s true s true could delete character s false s consists lowercase english
two sum iv - input is a bst root binary search tree integer true there exist two elements bst such their sum equal or false root k true root k false nodes tree range root guaranteed valid binary search k
number of ways to arrive at destination city consists intersections numbered roads between some inputs generated such can reach any intersection any other intersection there most one road between any two integer integer array roads where means there road between intersections ui vi takes timei minutes want know how many ways can travel intersection intersection shortest amount ways can arrive your destination shortest amount since answer may modulo roads shortest amount time takes go intersection intersection four ways get there minutes roads there only one way go intersection intersection takes vi timei ui vi there most one road connecting any two can reach any intersection any other
time to cross a bridge there k workers who want move boxes old warehouse new two integers integer array time size k x where warehouses separated river connected old warehouse right bank new warehouse left bank all k workers waiting left side move ith worker can cross bridge left bank right bank lefttorighti pick box old warehouse bridge pickoldi different workers can pick up their boxes cross bridge right bank left bank righttolefti put box new warehouse bridge putnewi different workers can put their boxes worker i less efficient than worker j either condition lefttorighti righttolefti lefttorightj righttoleftj lefttorighti righttolefti lefttorightj righttoleftj i j following rules regulate movement workers through bridge worker x reaches bridge while another worker y crossing x waits their side bridge worker waiting right side bridge gets cross more than one worker waiting right one lowest efficiency crosses bridge free no worker waiting right least one box remains old worker left side river gets cross more than one worker waiting left one lowest efficiency crosses instance time which last worker reaches left bank river after all boxes have been put new k time worker crosses bridge left bank right worker picks up box old worker crosses bridge right bank left worker puts box new whole process ends after we because problem asks instance time which last worker reaches left k time worker crosses bridge left bank right worker picks up box old worker crosses bridge left bank right worker picks up box old worker crosses bridge right bank left worker puts box new worker crosses bridge right bank left worker puts box new worker crosses bridge left bank right worker picks up box old worker crosses bridge right bank left worker puts box new whole process ends after we because problem asks instance time which last worker reaches left k k putnewi
difference between maximum and minimum price sum there exists undirected initially unrooted tree nodes indexed integer integer array edges length where indicates there edge between nodes ai bi each node associated integer array where price ith price sum path sum prices all nodes lying tree can rooted any node root your incurred cost after choosing root difference between maximum minimum price sum amongst all paths starting maximum possible cost amongst all possible root edges price diagram above denotes tree after rooting node first part shows path maximum price second part shows path minimum price first path contains nodes prices sum prices second path contains node price difference between maximum minimum price sum can proved maximum edges price diagram above denotes tree after rooting node first part shows path maximum price second part shows path minimum price first path contains nodes prices sum prices second path contains node price difference between maximum minimum price sum can proved maximum bi edges represents valid
minimum cost to merge stones there piles stones arranged ith pile move consists merging exactly k consecutive piles into one cost this move equal total stones these k minimum cost merge all piles stones into one stones k we start we merge cost we left we merge cost we left we merge cost we left total cost this minimum stones k after any merge there piles we merge so task stones k we start we merge cost we left we merge cost we left total cost this minimum k
sort items by groups respecting dependencies there items each belonging zero or one m groups where group item belongs equal item belongs no items groups zero group can have no item belonging sorted list items such items belong same group next each other sorted there some relations between these items where list containing all items should come before item sorted array left any solution there more than one solution empty list there no m group beforeitems m group beforeitems this same except needs before sorted m m i does not contain duplicates
rearrange spaces between words string text words placed among some each word consists one or more lowercase english letters separated least one guaranteed text contains least one rearrange spaces so there equal spaces between every pair adjacent words cannot redistribute all spaces place extra spaces meaning returned string should same length string after rearranging text this sentence there total spaces we can evenly divide spaces between text practice makes makes perfect there total spaces spaces plus extra we place this extra space end text consists lowercase english letters text contains least one
check if array pairs are divisible by k array integers arr even length integer we want divide array into exactly pairs such sum each pair divisible true can find way do or false arr k true pairs arr k true pairs arr k false can try all possible pairs see there no way divide arr into pairs each sum divisible k
watering plants want water plants your garden watering plants arranged row labeled left right where ith plant located x there river x can refill your watering can each plant needs specific amount water plants following water plants order left after watering current do not have enough water completely water next river fully refill watering cannot refill watering can initially river x takes one step move one unit integer array plants where amount water ith plant integer capacity representing watering can steps needed water all plants capacity start river full watering walk plant water watering can units walk plant water watering can unit since cannot completely water plant walk back river refill walk plant water watering can units since cannot completely water plant walk back river refill walk plant water steps needed plants capacity start river full watering water plants river water plant river water plant river water plant steps needed plants capacity have refill before watering each steps needed capacity
invalid tweets sql schema tweets column name type int content varchar primary key this this table contains all tweets social media write sql query find ids invalid tweet invalid characters used content tweet strictly greater than result table any query result format following tweets content vote biden let us make america great tweet length valid tweet length invalid
find players with zero or one losses integer array matches where indicates player winneri defeated player loseri list answer size list all players have not lost any list all players have lost exactly one values two lists should returned increasing should only consider players have played least one testcases generated such no two matches have same matches players have not lost any players each have lost one players each have lost two matches players have not lost any players each have lost two loseri winneri loseri all
minimum operations to make a uni-value grid integer grid size m x integer one can add x or subtract x any element grid grid where all elements minimum operations make grid not grid x we can make every element equal doing add x subtract x subtract x total operations grid x we can make every element equal grid x impossible make every element m m
minimum sideway jumps there lane road length consists points labeled frog starts point second lane wants jump point there could obstacles along array obstacles length where each describes obstacle lane point there no obstacles point there most one obstacle lanes each then there obstacle lane point frog can only travel point i point i same lane there not obstacle lane point i avoid frog can also perform side jump jump another lane they not same point there no obstacle new frog can jump lane point lane point minimum side jumps frog needs reach any lane point starting lane point there no obstacles points obstacles optimal solution shown arrows there side jumps note frog can jump over obstacles only when making side jumps shown point obstacles there no obstacles lane no side jumps obstacles optimal solution shown arrows there side
array wrapper create class arraywrapper accepts array integers this class should have two when two instances this class added together resulting value sum all elements both when function called comma separated string surrounded nums operation const new const new nums operation const obj new nums operation const new const new nums array passed constructor
handling sum queries after update two arrays array queries there three types query type flip values index l index both l r query type every index i set query type find sum elements array containing all answers third type queries after first query becomes after second becomes so answer third query queries after first remains so answer second query l r p
fair candy swap alice bob have different total two integer arrays alicesizes bobsizes where candies ith box candy alice candies jth box candy bob since they they would like exchange one candy box each so after they both have same total amount total amount candy person sum candies each box they integer array answer where candies box alice must candies box bob must there multiple may any one guaranteed least one answer alicesizes bobsizes alicesizes bobsizes alicesizes bobsizes alice bob have different total there least one valid answer
minimum number of frogs croaking string which represents combination string different multiple frogs can croak same so multiple minimum different frogs finish all croaks valid means frog printing five letters frogs have print all five letters finish string not combination valid croakoffrogs one frog yelling croakoffrogs minimum frogs first frog could yell second frog could yell later croakoffrogs string invalid combination different croakoffrogs either or
count of smaller numbers after self integer array integer array counts where smaller elements right nums right there smaller elements right there only smaller element right there smaller element right there smaller nums nums
minimum time to collect all apples in a tree undirected tree consisting vertices numbered which some apples their spend second walk over one edge minimum time seconds have spend collect all apples starting vertex coming back this edges undirected tree array where means exists edge connecting vertices ai there boolean array where true means vertex i does not have any edges hasapple figure above represents tree where red vertices have one optimal path collect all apples shown green edges hasapple figure above represents tree where red vertices have one optimal path collect all apples shown green edges hasapple ai bi
check array formation through concatenation array distinct integers arr array integer arrays where integers pieces your goal form arr concatenating arrays pieces any not allowed reorder integers each array true possible form array arr arr pieces true concatenate then arr pieces false even though numbers we cannot reorder arr pieces true concatenate then then integers arr integers pieces distinct we flatten pieces all integers this array
longest palindromic subsequence string find longest palindromic length subsequence sequence can derived another sequence deleting some or no elements without changing order remaining s one possible longest palindromic subsequence s one possible longest palindromic subsequence s consists only lowercase english
sum of total strength of wizards ruler have army wizards your integer array where denotes strength ith contiguous group wizards strengths form subarray total strength defined product following two strength weakest wizard total all individual strengths wizards sum total strengths all contiguous groups since answer may very modulo subarray contiguous sequence elements within strength following all contiguous groups total strength total strength total strength total strength total strength total strength total strength total strength total strength total strength sum all total strengths strength following all contiguous groups total strength total strength total strength total strength total strength total strength sum all total strengths
consecutive characters power string maximum length substring contains only one unique string power s substring length character s substring length character s consists only lowercase english
occurrences after bigram two strings first consider occurrences some text form second where second comes immediately after third comes immediately after array all words third each occurrence second text good girl she good first second text we rock first second text consists lowercase english letters all words text separated single first second consist lowercase english
count largest group integer each grouped according sum groups have largest there groups they grouped according sum digits numbers there groups largest there groups size
maximum subarray integer array find subarray largest nums subarray largest sum nums subarray largest sum nums subarray largest sum follow have figured out try coding another solution using divide conquer which more
masking personal information personal information string representing either email address or phone masked personal information using below email email address name consisting uppercase lowercase english followed followed domain consisting uppercase lowercase english letters dot somewhere middle first or last mask uppercase letters name domain must converted lowercase middle letters name all but first last must replaced asterisks phone phone formatted phone contains last digits make up local remaining make up country separation characters set separate above digits some mask phone remove all separation masked phone should have country code country code country code country code last digits local s s email name domain converted middle name replaced s s email name domain converted middle name replaced note even though still must have asterisks s s phone there so local digits country code resulting masked s either valid email or phone s s consists uppercase lowercase english letters exactly one symbol s phone s consists symbols
evaluate division array variable pairs equations array real numbers where represent equation ai bi each ai or bi string represents single also some where represents jth query where must find answer cj dj answers all single answer cannot input always may assume evaluating queries not result division zero there no equations values queries b b c queries c b e x x equations values queries equations values queries dj consist lower case english letters
shuffle an array integer array design algorithm randomly shuffle all permutations array should equally likely result implement solution initializes object integer array resets array original configuration returns returns random shuffling input output explanation solution solution new shuffle array any permutation must equally likely resets array back original configuration returns random shuffling array all elements nums most calls total made reset
maximum profit in job scheduling we have where every job scheduled done obtaining profit endtime profit maximum profit can take such there no two jobs subset overlapping time choose job ends time x able start another job starts time starttime endtime profit subset chosen first fourth time range we get profit starttime endtime profit subset chosen fourth fifth profit obtained starttime endtime profit
recover the original array alice had array arr consisting positive she chose arbitrary positive integer k created two new integer arrays lower higher following every index i where i every index i where i alice lost all three she remembers integers present arrays lower but not array each integer belonged help alice recover original array nums consisting where exactly integers present lower remaining original array case answer not any valid test cases generated such there exists least one valid array nums arr k we get lower higher combining lower higher gives us which permutation another valid possibility arr k lower higher nums arr k we get lower higher combining lower higher gives us which equal note arr cannot because only possible way obtain k this invalid since k must nums only possible combination arr k using we get lower higher test cases generated such there exists least one valid array
minimum impossible or integer array we say integer x expressible nums there exist some integers indexk which other integer expressible can written bitwise or some subsequence minimum positive integer not expressible nums already present we know since since not we nums we can show smallest not
maximum number of achievable transfer requests we have buildings numbered each building transfer some employees want change building they reside array requests where represents request transfer building fromi building all buildings so list requests achievable only each net change employee transfers this means employees leaving equal employees moving two employees leaving building one leaving building one leaving building there should two employees moving building one employee moving building one employee moving building maximum achievable requests see building we have employees x y both want move building building we have employees b they want move buildings building we have employee z they want move building building we have employee c they want move building building we have any we can achieve requests users x b swapping their we can achieve requests users z swapping places requests see building we have employee x they want stay same building building we have employee y they want move building building we have employee z they want move building we can achieve all requests toi
last person to fit in the bus sql schema queue column name type int varchar weight int turn int primary key column this this table information about all people waiting turn columns contain all numbers where rows turn determines order which people board where denotes first person board denotes last person weight weight person there queue people waiting board bus weight limit so there may some people who cannot write sql query find last person can fit bus without exceeding weight test cases generated such first person does not exceed weight query result format following queue weight turn alice bob alex john cena winston marie john cena folowing table ordered turn turn id name weight total weight alice alex john cena person marie bob winston
ugly number iii ugly positive integer divisible or four integers nth ugly b c ugly numbers b c ugly numbers b c ugly numbers c b c guaranteed result range
longest repeating character replacement string s integer can choose any character string change any other uppercase english can perform this operation most k length longest substring containing same letter can get after performing above s k replace two two or vice s k replace one middle form substring longest repeating which there may exists other ways achive this answer s consists only uppercase english k
3sum with multiplicity integer array integer tuples k such i j k answer can very modulo arr target enumerating values occurs occurs occurs occurs arr target occurs we choose one two arr target occured one time array so we target
binary tree preorder traversal root binary preorder traversal root root root nodes tree range follow recursive solution could do
check if there is a valid partition for the array integer array have partition array into one or more contiguous we call partition array valid each obtained subarrays satisfies one following subarray consists exactly equal subarray subarray consists exactly equal subarray subarray consists exactly consecutive increasing difference between adjacent elements subarray but subarray true array least one valid nums true array can partitioned into subarrays this partition so we nums false there no valid partition this
wiggle subsequence wiggle sequence sequence where differences between successive numbers strictly alternate between positive first difference one may either positive or sequence one element sequence two elements trivially wiggle wiggle sequence because differences alternate between positive not wiggle first not because first two differences second not because last difference subsequence obtained deleting some elements original leaving remaining elements their original integer array length longest wiggle subsequence nums entire sequence wiggle sequence differences nums there several subsequences achieve this one differences nums follow could solve this
stone game iv alice bob take turns playing alice starting there stones each player makes move consisting removing any square stones player cannot make loses positive integer true only alice wins game otherwise assuming both players play true alice can remove stone winning game because bob have any false alice can only remove after bob removes last one winning game true already perfect alice can win one removing stones
kth smallest product of two sorted arrays two sorted integer arrays well integer kth smallest product where i j k smallest products smallest product k smallest products smallest product k smallest products smallest product k
domino and tromino tiling have two types x domino shape tromino may rotate these integer ways tile x since answer may very modulo every square must covered two tilings different only there two adjacent cells board such exactly one tilings both squares occupied five different ways show
queries on number of points inside a circle array points where coordinates ith point multiple points can have same also array queries where describes circle centered radius each query compute points inside jth points border circle considered array where answer jth points queries points circles shown green red blue points queries points circles shown yi yj rj all coordinates follow could find answer each query better complexity than
remove colored pieces if both neighbors are the same color there pieces arranged each piece colored either or string colors length where color ith alice bob playing game where they take alternating turns removing pieces this alice moves alice only allowed remove piece colored both neighbors also colored she not allowed remove pieces colored bob only allowed remove piece colored both neighbors also colored not allowed remove pieces colored alice bob cannot remove pieces edge player cannot make move their player loses other player assuming alice bob play true alice or false bob colors true aaababb aababb alice moves she removes second left since only whose neighbors both now bob cannot make move his turn since there no whose neighbors both alice so colors false alice her turn there only two both edge so she cannot move her bob so colors false abbbbbbbaaa abbbbbbbaa alice moves her only option remove second last abbbbbbbaa abbbbbbaa next many options which piece can pick second she no more pieces she can bob so colors consists only letters
complex number multiplication complex can represented string form real real part integer range imaginary imaginary part integer range two complex numbers string complex represents their i need convert form i need convert form valid complex
calculate delayed arrival time positive integer arrivaltime denoting arrival time train another positive integer delayedtime denoting amount delay time when train arrive note time this problem arrivaltime delayedtime arrival time train delayed now reach arrivaltime delayedtime arrival time train delayed now reach denoted hours format so arrivaltime delayedtime
closest divisors integer find closest two integers absolute difference whose product equals num or num two integers any num num closest divisors num closest divisors hence num num num
add two integers two integers sum two their sum so so
row with maximum ones m x binary matrix find position row contains maximum count ones case there multiple rows have maximum count row smallest row should array containing index ones mat both rows have same so we index smaller maximum count ones answer mat row indexed maximum count ones so we answer mat row indexed maximum count ones so answer m either or
statistics from a large sample large sample integers range since sample so represented array count where times k appears calculate following minimum element maximum element average calculated total sum all elements divided total sample odd then median middle element once sample sample even then median average two middle elements once sample appears most guaranteed statistics sample array numbers answers within actual answer count sample represented count minimum maximum mean since size sample median average two middle elements which mode appears most count sample represented count minimum maximum mean display output shows rounded since size sample median middle element mode appears most mode sample count represents
the dining philosophers five silent philosophers sit round table bowls forks placed between each pair adjacent each philosopher must alternately think philosopher can only eat spaghetti when they have both left right each fork can held only one philosopher so philosopher can use fork only not being used another after individual philosopher finishes they need put down both forks so forks become available philosopher can take fork their right or one their left they become but cannot start eating before getting both eating not limited remaining amounts spaghetti or stomach infinite supply infinite demand design discipline behaviour concurrent such no philosopher each can forever continue alternate between eating assuming no philosopher can know when others may want eat or problem statement image above taken ids numbered clockwise implement function void philosopher id philosopher who wants pickleftfork pickrightfork functions can call pick corresponding forks eat function can call let philosopher eat once picked both putleftfork putrightfork functions can call put down corresponding forks philosophers assumed thinking long they not asking eat function not being called their five each representing simultaneously use one object your class simulate function may called same philosopher more than even before last call times each philosopher call output array describes calls made functions controlling forks eat format id b specifies c specifies
shifting letters ii string s lowercase english letters integer array shifts where every shift characters s index starti index endi forward directioni or shift characters backward directioni shifting character forward means replacing next letter alphabet around so becomes shifting character backward means replacing previous letter alphabet around so becomes final string after all such shifts s s shifts shift characters index index now s shift characters index index now s shift characters index index now s s shifts shift characters index index now s shift characters index index now s starti endi directioni s consists lowercase english
the earliest and latest rounds where players compete there tournament where players players standing single row numbered based their initial standing position first player player second player tournament consists multiple rounds round each ith player front row competes against ith player end winner advances next when players odd current player middle automatically advances next row consists players player competes against player player competes against player player automatically advances next after each round winners lined back up row based original ordering assigned them initially players numbered firstplayer secondplayer best they can win against any other player before they compete against each any two other players compete against each either them might thus may choose outcome this integers integer array containing two earliest possible round latest possible round which these two players compete against each firstplayer secondplayer one possible scenario which leads earliest round first second third one possible scenario which leads latest round first second third fourth firstplayer secondplayer players numbered compete first there no way make them compete any other firstplayer secondplayer
time needed to rearrange a binary string binary string one all occurrences simultaneously replaced this process repeats until no occurrences seconds needed complete this s after one s becomes after another s becomes after third s becomes after fourth s becomes no occurrence exists any process needed seconds so we s no occurrence exists processes needed seconds so we either or follow can solve this problem time
moving stones until consecutive there three stones different positions three integers positions one pick up stone endpoint either lowest or highest position move unoccupied position between those say stones currently positions z x y pick up stone either position x or position move stone integer position x k z k game ends when cannot make any more moves stones three consecutive integer array answer length minimum moves can maximum moves can b c move stone or move stone b c we cannot make any b c move stone or move stone c c have different
triangle triangle minimum path sum top each may move adjacent row more index i current may move either index i or index i next triangle triangle looks minimum path sum top bottom triangle follow could do this using only extra where total rows
xor queries of a subarray array arr positive also array queries where each query i compute xor elements lefti righti xor xor xor array answer where answer ith arr queries binary representation elements array xor values queries xor xor xor xor xor arr queries lefti righti
smallest missing genetic value in each subtree there family tree rooted consisting nodes numbered integer array where parent node since node there genetic each represented integer inclusive range integer array where distinct genetic value node array ans length where smallest genetic value missing subtree rooted node subtree rooted node x contains node x all descendant parents nums answer each subtree calculated subtree contains nodes values smallest missing subtree contains only node value smallest missing subtree contains nodes values smallest missing subtree contains only node value smallest missing parents nums answer each subtree calculated subtree contains nodes values smallest missing subtree contains nodes values smallest missing subtree contains only node value smallest missing subtree contains nodes values smallest missing subtree contains only node value smallest missing subtree contains only node value smallest missing parents nums value missing all i parents represents valid each
shortest bridge x binary matrix grid where represents land represents island connected group not connected any other there exactly two islands may change connect two islands form one smallest must flip connect two grid grid grid either or there exactly two islands
balanced binary tree binary determine root true root false root true nodes tree range
dinner plate stacks have infinite stacks arranged row numbered each stacks same maximum implement dinnerplates initializes object maximum capacity stacks void pushes integer val into leftmost stack size less than int returns value top rightmost stack removes returns all stacks int returns value top stack index index removes stack or returns stack index input output dinnerplates d initialize capacity stacks returns stacks stacks stacks returns stacks returns stacks returns stacks returns stacks returns stacks returns there no returns there still no capacity val index most calls made
bulb switcher ii there room bulbs labeled all turned four buttons each four buttons different functionality button flips status all button flips status all bulbs even labels button flips status all bulbs odd labels button flips status all bulbs label j where k must make exactly presses button presses each may pick any four buttons two integers different possible statuses after performing all presses button presses status can pressing button pressing button presses status can pressing button pressing button pressing button presses status can pressing button pressing button pressing button pressing button presses
mini parser string s represents serialization nested implement parser deserialize deserialized each element either integer or list whose elements may also integers or other s should nestedinteger object which contains single integer s nestedinteger object containing nested list integer containing value nested list containing two integer containing value nested list one integer containing value s consists square brackets negative sign commas s serialization valid all values input range
minimum score of a path between two cities positive integer representing cities numbered also array roads where indicates there bidirectional road between cities ai bi distance equal cities graph not necessarily score path between two cities defined minimum distance road this minimum possible score path between cities path sequence roads between two allowed path contain same road multiple can visit cities multiple times along test cases generated such there least one path between roads path city minimum score score this path can shown no other path less roads path city minimum score score this path bi ai bi distancei there no repeated there least one path between
smallest index with equal value integer array smallest index i nums such i mod or such index does not x mod y denotes remainder when x divided nums mod mod mod all indices have i mod so we smallest index nums mod mod mod mod only index which i mod nums no index satisfies i mod
customer who visited but did not make any transactions sql schema visits column name type int int primary key this this table contains information about customers who visited transactions column name type int int amount int primary key this this table contains information about transactions made during write sql query find ids users who visited without making any transactions times they made these types result table sorted any query result format following visits transactions amount customer id visited mall once made one transaction during visit id customer id visited mall once made one transaction during visit id customer id visited mall once did not make any customer id visited mall three during visits they did not make any during one visit they made customer id visited mall once did not make any we can users ids visited mall one time without making any user visited mall twice did not make any
valid square coordinates four points space true four points construct coordinate point pi represented input not any valid square four equal sides positive length four equal angles true false true yi
allow one function call function new function identical original function except ensures fn called most first time returned function should same result every subsequent time should fn b calls const oncefn fn not called fn b calls const oncefn fn not called fn not called
distant barcodes there row where ith barcode rearrange barcodes so no two adjacent barcodes may any guaranteed answer barcodes barcodes
amount of time for binary tree to be infected root binary tree unique integer minute infection starts node value each node becomes infected node currently node adjacent infected minutes needed entire tree root start following nodes infected minute node minute nodes minute node minute node minute nodes takes minutes whole tree infected so we root start minute only node tree infected so we nodes tree range each node unique node value start exists
top travellers sql schema users column name type id int name varchar id primary key this name name rides column name type id int int distance int id primary key this id user who traveled distance write sql query report distance traveled each result table ordered descending two or more users traveled same order them their name ascending query result format following users id name alice bob alex donald lee jonathan elvis rides id distance name elvis lee bob jonathan alex alice donald elvis lee traveled elvis top traveler his name alphabetically smaller than alice have only one ride we just order them total distances donald did not have any distance traveled him
possible bipartition we want split group people into two groups any each person may dislike some other they should not go into same integer array dislikes where indicates person labeled ai does not like person labeled true possible split everyone into two groups this dislikes true first group second group dislikes false we need least groups divide we cannot put them two ai bi all pairs dislikes
decode string encoded decoded encoding rule where inside square brackets being repeated exactly k note k guaranteed positive may assume input string always there no extra white square brackets may assume original data does not contain any digits digits only those repeat there not input like or test cases generated so length output never exceed s s s s consists lowercase english square brackets s guaranteed valid all integers s range
reach a number standing position infinite there destination position can make some moves nummoves so each can either go left or during ith move i i take i steps chosen integer minimum moves required minimum reach target we step we step we step target we step we step target target
count the number of consistent strings string allowed consisting distinct characters array strings string consistent all characters string appear string consistent strings array allowed words strings consistent since they only contain characters allowed words all strings allowed words strings characters allowed allowed contain only lowercase english
frequency tracker design data structure keeps track values answers some queries regarding their implement frequencytracker initializes frequencytracker object empty array void adds data void deletes one occurrence data data structure may not contain this case nothing bool returns true there data structure occurs frequency returns input output explanation frequencytracker frequencytracker new data structure now contains data structure now contains returns because occurs twice input output explanation frequencytracker frequencytracker new data structure now contains data structure becomes empty returns because data structure empty input output explanation frequencytracker frequencytracker new returns because data structure empty data structure now contains returns because occurs once frequency calls made hasfrequency
design an atm machine there atm machine stores banknotes initially atm user can use machine deposit or withdraw any amount when machine prioritizes using banknotes larger want withdraw there then machine use try withdraw there banknotes then withdraw request rejected because machine first try use banknote then unable use banknotes complete remaining note machine not allowed use banknotes instead implement atm initializes atm void deposits new banknotes order returns array length banknotes handed user order update banknotes atm after returns not possible not withdraw any banknotes this input output explanation atm atm new deposits returns machine uses banknote banknotes left over machine deposits banknotes machine now returns machine try use banknote then unable complete remaining so withdraw request since request banknotes machine not returns machine uses banknote amount most calls total made withdraw least one call made each function withdraw
minimum area rectangle array points plane points where minimum area rectangle formed these sides parallel x y there not any such points points yi all points
sort list head linked list after sorting ascending head head head nodes list range follow can sort linked list time memory constant
largest sum of averages integer array nums integer can partition array into most k adjacent score partition sum averages each note partition must use every integer score not necessarily maximum score can achieve all possible answers within actual answer nums k best choice partition nums into answer we could have also partitioned nums into partition would lead score which nums k k
construct string from binary tree root binary construct string consisting parenthesis integers binary tree preorder traversal omit all empty parenthesis pairs do not affect mapping relationship between string original binary root needs but need omit all unnecessary empty parenthesis root almost same first except we cannot omit first parenthesis pair break mapping relationship between input nodes tree range
find all groups of farmland m x binary matrix land where represents hectare forested land represents hectare keep land there designated rectangular areas hectares consist entirely these rectangular areas called no two groups meaning farmland one group not adjacent another farmland different land can represented coordinate system where top left corner land bottom right corner land find coordinates top left bottom right corner each group group farmland top left corner bottom right corner represented array array containing arrays described above each group farmland there no groups empty may answer any land first group top left corner bottom right corner second group top left corner bottom right corner land first group top left corner bottom right corner land there no groups m land consists only groups farmland rectangular
text justification array strings words width format text such each line exactly maxwidth characters fully should pack your words greedy pack many words can each pad extra spaces when necessary so each line exactly maxwidth extra spaces between words should distributed evenly spaces line does not divide evenly between empty slots left assigned more spaces than slots last line should no extra space inserted between word defined character sequence consisting characters each length guaranteed greater than not exceed input array words contains least one words maxwidth words maxwidth must note last line instead because last line must instead note second line also because contains only one words maxwidth what explain art else consists only english letters maxwidth maxwidth
minimum operations to reduce an integer to 0 positive integer can do following operation any add or subtract power minimum operations make equal x power x where i we can do following add so now subtract so now subtract so now can shown minimum operations we need make equal we can do following add so now add so now subtract so now so minimum operations
sum of subarray ranges integer array range subarray nums difference between largest smallest element sum all subarray ranges subarray contiguous sequence elements within nums subarrays nums range largest smallest range range range range range so sum all ranges nums subarrays nums range largest smallest range range range range range so sum all ranges nums sum all subarray ranges nums could find solution time
destroying asteroids integer which represents original mass further integer array where mass ith can arrange planet collide asteroids any arbitrary mass planet greater than or equal mass asteroid destroyed planet gains mass planet true all asteroids can mass asteroids true one way order asteroids planet collides asteroid mass new planet planet collides asteroid mass new planet planet collides asteroid mass new planet planet collides asteroid mass new planet planet collides asteroid mass new planet all asteroids mass asteroids false planet cannot ever gain enough mass destroy asteroid mass after planet destroys other have mass this less than so collision would not destroy last mass
circle and rectangle overlapping circle represented rectangle represented where coordinates coordinates corner true circle rectangle overlapped otherwise other check there any point belongs circle rectangle same radius xcenter ycenter true circle rectangle share point radius xcenter ycenter false radius xcenter ycenter true radius ycenter
continuous subarray sum integer array nums integer true nums good subarray or false good subarray subarray length least sum elements subarray multiple note subarray contiguous part integer x multiple k there exists integer such x always multiple nums k true continuous subarray size whose elements sum up nums k true continuous subarray size whose elements sum up multiple because nums k false k
monthly transactions i sql schema transactions column name type id int country varchar state enum amount int date id primary key this table information about incoming state column enum type write sql query find each month transactions their total approved transactions their total result table any query result format following transactions id country state amount us approved us declined us approved de approved month country us us de
longest arithmetic subsequence of given difference integer array arr integer length longest subsequence arr which arithmetic sequence such difference between adjacent elements subsequence equals subsequence sequence can derived arr deleting some or no elements without changing order remaining arr difference longest arithmetic subsequence arr difference longest arithmetic subsequence any single arr difference longest arithmetic subsequence difference
lfu cache design implement data structure least frequently used implement lfucache initializes object capacity data int gets value key key exists returns void int update value key or inserts key not already when cache reaches should invalidate remove least frequently used key before inserting new this when there tie two or more keys same least recently used key would determine least frequently used use counter maintained each key key smallest use counter least frequently used when key first inserted into use counter set put use counter key cache incremented either get or put operation called functions get put must each run average time input output explanation use counter key x show last used order tiebreakers element most lfucache lfu new lfu key because invalidate both have same but invalidate capacity key value most calls made get
maximal network rank there infrastructure cities some roads connecting these each indicates there bidirectional road between cities ai network rank two different cities defined total directly connected roads either road directly connected both only counted maximal network rank infrastructure maximum network rank all pairs different integer array maximal network rank entire roads network rank cities there roads connected either or road between only counted roads there roads connected cities or roads network rank notice all cities do not have bi ai bi each pair cities most one road connecting
remove element integer array nums integer remove all occurrences val nums order elements may then elements nums which not equal consider elements nums which not equal val get need do following change array nums such first k elements nums contain elements which not equal remaining elements nums not important well size custom judge test your solution following nums input array int val value remove expectednums expected answer correct sorted no values equaling int k calls your implementation assert k sort first k elements nums i i assert all assertions then your solution nums val nums your function should k first two elements nums being does not matter what leave beyond returned k they nums val nums your function should k first five elements nums containing note five elements can returned any does not matter what leave beyond returned k they val
merge similar items two integer representing two sets each array items following where valuei represents value weighti represents weight ith value each item items integer array ret where weighti being sum weights all items value ret should returned ascending order item value occurs weight weight total weight item value occurs weight weight total weight item value occurs weight total weight we item value occurs weight weight total weight item value occurs weight weight total weight item value occurs weight weight total weight we item value occurs weight weight total weight item value occurs weight weight total weight item value occurs weight total weight we weighti each valuei each valuei
decompress run-length encoded list we list nums integers representing list compressed consider each adjacent pair elements i each such there freq elements value val concatenated concatenate all sublists left right generate decompressed decompressed nums first pair means we have freq val so we generate array second pair means we have freq val so we generate end concatenation nums
minimum number of visited cells in a grid m x integer matrix your initial position cell starting cell can move one following cells j k j or cells i k i minimum cells need visit reach cell there no valid grid image above shows one paths visits exactly grid image above shows one paths visits exactly grid can proven no path m m m
find mode in binary search tree root binary search tree all most frequently occurred tree more than one them any assume bst defined left subtree node contains only nodes keys less than or equal right subtree node contains only nodes keys greater than or equal both left right subtrees must also binary search root root nodes tree range follow could do without using any extra implicit stack space incurred due recursion does not
find subsequence of length k with the largest sum integer array nums integer want find subsequence nums length k largest any such subsequence integer array length subsequence array can derived another array deleting some or no elements without changing order remaining nums k subsequence largest sum nums k subsequence largest sum nums k subsequence largest sum another possible subsequence k
summary ranges sorted unique integer array range set all integers b smallest sorted list ranges cover all numbers array each element nums covered exactly one there no integer x such x one ranges but not each range list should output b b nums ranges nums ranges all values nums nums sorted ascending
smallest range covering elements from k lists have k lists sorted integers find smallest range includes least one each k we define range smaller than range b d c or c b d nums list range list range list range nums k k sorted
swap for longest repeated character substring string can swap two characters length longest substring repeated text we can swap first last or last first longest repeated character substring length text swap last first we get longest repeated character substring length text no need longest repeated character substring length text consist lowercase english characters
sequential digits integer sequential digits only each digit one more than previous sorted list all integers range inclusive have sequential low high low high low high
find eventual safe states there directed graph nodes each node labeled graph represented integer array graph where integer array nodes adjacent node meaning there edge node i each node node terminal node there no outgoing node safe node every possible path starting node leads terminal node another safe array containing all safe nodes answer should sorted ascending graph graph shown nodes terminal nodes there no outgoing edges either every path starting nodes all lead either node or graph only node terminal every path starting node leads node sorted strictly increasing graph may contain edges graph range
contiguous array binary array maximum length contiguous subarray equal nums longest contiguous subarray equal nums longest contiguous subarray equal either or
combinations two integers all possible combinations k numbers chosen range may answer any k there choose total note combinations considered same k there choose total k
minimum subsequence in non-increasing order array obtain subsequence array whose sum elements strictly greater than sum non included elements such there multiple subsequence minimum size there still exist multiple subsequence maximum total sum all subsequence array can obtained erasing some elements note solution constraints guaranteed also answer sorted nums subsequences minimal such sum their elements strictly greater than sum elements not subsequence maximum total sum nums subsequence sum elements equal which not strictly greater than sum elements not included subsequence minimal satisfying note subsequence returned
number of restricted paths from first to last node there undirected weighted connected positive integer which denotes graph nodes labeled array edges where each denotes there edge between nodes ui vi weight equal path node start node end sequence nodes such start zk end there edge between zi where i distance path sum weights edges let denote shortest distance path between node node restricted path path also satisfies where i restricted paths node node since may too modulo edges each circle contains node black distancetolastnode value three restricted paths edges each circle contains node black distancetolastnode value only restricted path vi ui vi weighti there most one edge between any two there least one path between any two
plus one large integer represented integer array where each ith digit digits ordered most significant least significant large integer does not contain any leading increment large integer one resulting array digits array represents integer incrementing one gives result should digits array represents integer incrementing one gives result should digits array represents integer incrementing one gives result should digits does not contain any leading
search in a binary search tree root binary search tree integer find node bst value equals val subtree rooted such node does not root val root val nodes tree range root binary search val
construct binary search tree from preorder traversal array integers which represents preorder traversal bst binary search construct tree guaranteed there always possible find binary search tree requirements test binary search tree binary tree where every any descendant value strictly less than any descendant value strictly greater than preorder traversal binary tree displays value node then traverses then traverses preorder preorder all values preorder
longest palindromic substring string longest palindromic substring s also valid s s consist only digits english
most frequent subtree sum root binary most frequent subtree there all values highest frequency any subtree sum node defined sum all node values formed subtree rooted node node root root nodes tree range
print zero even odd have function printnumber can called integer parameter prints calling prints instance class zeroevenodd three same instance zeroevenodd passed three different thread calls should only output thread calls should only output even thread calls should only output odd modify class output series where length series must implement zeroevenodd initializes object represents numbers should void calls printnumber output one void calls printnumber output one even void calls printnumber output one odd there three threads being fired one them calls other calls last one calls correct
concatenation of array integer array nums length want create array ans length where i ans concatenation two nums array nums array ans formed ans ans nums array ans formed ans ans
maximum number of words you can type there malfunctioning keyboard where some letter keys do not all other keys keyboard work string text words separated single space leading or trailing string brokenletters all distinct letter keys words text can fully type using this text brokenletters we cannot type because key text brokenletters we cannot type because keys text brokenletters we cannot type either word because key text consists words separated single space without any leading or trailing each word only consists lowercase english brokenletters consists distinct lowercase english
n-repeated element in size 2n array integer array nums following nums contains unique exactly one element nums repeated element repeated nums nums nums nums contains unique elements one them repeated exactly
magnetic force between two balls universe earth rick discovered special form magnetic force between two balls they put his new invented rick empty ith basket morty m balls needs distribute balls into baskets such minimum magnetic force between any two balls rick stated magnetic force between two different balls positions x y integer array position integer required position m distributing balls into baskets make magnetic force between ball pairs minimum magnetic force we cannot achieve larger minimum magnetic force than position m we can use baskets all integers position m
longest common prefix write function find longest common prefix string amongst array there no common empty string strs strs there no common prefix among input consists only lowercase english
sort the people array strings array heights consists distinct positive both arrays length each index denote name height ith names sorted descending order names heights mary followed emma names heights first bob followed alice second consists lower upper case english all values heights
4sum ii four integer arrays all length tuples such l two tuples
maximum number of darts inside of a circular dartboard alice throwing darts very large array darts where position ith dart alice threw bob knows positions darts wants place dartboard radius r wall so maximum darts alice throws lies integer maximum darts can lie darts r circle dartboard center radius contain all darts r circle dartboard center radius contain all points except point yi all darts unique r
container with most water integer array height length there vertical lines drawn such two endpoints ith line find two lines together form such container contains most maximum amount water container can notice may not slant height above vertical lines represented array this max area water container can contain height
partition labels string we want partition string into many parts possible so each letter appears most one note partition done so after concatenating all parts resultant string should list integers representing size these s partition this partition so each letter appears most one partition like because splits s into less s s consists lowercase english
minimum operations to reduce x to zero integer array nums integer one can either remove leftmost or rightmost element array nums subtract value note this modifies array future minimum operations reduce x exactly nums x optimal solution remove last two elements reduce x nums x nums x optimal solution remove last three elements first two elements operations reduce x x
license key formatting license key represented string s consists only alphanumeric characters string separated into groups also integer we want reformat string s such each group contains exactly k except first which could shorter than k but still must contain least one there must dash inserted between two should convert all lowercase letters reformatted license s k string s been split into two each part note two extra dashes not needed can s k string s been split into three each part characters except first part could shorter mentioned s consists english dashes k
water bottles there numbottles water bottles initially full can exchange numexchange empty water bottles market one full water operation drinking full water bottle turns into empty two integers numbottles maximum water bottles can numbottles numexchange can exchange empty bottles get full water water bottles can numbottles numexchange can exchange empty bottles get full water water bottles can numbottles numexchange
image smoother image smoother filter size x can applied each cell image rounding down average cell eight surrounding cells average nine cells blue one or more surrounding cells cell not we do not consider average average four cells red m x integer matrix img representing grayscale image after applying smoother each cell img points points point img points points point m
describe the painting there long thin painting can represented painting painted multiple overlapping segments where each segment painted unique integer array where represents segment colori colors overlapping segments painting mixed when when two or more colors they form new color can represented set mixed colors then resulting mixed color sake should only output sum elements set rather than full want describe painting minimum segments these mixed these segments can represented array painting where describes segment mixed color sum painting created segments can described painting colored sum both first second colored only second array painting describing finished painting any parts not may segments any segment section line between points b including point not including point segments painting can described colored sum first third colored sum second third segments painting can described colored first colored sum first second colored second colored third segments painting can described colored sum first second colored sum third fourth note returning single segment incorrect because mixed color sets starti endi colori each colori
human traffic of stadium sql schema stadium column name type id int date people int primary key this each row this table contains visit date visit id stadium people during no two rows have same id dates increase write sql query display records three or more rows consecutive people greater than or equal result table ordered ascending query result format following stadium id people id people four rows ids have consecutive ids each them people note row included even though not next day after row rows ids not included because we need least three consecutive
split array largest sum integer array nums integer split nums into k subarrays such largest sum any subarray minimized largest sum subarray contiguous part nums k there four ways split nums into two best way split into where largest sum among two subarrays only nums k there four ways split nums into two best way split into where largest sum among two subarrays only k
maximum product difference between two pairs product difference between two pairs defined product difference between integer array choose four distinct indices z such product difference between pairs maximum such product nums we can choose indices first pair indices second pair product difference nums we can choose indices first pair indices second pair product difference
number of valid clock times string length called representing current time digital clock format earliest possible time latest possible time string digits represented symbol must replaced digit integer valid clock times can created replacing every digit time we can replace either or producing or note we cannot replace since time we have two time each can replaced any digit so we have total time there possible choices possible choices we have time valid string length format hh mm some digits might replaced need replaced digits
stream of characters design algorithm accepts stream characters checks suffix these characters string array strings words stream added four characters your algorithm should detect suffix characters matches implement streamchecker initializes object strings array boolean accepts new character stream returns true any suffix stream forms word input output explanation streamchecker streamchecker new false false false because wordlist false because wordlist false false false false false because wordlist consists lowercase english letter lowercase english most calls made
shift 2d grid grid size m x integer need shift grid k one shift element moves element moves element moves grid after applying shift operation k grid k grid k grid k m m k
incremental memory leak two integers representing available memory bits two memory there currently faulty program running consumes increasing amount memory every ith second i bits memory allocated stick more available memory first memory stick both have same available neither stick least i bits available program array containing where crashtime time when program crashed available bits memory first second sticks memory allocated bit memory allocated stick first stick now bit available bits memory allocated stick second stick now bits available program sticks have bits available memory allocated bit memory allocated stick second stick now bit available bits memory allocated stick second stick now bits available bits memory allocated stick first stick now bits available bits memory allocated stick second stick now bits available bits memory allocated stick first stick now bits available program sticks have bits available
corporate flight bookings there flights labeled array flight bookings where represents booking flights firsti through lasti seatsi seats reserved each flight array answer length where total seats reserved flight bookings flight booking booking booking total answer bookings flight booking booking total answer firsti lasti seatsi
valid parentheses string s containing just characters determine input string input string valid open brackets must closed same type open brackets must closed correct every close bracket corresponding open bracket same s true s true s false s consists parentheses only
minimum path cost in a grid m x integer matrix grid consisting distinct integers m can move this matrix cell any other cell next cell such x m can move any cells note not possible move cells last each possible move cost array movecost size x where cost moving cell value i cell column j next cost moving cells last row grid can cost path grid sum all values cells visited plus sum costs all moves minimum cost path starts any cell first row ends any cell last grid movecost path minimum possible cost path sum values cells visited cost moving cost moving so total cost path grid movecost path minimum possible cost path sum values cells visited cost moving so total cost this path m grid consists distinct integers m m
minimum moves to equal array elements integer array nums size minimum moves required make all array elements one can increment elements array nums only three moves needed each move increments two nums answer guaranteed fit
maximum score from removing substrings string s two integers x can perform two types operations any remove substring gain x when removing becomes remove substring gain y when removing becomes maximum points can gain after applying above operations s x y remove underlined s points added remove underlined s points added remove underlined s points added remove underlined s points added total score s x y y s consists lowercase english
least operators to express number single positive integer we write expression form x x x x where each operator either or division or x we might write which value when writing such we adhere following division operator returns rational there no parentheses placed we use usual order multiplication division happen before addition not allowed use unary negation operator valid expression only uses but not because uses we would like write expression least operators such expression equals least operators x target expression contains x target expression contains x target expression contains x target
html entity parser html entity parser parser takes html code input replace all entities special characters characters special characters their entities html quotation entity symbol character single quote entity symbol character entity symbol character greater than entity symbol character less than entity symbol character entity symbol character input text string html have implement entity text after replacing entities special text html entity but html entity but parser replace entity text i i string may contain any possible characters out all ascii
swap nodes in pairs linked swap every two adjacent nodes must solve problem without modifying values nodes only nodes themselves may head head head nodes list range
maximum students taking exam m matrix seats represent seats distributions seat denoted character otherwise denoted students can see answers those sitting next upper left upper but cannot see answers student sitting directly front or behind maximum students can take exam together without any cheating being students must placed seats good seats teacher can place students available seats so they cheat seats place all students available seats place students available seats column seats contains only characters m m
number of unique good subsequences binary string subsequence binary considered good not empty no leading zeros exception find unique good subsequences binary then all good subsequences so unique good subsequences note subsequences not good because they have leading unique good subsequences since answer may very modulo subsequence sequence can derived another sequence deleting some or no elements without changing order remaining binary good subsequences binary unique good subsequences binary good subsequences binary unique good subsequences binary good subsequences binary unique good subsequences binary consists only
maximum population year integer array logs where each indicates birth death years ith population some year x people alive during ith person counted year population x inclusive range deathi note person not counted year they earliest year maximum logs maximum population earliest year this logs maximum population had happened years earlier year between them birthi deathi
generate a string with characters that have odd counts integer string characters such each character such string occurs odd returned string must contain only lowercase english there multiples valid any valid string since character occurs three times character occurs note there many other valid strings such valid string since characters occur note there many other valid strings such
minimum operations to make all array elements equal array nums consisting positive also integer array queries size ith want make all elements nums equal can perform following operation array any increase or decrease element array array answer size m where minimum operations make all elements nums equal note after each query array reset original nums queries first query we can do following decrease so nums decrease so nums decrease so nums so total operations first query second query we can do following increase so nums increase so nums decrease so nums decrease so nums so total operations second query nums queries we can increase each value array total operations m m
mirror reflection there special square room mirrors each four except southwest there receptors each remaining numbered square room walls length p laser ray southwest corner first meets east wall distance q two integers p receptor ray meets test cases guaranteed so ray meet receptor p q ray meets receptor first time gets reflected back left p q q p
count the hidden sequences array integers which describes differences between each pair consecutive integers hidden sequence length more call hidden sequence then we have further two integers lower upper describe inclusive range values hidden sequence can differences lower upper hidden sequence sequence length whose elements between possible hidden not possible since contains element greater than not possible since differences not possible hidden sequences there there no possible differences lower upper possible hidden sequences we differences lower upper possible hidden sequences we differences lower upper there no possible hidden we lower upper
minimum sum of squared difference two positive integer arrays both length sum squared difference arrays defined sum each i also two positive integers can modify any elements or most can modify any elements or most minimum sum squared difference after modifying array most times modifying array most allowed modify array elements become negative elements cannot modified because sum square difference one way obtain minimum sum square difference increase increase minimum sum square difference note there other ways obtain minimum sum square but there no way obtain sum smaller than
maximum element after decreasing and rearranging array positive integers perform some operations arr so satisfies these value first element arr must absolute difference between any adjacent elements must less than or equal other each i where i absolute value there types operations can perform any decrease value any element arr smaller positive rearrange elements arr any maximum possible value element arr after performing operations satisfy arr we can satisfy conditions rearranging arr so becomes largest element arr arr one possible way satisfy conditions doing rearrange arr so becomes decrease value second element decrease value third element now arr which satisfies largest element arr arr array already satisfies largest element
all paths from source to target directed acyclic graph nodes labeled find all possible paths node node them any graph list all nodes can visit node i there directed edge node i node graph there two graph i there no all elements input graph guaranteed
sell diminishing-valued colored balls have inventory different colored there customer wants orders balls any customer weirdly values colored each colored value balls color currently have your own yellow customer would pay first yellow after there only yellow balls so next yellow ball then valued value balls decreases sell more integer where represents balls ith color initially also integer which represents total balls customer can sell balls any maximum total value can attain after selling orders colored answer may too modulo inventory orders sell color time color times maximum total value inventory orders sell color times color times maximum total value orders
total appeal of a string appeal string distinct characters found appeal because distinct string total appeal all substring contiguous sequence characters within s following substrings substrings length have appeal sum substrings length have appeal sum substrings length have appeal sum substrings length have appeal sum substrings length appeal sum total sum s following substrings substrings length have appeal sum substrings length have appeal sum substrings length have appeal sum substrings length appeal sum total sum s consists lowercase english
reverse vowels of a string string reverse only all vowels string vowels they can appear both lower upper more than s s s consist printable ascii
merge triplets to form target triplet triplet array three integer array where describes ith also integer array target describes triplet want obtain may apply following operation triplets any times choose two indices i j update become updated true possible obtain target triplet element or false triplets target true perform following choose first last triplets update last triplet triplets target triplet now element triplets target false impossible have element because there no any triplets target true perform following choose first third triplets update third triplet triplets choose third fourth triplets update fourth triplet triplets target triplet now element z
partition array into disjoint intervals integer array partition into two subarrays left right so every element left less than or equal every element left right left smallest possible length left after such test cases generated such partitioning nums left right nums left right there least one valid answer
kth ancestor of a tree node tree nodes numbered form parent array parent where parent ith root tree node find kth ancestor kth ancestor tree node kth node path node root implement treeancestor initializes object nodes tree parent int int kth ancestor node there no such input output explanation treeancestor treeancestor new returns which parent returns which grandparent returns because there no such ancestor k all i node there most
nth digit integer nth digit infinite integer sequence digit sequence which part
print in order suppose we have public class foo public void public void public void same instance foo passed three different thread call thread b call thread c call design mechanism modify program ensure executed after executed after we do not know how threads scheduled operating even though numbers input seem imply input format see mainly ensure our nums there three threads being fired input means thread calls thread b calls thread c calls correct nums input means thread calls thread b calls thread c calls correct nums permutation
three divisors integer true exactly three positive integer m divisor there exists integer k such k false only two true three
minimize the total price of the trips there exists undirected unrooted tree nodes indexed integer integer array edges length where indicates there edge between nodes ai bi each node associated integer array where price ith price sum path sum prices all nodes lying integer array where indicates start ith trip node starti travel node endi any path before performing your first can choose some nodes halve minimum total price sum perform all edges price trips diagram above denotes tree after rooting node first part shows initial tree second part shows tree after choosing nodes making their price we choose path price sum path we choose path price sum path we choose path price sum path total price sum all trips can minimum answer we can edges price trips diagram above denotes tree after rooting node first part shows initial tree second part shows tree after choosing node making price we choose path price sum path total price sum all trips can minimum answer we can bi edges represents valid even endi
parallel courses iii integer which indicates there courses labeled also integer array relations where denotes course prevcoursej completed before course nextcoursej integer array time where denotes how many months takes complete must find minimum months needed complete all courses following these may start taking course any time prerequisites any courses can taken same minimum months needed complete all test cases generated such possible complete every course graph directed acyclic relations time figure above represents graph time required complete each we start course course simultaneously month course takes months course takes months complete earliest time we can start course month total time required relations time figure above represents graph time required complete each can start courses month can complete them after months course can taken only after course after completed after course can taken only after courses have been after minimum time needed complete all courses nextcoursej prevcoursej nextcoursej all pairs graph directed acyclic
most profit assigning work have jobs m three worker difficulty profit ith ability jth worker jth worker can only complete job difficulty most every worker can assigned most one but one job can completed multiple three workers attempt same job pays then total profit worker cannot complete any their profit maximum profit we can achieve after assigning workers difficulty profit worker workers assigned jobs difficulty they get profit difficulty profit worker m m
find xor sum of all pairs bitwise and xor sum list bitwise xor all list only contains one then xor sum equal this xor sum equal xor xor xor xor sum equal two arrays consist only consider list containing result every pair where i j xor sum aforementioned list xor sum xor xor xor xor xor list xor sum
memoize ii function memoized version memoized function function never called twice same instead cached fn can any function there no constraints what type values inputs considered identical they each getinputs fn function const inputs const memoized arr inputs required call inputs but those inputs seen before so no call inputs required another call total getinputs fn function merging two empty objects always result empty may seem like there should only call because however none those objects each getinputs const o fn function merging two empty objects always result empty third function calls result this because every object passed nan
keep multiplying found values by two array integers also integer original which first needs searched then do following original found multiply two set original stop repeat this process new long keep finding final value nums original found multiplied obtain found multiplied obtain found multiplied obtain not found nums original not found original
delete node in a bst root node reference bst delete node key root node reference deletion can divided into two search node node delete root key key delete so we find node value delete one valid answer shown above please notice another valid answer also root key tree does not contain node value root key nodes tree range each node unique root valid binary search key follow could solve time complexity
finding the users active minutes logs actions integer logs represented integer array logs where each indicates user idi performed action minute multiple users can perform actions single user can perform multiple actions same user active minutes user defined unique minutes which user performed action minute can only counted even multiple actions occur during calculate array answer size k such each j j users whose uam equals array answer described logs k user performed actions minutes they have uam only counted user performed actions minutes they have uam since both users have uam remaining values logs k user performed single action minute they have uam user performed actions minutes they have uam there one user uam one uam remaining values idi timei k range maximum uam
friends of appropriate ages there persons social media integer array ages where age ith person x not send friend request person y any following conditions x send friend request note x sends request y not necessarily send request person not send friend request total friend requests ages people friend request each ages friend requests made ages friend requests made
add binary two binary strings their sum binary b b b consist only or each string does not contain leading zeros except zero
populating next right pointers in each node perfect binary tree where all leaves same every parent two binary tree following struct node int node node node populate each next pointer point next right there no next right next pointer should set all next pointers set root above perfect binary tree your function should populate each next pointer point next right just like figure serialized output level order connected next signifying end each root nodes tree range may only use constant extra recursive approach may assume implicit stack space does not count extra space this
construct target array with multiple sums array target starting array arr consisting may perform following procedure let x sum all elements currently your choose index such i set value arr index i may repeat this procedure many times true possible construct target array target true start arr sum choose index sum choose index sum choose index done target false impossible create target array target true
groups of strings array strings each string consists lowercase english letters no letter occurs more than once any string two strings said connected set letters can obtained set letters any one following adding exactly one letter set letters deleting exactly one letter set letters replacing exactly one letter set letters any including array words can divided into one or more string belongs group any one following connected least one other string only string present note strings words should grouped such manner string belonging group cannot connected string present any other can proved such arrangement always array ans size maximum groups words can divided size largest words can used obtain replacing adding so connected can used obtain replacing adding so connected can used obtain deleting deleting so connected not connected any string words can divided into groups size largest group words connected connected connected since all strings connected each they should grouped size largest group consists lowercase english letters no letter occurs more than once
string to integer (atoi) implement which converts string signed integer atoi algorithm read ignore any leading check next character not already end or read this character this determines final result negative or positive assume result positive neither read next characters until next character or end input rest string convert these digits into integer no digits then integer change sign necessary step integer out signed integer range then clamp integer so remains integers less than should clamped integers greater than should clamped integer final only space character considered whitespace do not ignore any characters other than leading whitespace or rest string after s underlined characters what read caret current reader step characters read because there no leading step characters read because there neither nor step read parsed integer since range final result s step whitespace read step so result should step read parsed integer since range final result s step characters read because there no leading step characters read because there neither nor step read reading stops because next character parsed integer since range final result s consists english letters digits
invert binary tree root binary invert root root root nodes tree range
2 keys keyboard there only one character screen can perform one two operations this notepad each copy can copy all characters present screen partial copy not can paste characters which copied last integer minimum operations get character exactly times we have one character step we use copy all step we use paste operation get step we use paste operation get
divide a string into groups of size k string s can partitioned into groups size k using following first group consists first k characters second group consists next k characters so each character can part exactly one last string does not have k characters character fill used complete note partition done so after removing fill character last group concatenating all groups resultant string should string size each group k character string array denoting composition every group s been divided using above s k fill first characters form first next characters form second last characters form third since all groups can completely filled characters we do not need use groups formed s k fill similar previous we forming first three groups last we can only use character complete this we add groups formed s consists lowercase english letters k fill lowercase english
first completely painted row or column integer array m x integer matrix arr mat both contain all integers range m go through each index i arr starting index paint cell mat containing integer smallest index i which either row or column completely painted arr mat moves shown both first row second column matrix become fully painted arr mat second column becomes fully painted m m m m all integers arr all integers mat
find the minimum number of fibonacci numbers whose sum is k integer minimum fibonacci numbers whose sum equal same fibonacci can used multiple fibonacci numbers defined fn guaranteed constraints we can always find such fibonacci numbers sum up k fibonacci numbers k we can use k k we can use k k we can use k
product price at a given date sql schema products column name type int int date primary key this each row this table indicates price some product changed new price some write sql query find prices all products assume price all products before any change result table any query result format following products price
shifting letters string s lowercase english letters integer array shifts same call next letter around so becomes now each we want shift first i letters x final string after all such shifts s s shifts we start after shifting first letters s we have after shifting first letters s we have after shifting first letters s we have s shifts s consists lowercase english
super washing machines have super washing machines each washing machine some dresses or each could choose any m m washing pass one dress each washing machine one adjacent washing machines same integer array machines representing dresses each washing machine left right minimum moves make all washing machines have same not possible do machines machines machines impossible make all three washing machines have same
count operations to obtain zero two integers one must subtract otherwise subtract subtract thus obtaining after one operations required make either or operation since we subtract get operation since we subtract operation since we subtract now since we do not need perform any further so total operations required operation since we subtract get now since we so total operations required
valid palindrome phrase palindrome after converting all uppercase letters into lowercase letters removing all reads same forward alphanumeric characters include letters string true or false s true s false not s true s empty string after removing since empty string reads same forward s consists only printable ascii
reachable nodes with restrictions there undirected tree nodes labeled integer array edges length where indicates there edge between nodes ai bi also integer array restricted which represents restricted maximum nodes can reach node without visiting restricted note node not restricted edges restricted diagram above shows we have only nodes can reached node without visiting restricted edges restricted diagram above shows we have only nodes can reached node without visiting restricted bi ai bi edges represents valid all values restricted
bank account summary ii sql schema users column name type account int name varchar account primary key this each row this table contains account each user there no two users having same name transactions column name type int account int amount int date primary key this each row this table contains all changes made all amount positive user received money negative they transferred all accounts start balance write sql query report name balance users balance higher than balance account equal sum amounts all transactions involving result table any query result format following users account name alice bob charlie transactions account amount name balance alice balance balance balance
diagonal traverse m x matrix array all elements array diagonal mat mat m m
final value of variable after performing operations there programming language only four operations one variable increments value variable x decrements value variable x value x array strings operations containing list final value x after performing all operations operations performed x x decremented x x incremented x x incremented x operations operations performed x x incremented x x incremented x x incremented x operations operations performed x x incremented x x incremented x x decremented x x decremented x either or
array with elements not equal to average of neighbors array nums distinct want rearrange elements array such every element rearranged array not equal average more rearranged array should have property such every i range i not equal any rearrangement nums meets nums when average neighbors when average neighbors when average neighbors nums when average neighbors when average neighbors when average neighbors
longest happy prefix string called happy prefix prefix which also suffix string longest happy prefix empty string no such prefix s s contains prefix excluding itself suffix largest prefix which also suffix s largest prefix which also they can overlap original s contains only lowercase english
minimum number of operations to move all balls to each box have binary string boxes length where ith box contains one one can move one ball box adjacent box i adjacent box j note after doing there may more than one ball some array answer size where minimum operations needed move all balls ith each calculated considering initial state boxes answer each box first have move one ball second box first box one second have move one ball first box second box one third have move one ball first box third box two move one ball second box third box one boxes either or
ugly number ugly positive integer whose prime factors limited integer true ugly true true no prime therefore all prime factors limited false not ugly since includes prime factor
binary prefix divisible by 5 binary array nums we define xi whose binary representation subarray nums then array booleans answer where true xi divisible nums input numbers binary which only first divisible so nums either or
step-by-step directions from a binary tree node to another root binary tree each node uniquely assigned value also integer startvalue representing value start node different integer destvalue representing value destination node find shortest path starting node s ending node generate directions such path string consisting only uppercase letters each letter indicates specific means go node left child means go node right child means go node parent directions shortest path node s node root startvalue destvalue shortest path root startvalue destvalue shortest path nodes tree all values tree destvalue startvalue destvalue
split two strings to make palindrome two strings b same choose index split both strings same splitting into two aprefix asuffix where aprefix splitting b into two bprefix bsuffix where b bprefix check aprefix bsuffix or bprefix asuffix forms when split string s into sprefix either ssuffix or sprefix allowed s then valid true possible form palindrome otherwise notice x y denotes concatenation strings x b true either or b palindromes answer true since can split following aprefix asuffix bprefix bsuffix aprefix bsuffix which b false b true split them index aprefix asuffix bprefix bsuffix aprefix bsuffix which b consist lowercase english letters
permutation in string two strings true contains permutation or false other true one permutations substring true contains one permutation false consist lowercase english
minimum length of string after deleting similar ends string s consisting only characters asked apply following algorithm string any pick prefix string s where all characters prefix pick suffix string s where all characters this suffix prefix suffix should not intersect any characters prefix suffix must delete both prefix minimum length s after performing above operation any times zero s remove any so string stays s optimal sequence operations take prefix suffix remove s take prefix suffix remove s take prefix suffix remove s take prefix suffix remove s s optimal sequence operations take prefix suffix remove s take prefix suffix remove s s only consists characters
find the shortest superstring array strings smallest string contains each string words there multiple valid strings smallest any may assume no string words substring another string words all permutations would also words consists lowercase english all strings words
longest ideal subsequence string s consisting lowercase letters integer we call string t ideal following conditions t subsequence string absolute difference alphabet order every two adjacent letters t less than or equal length longest ideal subsequence string can derived another string deleting some or no characters without changing order remaining note alphabet order not absolute difference alphabet order not s k longest ideal string length this string so note not ideal because have difference alphabet s k longest ideal string length this string so k s consists lowercase english
subtract the product and sum of digits of an integer integer difference between product digits sum product digits sum digits result product digits sum digits result
delete greatest value in each row m x matrix grid consisting positive perform following operation until grid becomes delete element greatest value each multiple such elements delete any add maximum deleted elements note columns decreases one after each answer after performing operations described grid diagram above shows removed values each first we remove first row second row there two cells value we can remove any we add second we remove first row second we add third we remove first row second we add final answer grid diagram above shows removed values each first we remove first we add final answer m
odd even linked list head singly linked group all nodes odd indices together followed nodes even reordered first node considered second node so note relative order inside both even odd groups should remain must solve problem extra space complexity time head head nodes linked list range
substrings of size three with distinct characters string good there no repeated string good substrings length three note there multiple occurrences same every occurrence should substring contiguous sequence characters s there substrings size only good substring length s there substrings size good substrings s consists lowercase english
partition equal subset sum integer array true can partition array into two subsets such sum elements both subsets equal or false nums true array can partitioned nums false array cannot partitioned into equal sum
count prefixes of a given string string array words string where s comprise only lowercase english strings words prefix prefix string substring occurs beginning substring contiguous sequence characters within words s strings words which prefix s thus strings words which prefix s words s both strings prefix note same string can occur multiple times should counted each s consist lowercase english letters
reshape the matrix there handy function called reshape which can reshape m x matrix into new one different size r x c keeping original m x matrix mat two integers r c representing rows columns wanted reshaped reshaped matrix should filled all elements original matrix same order they reshape operation parameters possible output new reshaped output original mat r c mat r c m c
verbal arithmetic puzzle represented words left side result right need check equation solvable under following each character decoded one digit no two characters can map same each result decoded one without leading sum numbers left side equal right side true equation otherwise words result true map such words result true map such words result false there no possible mapping satisfy so we note two different characters cannot map same result contain only uppercase english different characters used expression most
basic calculator iv expression such expression evaluation map such terms evalvars evalints list tokens representing simplified such expression alternates chunks space separating each chunk chunk either expression or variable string lowercase letters including note variables can multiple note variables never have leading coefficient or unary operator like or expressions evaluated usual brackets then then addition expression answer format output each term free variables we write free variables within term sorted order we would never write term like only terms have degrees equal free variables being counting we write largest degree terms our answer breaking ties lexicographic order ignoring leading coefficient degree leading coefficient term placed directly left asterisk separating variables they leading coefficient still answer terms constant coefficient not expression output may assume expression always all intermediate results range expression evalvars evalints expression temperature evalvars evalints expression evalvars evalints expression consists lowercase english expression does not contain any leading or trailing all tokens expression separated single consists lowercase english
battleships in a board m x matrix board where each cell battleship or empty battleships battleships can only placed horizontally or vertically other they can only made shape x k k or k x where k can any least one horizontal or vertical cell separates between two battleships there no adjacent board board m either or follow could do using only extra memory without modifying values
unique substrings in wraparound string we define string base infinite wraparound string so base look like string unique substrings s present s only substring s s there two substrings s s there six substrings s s consists lowercase english
design circular queue design your implementation circular circular queue linear data structure which operations performed based fifo first last position connected back first position make also called one benefits circular queue we can make use spaces front normal once queue becomes we cannot insert next element even there space front but using circular we can use space store new implement mycircularqueue initializes object size queue int gets front item queue int gets last item queue boolean inserts element into circular true operation boolean deletes element circular true operation boolean checks whether circular queue empty or boolean checks whether circular queue full or must solve problem without using queue data structure your programming input output explanation mycircularqueue mycircularqueue new true true true false true true true k value most calls made
implement queue using stacks implement first first out queue using only two implemented queue should support all functions normal queue implement myqueue void pushes element x back int removes element front queue returns int returns element front boolean returns true queue false must use only standard operations which means only push empty operations depending your stack may not supported may simulate stack using list or deque long use only standard input output explanation myqueue myqueue new queue queue front queue false x most calls made all calls pop peek can implement queue such each operation amortized time other performing operations take overall time even one those operations may take
kth smallest element in a bst root binary search integer kth smallest value all values nodes root k root k nodes tree k follow bst modified often we can do insert delete need find kth smallest how would
parse lisp expression string expression representing expression integer value syntax these expressions expression either let add mult or assigned expressions always evaluate single integer could positive or let expression takes form vn en where let always string then there one or more pairs alternating variables meaning first variable assigned value expression second variable assigned value expression so then value this let expression value expression add expression takes form where add always string there always two expressions result addition evaluation evaluation mult expression takes form where mult always string there always two expressions result multiplication evaluation evaluation this we use smaller subset variable variable starts lowercase then zero or more lowercase letters or your names protected never used variable there concept when expression variable name within context innermost scope terms checked first value then outer scopes checked guaranteed every expression please see examples more details expression x x x y x expression x when checking value variable we check innermost scope outermost context variable we trying since x found value x expression x x assignment let statements processed expression x y x x x first x evaluates assigned second x evaluates there no leading or trailing spaces all tokens separated single space answer all intermediate calculations answer guaranteed fit expression guaranteed legal evaluate
number of good pairs array integers good pair called good i nums there good pairs nums each pair array nums
maximum value of k coins from piles there piles coins each pile consists positive coins assorted one can choose any coin top any remove add your list where list integers denoting composition ith pile top positive integer maximum total value coins can have your wallet choose exactly k coins piles k above diagram shows different ways we can choose k maximum total we can obtain piles k maximum total can obtained we choose all coins last k
arithmetic slices integer array called arithmetic consists least three elements difference between any two consecutive elements arithmetic integer array arithmetic subarrays subarray contiguous subsequence nums we have arithmetic slices nums
complement of base 10 integer complement integer integer get when flip all all binary integer binary complement which integer integer complement which complement which complement which this question same
sliding puzzle x there five tiles labeled empty square represented move consists choosing adjacent swapping state board solved only board puzzle board least moves required so state board impossible state board board swap one board no moves make board board smallest moves solves after move after move after move after move after move after move each value
design hashset design hashset without using any hash table implement myhashset void inserts value key into bool returns whether value key exists hashset or void removes value key key does not exist do input output explanation myhashset myhashset new set set true set true set key most calls made
maximum number of events that can be attended array events where every event i starts startdayi ends can attend event i any day d where starttimei d can only attend one event any time maximum events can events can attend all three one way attend them all attend first event day attend second event day attend third event day startdayi enddayi
string without aaa or bbb two integers any string s such s length b contains exactly exactly b substring does not occur substring does not occur b all correct b b guaranteed such s exists
maximum number of non-overlapping substrings string s lowercase need find maximum substrings s meet following substrings do not any two substrings either j x or i y substring contains certain character c must also contain all occurrences find maximum substrings meet above there multiple solutions same one minimum total can shown there exists unique solution minimum total notice can substrings any s following all possible substrings meet we choose first we cannot choose anything else get only we choose we left which only one thus obtaining notice not optimal choose since can split into optimal way choose which gives us no other solution same substrings s notice while set substrings also length considered incorrect since larger total s contains only lowercase english
check if one string swap can make strings equal two strings equal string swap operation where choose two indices string necessarily swap characters these true possible make both strings equal performing most one string swap exactly one true swap first character last character make false impossible make them equal one string true two strings already so no string swap operation consist only lowercase english
number of burgers with no waste of ingredients two integers tomatoslices ingredients different burgers jumbo tomato slices cheese small tomato slices cheese so remaining tomatoslices equal remaining cheeseslices equal not possible make remaining tomatoslices cheeseslices equal tomatoslices cheeseslices make one jumbo burger small burgers we need tomato there no remaining tomatoslices cheeseslices there no way use all ingredients make small jumbo tomatoslices cheeseslices making jumbo burger there cheese remaining making small burgers there cheese cheeseslices
special binary string special binary strings binary strings following two equal every prefix binary string least many special binary string move consists choosing two special substrings swapping two strings consecutive last character first string exactly one index before first character second lexicographically largest resulting string possible after applying mentioned operations s strings this lexicographically largest string possible after some s either or s special binary
maximum white tiles covered by a carpet integer array tiles where represents every tile j range li j ri colored also integer length single carpet can placed maximum white tiles can covered tiles carpetlen place carpet starting tile covers white so we note there may other places where carpet covers white can shown carpet cannot cover more than white tiles carpetlen place carpet starting tile covers white so we li ri carpetlen tiles
partitioning into minimum number of deci-binary numbers decimal called each digits either or without any leading while string represents positive decimal minimum positive numbers needed so they sum up consists only does not contain any leading zeros represents positive
custom sort string two strings order all characters order unique sorted some custom order permute characters s so they match order order more character x occurs before character y then x should occur before y permuted any permutation s satisfies this order s appear so order should since does not appear can any position returned also valid order s order s consist lowercase english all characters order
count the number of vowel strings in range array string words two integers left string called vowel string starts vowel character ends vowel character where vowel characters vowel strings where i belongs inclusive range words left right vowel string because starts ends not vowel string because does not end vowel string because starts ends vowel strings mentioned range words left right vowel string because starts ends not vowel string because does not start vowel string because starts ends vowel string because starts ends vowel strings mentioned range consists only lowercase english left right
maximum erasure value array positive integers nums want erase subarray containing unique score get erasing subarray equal sum maximum score can get erasing exactly one array b called subarray forms contiguous subsequence equal some nums optimal subarray here nums optimal subarray here or
number of students doing homework at a given time two integer arrays starttime endtime integer ith student started doing their homework time finished time students doing their homework time more students where querytime lays interval starttime endtime querytime we have students first student started doing homework time finished time doing anything time second student started doing homework time finished time also doing anything time third student started doing homework time finished time only student doing homework time starttime endtime querytime only student doing their homework querytime
decode ways ii message containing letters can encoded into numbers using following decode encoded all digits must grouped then mapped back into letters using reverse mapping above may multiple can mapped grouping grouping note grouping invalid because cannot mapped into since different addition mapping encoded message may contain which can represent any digit encoded message may represent any encoded messages or decoding equivalent decoding any encoded messages can string s consisting digits ways decode since answer may very modulo s encoded message can represent any encoded messages or each these can decoded strings there total ways decode s encoded message can represent any encoded messages or each these encoded messages have ways decoded can decoded or there total ways decode s encoded message can represent any encoded messages or have ways being but only have there total ways decode digit or
maximum average subarray i integer array nums consisting integer find contiguous subarray whose length equal k maximum average value this any answer calculation error less than nums k maximum average nums k k
couples holding hands there couples sitting seats arranged row want hold people seats represented integer array row where id person sitting ith couples numbered first couple being second couple being so last couple being minimum swaps so every couple sitting side swap consists choosing any two then they stand up switch row we only need swap second third row all couples already seated side all elements row
magic squares in grid x magic square x grid filled distinct numbers such each both diagonals all have same row x col grid how many x subgrids subgrid grid following subgrid x magic while this one there only one magic square inside grid row col col
minimum time to visit a cell in a grid m x matrix grid consisting integers where represents minimum time required able visit cell which means can visit cell only when time visit greater than or equal standing cell matrix must move any adjacent cell four each move make takes minimum time required which can visit cell cannot visit then grid one paths we can take t we cell t we move cell possible because t we move cell possible because t we move cell possible because t we move cell possible because t we move cell possible because t we move cell possible because t we move cell possible because final time can shown minimum time grid there no path top left m m
maximum deletions on a string string s consisting only lowercase english one delete entire string or delete first i letters s first i letters s equal following i letters any i range i s then one could delete first two letters s get since first two letters s following two letters s both equal maximum operations needed delete all s delete first letters since next letters s delete all we used operations so can proven maximum operations note second operation we cannot delete again because next occurrence does not happen next s delete first letter since next letter s delete first letters since next letters s delete first letter since next letter s delete all we used operations so can proven maximum operations s each we can delete first letter s consists only lowercase english
peak index in a mountain array array arr mountain following properties there exists some i i such mountain array index i such must solve time arr arr arr arr guaranteed mountain
minimum score triangulation of polygon have convex polygon where each vertex integer integer array values where value ith vertex clockwise triangulate polygon into each value triangle product values total score triangulation sum these values over all triangles smallest possible total score can achieve some triangulation values polygon already score only triangle values there two possible or minimum score values minimum score triangulation score
graph connectivity with threshold we have cities labeled two different cities labels x y directly connected bidirectional road only x y share common divisor strictly greater than some more cities labels x y have road between them there exists integer z such all following x z y z z two array must determine each cities ai bi connected directly or there some path between array where true ith there path between ai or false there no threshold queries divisors each using underlined divisors above only cities share common so they only ones directly result each not connected not connected connected through path threshold queries divisors each same previous since threshold all divisors can since all numbers share all cities threshold queries only cities share common divisor which strictly greater than threshold so they only ones directly please notice there can multiple queries same pair nodes query equivalent query threshold bi cities ai bi
form array by concatenating subarrays of another array integer array groups length also integer array asked can choose disjoint subarrays array nums such ith subarray equal i subarray appears before ith subarray nums subarrays must same order true can do this false note subarrays disjoint only there no index k such belongs more than one subarray contiguous sequence elements within groups nums true can choose subarray one these subarrays disjoint they share no common groups nums false note choosing subarrays incorrect because they not same order must come before groups nums false note choosing subarrays invalid because they not they share common elements
number of visible people in a queue there people standing they numbered left right array heights distinct integers where represents height ith person can see another person their right queue everybody between shorter than both more ith person can see jth person i j array answer length where people ith person can see their right heights person can see person person can see person person can see person person can see person person can see person person can see no one since nobody right heights all values heights
binary tree maximum path sum path binary tree sequence nodes where each pair adjacent nodes sequence edge connecting node can only appear sequence most note path does not need pass through path sum path sum values root binary maximum path sum any root optimal path path sum root optimal path path sum nodes tree range
next greater element iv array integers each integer must find respective second greater second greater integer such j i there exists exactly one index k such i k there no such second greater integer considered array second greater integer integer array where second greater integer nums first integer greater than second integer greater than right second integer greater than right second integer greater than right there no integer greater than so second greater integer considered there no integer greater than so second greater integer considered we nums we since neither integer any integer greater than
reduction operations to make the array elements equal integer array your goal make all elements nums complete one follow these find largest value let index i value there multiple elements largest pick smallest find next largest value nums strictly smaller than let value reduce operations make all elements nums nums takes operations make all elements nums largest index nextlargest reduce nums largest index nextlargest reduce nums largest index nextlargest reduce nums nums all elements nums already nums takes operations make all elements nums largest index nextlargest reduce nums largest index nextlargest reduce nums largest index nextlargest reduce nums largest index nextlargest reduce nums
strictly palindromic number integer strictly palindromic every base b between string representation integer base b integer true strictly palindromic false string palindromic reads same forward false base which base which not not strictly palindromic so we note bases also not false we only consider base which not we
height checker school trying take annual photo all students asked stand single file line order let this ordering represented integer array expected where expected height ith student integer array heights representing current order students standing each height ith student line indices where heights indices do not heights all indices do not heights all indices
find the index of the first occurrence in a string two strings needle index first occurrence needle or needle not part haystack needle occurs index first occurrence index so we haystack needle did not occur so we haystack needle consist only lowercase english
largest triangle area array points plane points where area largest triangle can formed any three different answers within actual answer points five points shown above red triangle points yi all points
group anagrams array strings group anagrams can answer any anagram word or phrase formed rearranging letters different word or typically using all original letters exactly strs strs strs consists lowercase english
previous permutation with one swap array positive integers arr necessarily lexicographically largest permutation smaller than can made exactly one cannot then same note swap exchanges positions two numbers arr swapping arr this already smallest arr swapping
stamping the grid m x binary matrix grid where each cell either or then stamps size stampheight x we want fit stamps such they follow restrictions cover all empty do not cover any occupied we can put many stamps we stamps can overlap each stamps not allowed stamps must stay completely inside true possible fit stamps while following restrictions grid stampheight stampwidth true we have two overlapping stamps able cover all empty grid stampheight stampwidth false there no way fit stamps onto all empty cells without stamps going outside m m either or stampwidth
merge bsts to create single bst bst search root nodes separate bsts stored array trees each bst trees most no two roots have same one select two distinct indices i j such value stored one leaves equal root value replace leaf node remove root resulting bst possible form valid bst after performing or null impossible create valid bst search binary tree where each node satisfies following every node left subtree value strictly less than every node right subtree value strictly greater than leaf node no trees first pick merge into delete so trees second pick merge into delete so trees resulting shown valid so trees pick merge into delete so trees resulting tree shown this only valid operation can but resulting tree not valid so trees impossible perform any nodes each tree range each node input may have children but no no two roots trees have same all trees input valid
number of valid move combinations on chessboard there x chessboard containing pieces or string array pieces length where describes type or ith integer array positions also length where indicates ith piece currently coordinate when making move choose destination square piece travel toward stop rook can only travel horizontally or vertically direction or queen can only travel or diagonally direction bishop can only travel diagonally direction must make move every piece board move combination consists all moves performed all every each piece instantaneously travel one square towards their destination they not already all pieces start traveling move combination invalid two or more pieces occupy same valid move no two pieces start same may choose square piece already two pieces directly adjacent each valid them move past each other swap positions one pieces positions image above shows possible squares piece can move pieces positions image above shows possible squares piece can move pieces positions image above shows possible squares piece can move pieces only contains strings there most one queen yi each
number of segments in a string string segments segment defined contiguous sequence s my name five segments s s consists lowercase uppercase english or one following characters only space character s
design authentication manager there authentication system works authentication each user receive new authentication token expire timetolive seconds after token expiry time extended expire timetolive seconds after implement authenticationmanager constructs authenticationmanager sets int generates new token tokenid currenttime int renews unexpired token tokenid currenttime there no unexpired tokens request nothing returns unexpired tokens note token expires time another action happens time t or expiration takes place before other input output explanation authenticationmanager authenticationmanager new constructs authenticationmanager timetolive no token exists tokenid time so nothing generates new token tokenid time token tokenid only unexpired one time so generates new token tokenid time token tokenid expired time so time renew request nothing token tokenid unexpired time so renew request fulfilled now token expire time token tokenid expires time token tokenid expired time so currently no token so timetolive currenttime tokenid consists only lowercase all calls generate contain unique values values currenttime across all function calls strictly most calls made all functions
ransom note two strings ransomnote true ransomnote can constructed using letters magazine false each letter magazine can only used once ransomnote magazine false ransomnote magazine false ransomnote magazine true ransomnote magazine consist lowercase english
find unique binary string array strings nums containing unique binary strings each length binary string length does not appear there multiple may any nums does not appear would also nums does not appear would also nums does not appear would also either or all strings nums
binary subarrays with sum binary array nums integer subarrays sum subarray contiguous part nums goal subarrays bolded underlined nums goal either or goal
toeplitz matrix m x true matrix matrix toeplitz every diagonal same matrix true above diagonals each diagonal all elements so answer matrix false diagonal different m follow what matrix stored memory limited such can only load most one row matrix into memory what matrix so large can only load up partial row into memory
replace all digits with characters string s lowercase english letters even indices digits odd there function where c character x returns xth character after every odd index want replace digit s after replacing all guaranteed never exceed s digits replaced s digits replaced s consists only lowercase english letters all odd indices
longest subarray with maximum bitwise and integer array nums size consider subarray nums maximum possible bitwise other let k maximum value bitwise any subarray only subarrays bitwise equal k should length longest such bitwise array bitwise all numbers subarray contiguous sequence elements within nums maximum possible bitwise subarray longest subarray value so we nums maximum possible bitwise subarray longest subarray value so we
minimum cost to make at least one valid path in a grid m x each cell grid sign pointing next cell should visit currently this sign can which means go cell go which means go cell go which means go lower go which means go upper go notice there could some signs cells grid point outside initially start upper left cell valid path grid path starts upper left cell ends cell following signs valid path does not have can modify sign cell cost can modify sign cell one time minimum cost make grid have least one valid grid start point path change arrow down cost change arrow down cost change arrow down cost total cost grid can follow path grid m
number of distinct roll sequences integer roll fair dice determine total distinct sequences rolls possible such following conditions greatest common divisor any adjacent values sequence equal there least gap rolls between equal valued more value ith roll equal value jth then total distinct sequences since answer may very modulo two sequences considered distinct least one element some possible sequences some invalid sequences invalid since first third roll have equal value j invalid since greatest common divisor there total distinct sequences so we some possible sequences some invalid sequences since greatest common divisor not equal there total distinct sequences so we
unique email addresses every valid email consists local name domain separated besides lowercase email may contain one or more or local domain add periods between some characters local name part email mail sent there forwarded same address without dots local note this rule does not apply domain forward same email add plus local everything after first plus sign this allows certain emails note this rule does not apply domain forwarded possible use both these rules same array strings emails where we send one email each different addresses actually receive emails actually receive emails consist lowercase english each contains exactly one all local domain names local names do not start domain names end
count submatrices with all ones m x binary matrix submatrices have all mat there rectangles side there rectangles side there rectangles side there rectangle side there rectangle side total rectangles mat there rectangles side there rectangles side there rectangles side there rectangles side there rectangles side there rectangles side there rectangle side total rectangles either or
vowels of all substrings string sum vowels every substring substring contiguous sequence characters within due large answer may not fit signed please careful during word all possible substrings vowels have vowel each vowels total sum vowels word all possible substrings have vowel each have vowels each total sum vowels word there no vowels any substring word consists lowercase english
cherry pickup x grid representing field each cell one three possible means cell so can pass means cell contains cherry can pick up pass or means cell contains thorn blocks your maximum cherries can collect following rules starting position reaching moving right or down through valid path cells value or after reaching returning moving left or up through valid path when passing through path cell containing pick cell becomes empty cell there no valid path between then no cherries can grid player started went right right reach cherries picked up during this single matrix becomes player went left picking up one more total cherries picked up this maximum grid or
the number of employees which report to each employee sql schema employees column name type int name varchar int age int primary key this this table contains information about employees id manager they report some employees do not report anyone this we consider manager employee who least other employee reporting write sql query report ids names all employees who report directly average age reports rounded nearest result table ordered query result format following employees name age hercy null alice bob winston null name hercy hercy people report directly alice their average age which after rounding nearest
smallest sufficient team have list required skills list ith person contains list skills person consider sufficient set people such every required skill there least one person team who we can represent these teams index each team represents people skills any sufficient team smallest possible represented index each may answer any guaranteed answer people people consists lowercase english all strings consists lowercase english all strings every skill skill guaranteed sufficient team
largest component size by common factor integer array unique positive integers consider following there labeled there undirected edge between share common factor greater than size largest connected component nums nums nums all values nums
number of subarrays with gcd equal to k integer array nums integer subarrays nums where greatest common divisor elements subarray contiguous sequence elements within greatest common divisor array largest integer evenly divides all array nums k subarrays nums where greatest common divisor all elements nums k there no subarrays nums where greatest common divisor all k
jump game v array integers arr integer one step can jump index i i x i x x i x i x x can only jump index i index j all indices k between i j formally k can choose any index array start maximum indices can notice can not jump outside array any arr d can start index can jump note start index can only jump index cannot jump index because cannot jump index because index between index similarly cannot jump index index or index arr d can start any always cannot jump any arr d start index can visit all d
valid permutations for di sequence string s length where means or means permutation perm integers all integers range called valid permutation all valid then then valid permutations since answer may modulo s valid permutations s either or
minimum swaps to arrange a binary grid x binary one step can choose two adjacent rows grid swap grid said valid all cells above main diagonal minimum steps needed make grid or grid cannot main diagonal grid diagonal starts cell ends cell grid grid all rows swaps have no effect grid either or
string compression ii encoding string compression method works replacing consecutive identical characters or more concatenation character marking count characters compress string we replace replace thus compressed string becomes notice this we not adding after single string s integer need delete most k characters s such encoded version s minimum find minimum length encoded version s after deleting most k s k compressing s without deleting anything give us length deleting any characters or would most decrease length compressed string instance delete then we have s which compressed optimal way delete then compressed version s length s k we delete both resulting compressed string would length s k since k we cannot delete compressed string length k s contains only lowercase english
trapping rain water integers representing elevation map where width each bar compute how much water can trap after height above elevation map represented array this units rain water being height
expression add operators string num contains only digits integer all possibilities insert binary operators between digits num so resultant expression evaluates target note operands returned expressions should not contain leading num target both evaluate num target both evaluate num target there no expressions can created evaluate num consists only target
minimum difference between highest and lowest of k scores integer array where represents score ith also integer pick scores any k students array so difference between highest lowest k scores minimum possible nums k there one way pick one difference between highest lowest score minimum possible difference nums k there six ways pick two difference between highest lowest score difference between highest lowest score difference between highest lowest score difference between highest lowest score difference between highest lowest score difference between highest lowest score minimum possible difference k
maximum sum of 3 non-overlapping subarrays integer array nums integer find three subarrays length k maximum sum result list indices representing starting position each interval there multiple lexicographically smallest nums k subarrays correspond starting indices we could have also taken but answer would lexicographically nums k k
minimum reverse operations integer integer p range representing array arr length where all positions set except position p which set also integer array banned containing some positions ith position can perform multiple operations can choose subarray size k reverse arr should never go any positions other after each operation remains array ans where each i minimum reverse operations needed bring position i or subarray contiguous sequence elements within values independent all reverse array array containing values reverse p banned k this case k so there only one possible reverse operation we can which reversing whole placed position so amount operations we need position we can never place banned so answer positions one reverse operation we can bring index so answer position p banned k this case initially position so answer position we can perform reverse operations size currently located position so we need reverse subarray leave but reversing subarray makes position have which we move position making result all other positions p banned k this case we can only perform reverse operations size so never changes p k p all values banned unique
find the prefix common array of two arrays two integer permutations b length prefix common array b array c such equal count numbers present or before index i both prefix common array sequence integers called permutation contains all integers exactly b i no so i common so i common so i common so b i no so i only common so i common so guaranteed b both permutation
tallest billboard installing billboard want have largest billboard have two steel one each each steel support must equal collection rods can welded have rods lengths can weld them together make support length largest possible height your billboard cannot support rods we have two disjoint subsets which have same sum rods we have two disjoint subsets which have same sum rods billboard cannot so we
make array zero by subtracting equal amounts integer array one choose positive integer x such x less than or equal smallest element subtract x every positive element minimum operations make every element nums equal nums first choose x nums second choose x nums third choose x nums nums each element nums already so no operations
number of ways to wear different hats to each other there people types hats labeled integer array where list all hats preferred ith ways people wear different hats each since answer may too modulo hats there only one way choose hats first person choose hat second person choose hat last one hat hats there ways choose hats each person can choose hats labeled permutations contains list unique
actors and directors who cooperated at least three times sql schema actordirector column name type int int timestamp int timestamp primary key column this write sql query report provides pairs where actor cooperated director least three result table any query result format following actordirector timestamp only pair where they cooperated exactly
count the number of good subarrays integer array nums integer good subarrays subarray arr good there least k pairs indices such i j subarray contiguous sequence elements within nums k only good subarray array nums nums k there different good k
sort the matrix diagonally matrix diagonal diagonal line cells starting some cell either topmost row or leftmost column going direction until reaching matrix diagonal starting where mat x includes cells m x matrix mat sort each matrix diagonal ascending order resulting mat mat m
sort an array array integers sort array ascending order must solve problem without using any functions time complexity smallest space complexity nums after sorting positions some numbers not changed while positions other numbers changed nums note values nums not necessairly
number of unequal triplets in array array positive integers find triplets meet following i j k pairwise other triplets meet nums following triplets meet because because because since there we note not valid triplet because nums no triplets meet conditions so we
number of laser beams in a bank security devices activated inside binary string array bank representing floor plan which m x represents ith consisting means cell means cell security there one laser beam between any two security devices both conditions two devices located two different where each row i where i there no security devices ith laser beams one beam does not interfere nor join total laser beams bank between each following device there one there note there no beam between any device row any this because row contains security which breaks second bank there does not exist two devices located two different m either or
longest palindrome by concatenating two letter words array strings each element words consists two lowercase english create longest possible palindrome selecting some elements words concatenating them any each element can selected most length longest palindrome can impossible create any palindrome string reads same forward words one longest palindrome length note another longest palindrome can words one longest palindrome length note another longest palindrome can words one longest palindrome length note another longest palindrome can so consists lowercase english
find numbers with even number of digits array nums how many them contain even nums contains digits contains digits contains digit contains digit contains digits therefore only contain even nums only contains even
minimum difference in sums after removal of elements integer array nums consisting allowed remove any subsequence elements size exactly remaining elements divided into two equal first elements belonging first part their sum next elements belonging second part their sum difference sums two parts denoted sumfirst sumfirst sumsecond their difference sumfirst sumsecond their difference minimum difference possible between sums two parts after removal nums nums so thus we have remove element nums divide array into two equal we remove array difference sums two parts we remove array difference sums two parts we remove array difference sums two parts minimum difference between sums two parts nums here so we must remove elements divide remaining array into two parts containing two elements we remove resultant array difference sums obtain minimum we should remove resultant array becomes difference sums two parts can shown not possible obtain difference smaller than
remove boxes several boxes different colors represented different positive may experience several rounds remove boxes until there no box each time can choose some continuous boxes same color composed k k remove them get k k maximum points can boxes boxes boxes
day of the week corresponding day week input three integers representing month year answer one following values day month year day month year day month year dates valid dates between years
search in rotated sorted array there integer array nums sorted ascending order distinct prior being passed your nums possibly rotated unknown pivot index k k such resulting array might rotated pivot index become array nums after possible rotation integer index target or not must write algorithm runtime nums target nums target nums target all values nums nums ascending array possibly target
maximum number of balls in a box working ball factory where have balls numbered lowlimit up highlimit inclusive highlimit lowlimit infinite boxes numbered your job this factory put each ball box equal sum digits ball put box ball put box two integers lowlimit balls box most lowlimit highlimit box ball box most balls lowlimit highlimit box ball boxes have most balls balls lowlimit highlimit box ball box most balls lowlimit highlimit
steps to make array non-decreasing integer array one remove all elements where all i steps performed until nums becomes nums following steps step becomes step becomes step becomes we nums nums already we
snakes and ladders x integer matrix board where cells labeled boustrophedon style starting bottom left board alternating direction each start square each starting square do choose destination square next label range this choice simulates result standard die there always most regardless size next snake or must move destination snake or move game ends when reach square board square row r column c snake or ladder destination snake or ladder squares do not have snake or note only take snake or ladder most once per destination snake or ladder start another snake or do not follow subsequent snake or suppose board first your destination square follow ladder square but do not follow subsequent ladder least moves required reach square not possible reach board start square row column decide move square must take ladder square then decide move square must take snake square then decide move square must take ladder square then decide move square ending this lowest possible moves reach last so board either or range squares labeled do not have any ladders or
number of orders in the backlog integer array where each denotes amounti orders have been placed type ordertypei price ordertypei batch buy or batch sell note represents batch amounti independent orders same price order all orders represented placed before all orders represented all valid there backlog consists orders have not been backlog initially when order following order buy look sell order smallest price sell price smaller than or equal current buy they match sell order removed buy order added vice order sell look buy order largest price buy price larger than or equal current sell they match buy order removed sell order added total amount orders backlog after placing all orders since this can modulo orders here what happens orders type buy price there no sell so orders added orders type sell price there no buy orders prices larger than or equal so orders added order type sell price there no buy orders prices larger than or equal so this order added orders type buy price first orders matched sell orders least which these sell orders removed order matched sell order least which this sell order removed there no more sell orders so order added backlog buy orders price buy order price so total orders backlog orders here what happens orders type sell price there no buy so orders added orders type buy price they matched sell orders least price which those sell orders removed orders type buy price least price sell order so orders added order type sell price matched buy order highest which buy order removed backlog sell orders price buy orders price so total orders which equal amounti ordertypei either or
transform to chessboard x binary grid each can swap any two rows each or any two columns each minimum moves transform board into chessboard task chessboard board board where no no board one potential sequence moves first move swaps first second second move swaps second third board also note board top left also valid board no matter what sequence moves cannot end valid either or
print words vertically string all words vertically same order which they appear words returned list complete spaces when spaces not each word would put only one column one column there only one s each word printed s or not trailing spaces not s s contains only upper case english guaranteed there only one space between
check if string is transformable with substring sort operations two strings s transform string s into string t using following operation any choose substring s sort place so characters ascending applying operation underlined substring results true possible transform s into substring contiguous sequence characters within s t true can transform s into t using following sort index index s t true can transform s into t using following sort s t false s t consist only
minimum number of people to teach social network consisting m users some friendships between two users can communicate each other they know common integer array array friendships there languages numbered through set languages ith user denotes friendship between users ui can choose one language teach some users so all friends can communicate each minimum users need note friendships not meaning x friend y y friend this guarantee x friend languages friendships can either teach user second language or user first languages friendships teach third language users yielding two users m m ui vi all tuples unique contains only unique values
maximum consecutive floors without special floors alice manages company rented some floors building office alice decided some these floors should special used relaxation two integers bottom which denote alice rented all floors bottom top also integer array where denotes special floor alice designated maximum consecutive floors without special bottom top special following ranges consecutive floors without special total amount total amount total amount we maximum which bottom top special every floor rented special so we bottom top all values special
time based key-value store design data structure can store multiple values same key different time stamps retrieve value certain implement timemap initializes object data void string int stores key key value value time string int returns value such set called there multiple such returns value associated largest there no returns input output explanation timemap timemap new store key value along timestamp since there no value corresponding foo timestamp timestamp then only value timestamp store key value along timestamp key value consist lowercase english letters timestamp all timestamps timestamp set strictly most calls made set
sequentially ordinal rank tracker scenic location represented name attractiveness where name unique string among all locations score locations can ranked best higher better scores two locations then location lexicographically smaller name building system tracks ranking locations system initially starting no adding scenic one querying ith best location all locations already where i times system been queried current when system queried returns best location all locations already note test data generated so any queries does not exceed locations added implement sortracker initializes tracker void int adds scenic location name score string queries returns ith best where i times this method been invoked this input output explanation sortracker tracker new initialize tracker add location add location sorted best note branford precedes bradford due higher score this time so best add location sorted note alps precedes bradford even though they have same score this because lexicographically smaller than best location time add location sorted time add location sorted add location sorted sorted name consists lowercase english unique among all score any calls get does not exceed calls most calls total made add
letter combinations of a phone number string containing digits all possible letter combinations could answer any mapping digits letters like telephone note does not map any digits digits digits digit range
check if object instance of class write function checks value instance class or this object considered instance class object access there no constraints data types can passed value or class could func true object returned date constructor instance func class animal class dog extends animal true class animal class dog extends animal true dog subclass dog object instance both dog func false date constructor cannot logically instance func true note keyword would still considered instance because accesses
apply discount to prices sentence string separated words where each word can contain lowercase dollar sign word represents price sequence digits preceded dollar represent prices while do string sentence representing sentence integer each word representing apply discount price update word all updated prices should represented exactly two decimal string representing modified note all prices contain most sentence candies discount candies words which represent prices discount yields so replaced discount yields since we need have exactly decimal places after we replace sentence discount applying discount any price result words representing prices each them replaced sentence consists lowercase english sentence does not have leading or trailing all words sentence separated single all prices positive numbers without leading all prices have most discount
angle between hands of a clock two hour smaller angle formed between hour minute answers within actual value accepted hour minutes hour minutes hour minutes hour minutes
minimum fuel cost to report to the capital there tree undirected graph no structure country network consisting cities numbered exactly capital city city integer array roads where denotes there exists bidirectional road connecting cities ai there meeting representatives each meeting capital there car each integer seats indicates seats each representative can use car their city travel or change car ride another cost traveling between two cities one liter minimum liters fuel reach capital roads seats goes directly capital liter goes directly capital liter goes directly capital liter costs liters fuel can proven minimum liters fuel roads seats goes directly city liter go together city liter go together capital liter goes directly capital liter goes directly capital liter goes directly city liter go together capital liter costs liters fuel can proven minimum liters fuel roads seats no representatives need travel capital bi ai bi roads represents valid seats
make array empty integer array nums containing distinct can perform following operations until array first element smallest remove put first element end integer denoting operations takes make nums nums operation array nums operation array nums operation array all values nums
sort characters by frequency string sort decreasing order based frequency frequency character times appears sorted there multiple any s appears twice while both appear so must appear before both therefore also valid s both appear three so both valid note same characters must s also valid but note treated two different s consists uppercase lowercase english letters
longest substring without repeating characters string find length longest substring without repeating s answer length s answer length s answer length notice answer must subsequence not s consists english symbols
people whose list of favorite companies is not a subset of another list array favoritecompanies where list favorites companies ith person indices people whose list favorite companies not subset any other list favorites must indices increasing favoritecompanies person which subset corresponding person index person which subset other lists favorite companies not subset another answer favoritecompanies this case subset answer favoritecompanies all strings all lists favorite companies we sort alphabetically each list then all strings consist lowercase english letters
average salary excluding the minimum and maximum salary array unique integers salary where salary ith average salary employees excluding minimum maximum answers within actual answer salary minimum salary maximum salary average salary excluding minimum maximum salary salary minimum salary maximum salary average salary excluding minimum maximum salary all integers salary
course schedule ii there total numcourses courses have labeled numcourses array prerequisites where indicates must take course bi first want take course pair indicates take course have first take course ordering courses should take finish all there many valid any impossible finish all empty numcourses prerequisites there total courses take course should have finished course so correct course order numcourses prerequisites there total courses take course should have finished both courses both courses should taken after finished course so one correct course order another correct ordering numcourses prerequisites numcourses numcourses bi numcourses ai bi all pairs
minimum degree of a connected trio in a graph undirected integer which nodes graph array where each indicates there undirected edge between ui connected trio set three nodes where there edge between every pair degree connected trio edges where one endpoint other minimum degree connected trio or graph no connected edges there exactly one which edges form degree bolded figure edges there exactly three degree degree degree vi ui vi there no repeated
maximum xor of two numbers in an array integer array maximum result xor where i j nums maximum result xor nums
beautiful arrangement ii two integers construct list answer contains different positive integers ranging obeys following suppose this list answer then list exactly k distinct list there multiple valid any k three different positive integers ranging exactly distinct k three different positive integers ranging exactly distinct k
increment submatrices by one positive integer indicating we initially have x integer matrix mat filled also integer array each should do following add every element submatrix top left corner bottom right corner add all x y matrix mat after performing every queries diagram above shows initial matrix after first matrix after second first we add every element submatrix top left corner bottom right corner second we add every element submatrix top left corner bottom right corner queries diagram above shows initial matrix matrix after first first query we add every element
maximum good people based on statements there two types good person who always tells bad person who might tell truth might integer array statements size x represents statements made people about each more could one which represents statement made person i person j bad which represents statement made person i person j good represents no statement made person i about person no person ever makes statement about we have all i maximum people who can good based statements made statements each person makes single person states person person states person person states person take person assuming person good based statement made person person bad now we know sure person bad person based statement made person since person they could telling there contradiction this case this assumption this person also bad person lied their following person good there only one good person assuming person bad based statement made person since person they could telling following this person both bad explained following person bad but told there no good persons this case person good since person good person also good following person bad there two good persons we can see most persons good best so we note there more than one way arrive this statements each person makes single person states person person states person take person assuming person good based statement made person person bad person following person good there only one good person assuming person bad based statement made person since person they could telling following this person both following person bad but told there no good persons this case person good following person bad there only one good person we can see one person good best so we note there more than one way arrive this either or
relative ranks integer array score size where score ith athlete all scores guaranteed athletes placed based their where place athlete highest place athlete highest so placement each athlete determines their place rank place rank place rank place nth place their rank their placement xth place rank array answer size where rank ith score placements score placements all values score
set intersection size at least two integer array intervals where represents all integers starti endi containing set array nums where each interval intervals least two integers intervals then containing minimum possible size containing intervals let nums can shown there cannot any containing array size intervals let nums can shown there cannot any containing array size intervals let nums can shown there cannot any containing array size starti endi
decode the slanted ciphertext string originaltext encoded using slanted transposition cipher string encodedtext help matrix having fixed rows originaltext placed first blue cells filled followed red then yellow so until we reach end arrow indicates order which cells all empty cells filled columns chosen such rightmost column not empty after filling encodedtext then formed appending all characters matrix characters blue cells appended first then red so finally yellow arrow indicates order which cells originaltext rows then we encode following blue arrows depict how originaltext placed red arrows denote order which encodedtext above encodedtext ie encoded string encodedtext rows original string originaltext does not have any trailing spaces test cases generated such there only one possible encodedtext ie rows this same described problem encodedtext eed l te rows love figure above denotes matrix used encode blue arrows show how we can find originaltext encodedtext rows since there only both originaltext encodedtext encodedtext consists lowercase english letters encodedtext valid encoding some originaltext does not have trailing rows testcases generated such there only one possible
minimum swaps to group all 1's together ii swap defined taking two distinct positions array swapping values circular array defined array where we consider first element last element binary circular array minimum swaps required group all present array together any nums here few ways group all using using using swaps circular property there no way group all together minimum swaps required nums here few ways group all using swaps circular property using there no way group all together or minimum swaps required nums all already grouped together due circular property minimum swaps required either or
count pairs of nodes undirected graph defined integer integer array edges where indicates there undirected edge between ui also integer array let defined edges connected either node or answer jth query pairs nodes satisfy both following b array answers such answer jth note there can multiple edges between same two edges queries calculations shown table answers each queries all pairs have value greater than all pairs except have value greater than edges queries vi ui vi
numbers at most n given digit set array digits which sorted can write numbers using each many times we digits we may write numbers such positive integers can generated less than or equal integer digits numbers can written digits we can write one digit two digit three digit four digit five digit six digit seven digit eight digit nine digit this integers can written using digits digits digit all values digits digits sorted
check if a parentheses string can be valid parentheses string string consisting only valid any following conditions can written ab concatenated where b valid parentheses can written where valid parentheses parentheses string s string both length locked binary string consisting only each index i cannot change but can change either or true can make s valid parentheses s locked true so we cannot change or we change while leaving unchanged make s s locked true we do not need make any changes because s already s locked false locked permits us change changing either or not make s either or either or
rearrange products table sql schema products column name type int int int int primary key this each row this table indicates price different product not available price null write sql query rearrange products table so each row product not available do not include row store combination result result table any query result format following products null store price product available all three stores prices product available price price product not available
count square sum triples square triple triple where c integers integer square triples such c square triples square triples
remove comments remove comments program source array strings source where ith line source this represents result splitting original source code string newline character there two types line block string denotes line which represents rest characters right same line should string denotes block which represents all characters until next occurrence should occurrences happen reading line line left string does not yet end block ending would overlapping first effective comment takes precedence over string occurs block string occurs line or block also certain line code empty after removing must not output each string answer list there no control single or double quote source s not not test nothing else such defines or macros interfere guaranteed every open block comment eventually so outside line or block comment always starts new implicit newline characters can deleted block please see examples below after removing comments source source code same source program variable declaration this multiline comment testing b b line line code visualized program int variable declaration int this test multiline comment testing b string denotes block including line lines string denotes line line line output code visualized int int b source original source string where we have bolded newline after implicit newline characters leaving string which when delimited newline characters becomes consists printable ascii every open block comment eventually there no or
capitalize the title string title consisting one or more words separated single where each word consists english capitalize string changing capitalization each word such length word or change all letters change first letter uppercase remaining letters capitalized title since all words have length least first letter each word remaining letters title letter each letter each word length so all remaining words have length least so first letter each remaining word remaining letters title love love word length so remaining words have length least so first letter each remaining word remaining letters title consists words separated single space without any leading or trailing each word consists uppercase lowercase english letters
abbreviating the product of a range two positive integers left right left calculate product all integers inclusive range since product may very abbreviate following these count all trailing zeros product remove let us denote this count there trailing zeros there trailing zeros denote remaining digits product d then express product where denotes first digits denotes last digits product after removing all trailing d we keep we express but represented represent product string represented string denoting abbreviated product all integers inclusive range left right product there no trailing so remains abbreviation end since digits which less than we do not have abbreviate final representation left right product there trailing which we remove get abbreviation end digits after removing trailing zeros so we do not abbreviate abbreviated product left right product left right
partition array into two arrays to minimize sum difference integer array nums need partition nums into two arrays length minimize absolute difference sums partition put each element nums into one two minimum possible absolute nums one optimal partition absolute difference between sums arrays nums one optimal partition absolute difference between sums arrays nums one optimal partition absolute difference between sums arrays
subarray sum equals k array integers nums integer total subarrays whose sum equals subarray contiguous sequence elements within nums k nums k k
average value of even numbers that are divisible by three integer array nums positive average value all even integers divisible note average elements sum elements divided rounded down nearest nums even numbers divisible nums there no single satisfies so
best time to buy and sell stock array prices where price stock ith want maximize your profit choosing single day buy one stock choosing different day future sell maximum profit can achieve this cannot achieve any prices buy day sell day profit note buying day selling day not allowed because must buy before prices this no transactions done max profit
xor operation in an array integer integer define array nums where start i bitwise xor all elements start array nums equal where where corresponds bitwise xor start array nums equal where start
number of zero-filled subarrays integer array subarrays filled subarray contiguous sequence elements within nums there occurrences there occurrences there no occurrence subarray size more than filled we nums there occurrences there occurrences there occurrence there no occurrence subarray size more than filled we nums there no subarray filled we
design memory allocator integer representing size memory all memory units initially have memory allocator following allocate block size consecutive free memory units assign id free all memory units id note multiple blocks can allocated same should free all memory units even they allocated different implement allocator initializes allocator object memory array size int int find leftmost block size consecutive free memory units allocate id first such block does not int free all memory units id memory units have input output explanation allocator loc new initialize memory array size all memory units initially leftmost first index memory array becomes we leftmost first index memory array becomes we leftmost first index memory array becomes we free all memory units mid memory array becomes we since there only unit mid leftmost first index memory array becomes we leftmost first index memory array becomes we leftmost first index memory array becomes we free all memory units mid memory array becomes we since there units mid we can not find any free block consecutive free memory so we free all memory units mid memory array remains same since there no memory unit mid we mid most calls made allocate
maximum number of events that can be attended ii array events where ith event starts startdayi ends attend this receive value also integer k which represents maximum events can can only attend one event choose attend must attend entire note end day cannot attend two events where one them starts other ends same maximum sum values can receive attending events k choose green total value events k choose event total value notice cannot attend any other event they do not have attend k events k although events do not can only attend pick highest valued k k startdayi enddayi valuei
insertion sort list head singly linked sort list using insertion sorted steps insertion sort insertion sort consuming one input element each repetition growing sorted output each insertion sort removes one element input finds location belongs within sorted list inserts repeats until no input elements following graphical insertion sort partially sorted list initially contains only first element one element removed input data inserted into sorted list each head head nodes list range
maximum level sum of a binary tree root binary level root level children so smallest level x such sum all values nodes level x root level sum level sum level sum so we level maximum sum which level root nodes tree range
reverse string write function reverses input string array characters must do this modifying input array extra s s printable ascii
maximum difference between node and ancestor root binary find maximum value v which there exist different nodes b where v ancestor node ancestor b any child equal b or any child ancestor root we have various some which below among all possible maximum value obtained root nodes tree range
build array where you can find the maximum exactly k comparisons three integers m consider following algorithm find maximum element array positive should build array arr which following arr exactly m where i after applying mentioned algorithm value equal ways build array arr under mentioned answer may grow answer must computed modulo m k possible arrays m k there no possible arrays satisify mentioned m k only possible array m k
the number of weak characters in the game playing game contains multiple each characters two main attack integer array properties where represents properties ith character character said weak any other character both attack defense levels strictly greater than this attack defense more character i said weak there exists another character j where attackj attacki defensej weak properties no character strictly greater attack defense than properties first character weak because second character strictly greater attack properties third character weak because second character strictly greater attack defensei
rearrange array to maximize prefix score integer array can rearrange elements nums any order let prefix array containing prefix sums nums after rearranging other sum elements i nums after rearranging score nums positive integers array maximum score can nums we can rearrange array into nums prefix so score can shown maximum score we can nums any rearrangement array result score
valid anagram two strings s true t anagram false anagram word or phrase formed rearranging letters different word or typically using all original letters exactly s t true s t false s t consist lowercase english follow what inputs contain unicode how would adapt your solution such
prefix and suffix search design special dictionary searches words prefix implement wordfilter initializes object words string returns index word which prefix pref suffix there more than one valid largest there no such word input output explanation wordfilter wordfilter new because word index prefix suffix pref suff consist lowercase english letters most calls made function
maximum number of words found in sentences sentence list words separated single space no leading or trailing array strings where each represents single maximum words appear single sentences bob love think so great thanks very first bob love words second think so words third great thanks very words maximum words single sentence comes third which sentences possible multiple sentences contain same this second third sentences have same consists only lowercase english letters does not have leading or trailing all words separated single
coin change integer array coins representing coins different denominations integer amount representing total amount fewest coins need make up amount money cannot made up any combination may assume have infinite each kind coins amount coins amount coins amount amount
buddy strings two strings s true can swap two letters s so result equal swapping letters defined taking two indices i j such i j swapping characters swapping indices results s goal true can swap get which equal s goal false only letters can swap which results s goal true can swap get which equal s goal consist lowercase
implement rand10() using rand7() api generates uniform random integer range write function generates uniform random integer range can only call api call any other please do not use random each test case have one internal argument times your implemented function called while note this not argument passed follow what expected value calls could minimize calls
count collisions on a road there cars infinitely long cars numbered left right each car present unique string directions length can either or denoting whether ith car moving towards towards or staying current point each moving car same collisions can calculated when two cars moving opposite directions collide each collisions increases when moving car collides stationary collisions increases after cars involved can no longer move stay point where they other than cars cannot change their state or direction total collisions happen directions collisions happen road cars collide each since they moving opposite collisions becomes cars collide each since car collisions becomes cars collide each since car collisions becomes cars collide each after car collides car stay point collision get hit car collisions becomes total collisions happen road directions no cars collide each total collisions happen road either or
generate fibonacci sequence write generator function returns generator object which yields fibonacci fibonacci sequence defined relation xn first few numbers series callcount const gen callcount never called so nothing outputted callcount
swapping nodes in a linked list head linked integer head linked list after swapping values kth node beginning kth node end list head k head k nodes list k
substring xor queries binary string integer array queries where ith find shortest substring s whose decimal yields secondi when bitwise xored other val firsti answer ith query endpoints substring or no such substring there multiple choose one minimum array ans where answer ith substring contiguous sequence characters within s queries first query substring range which decimal value hence answer first query second substring range decimal value returned second s queries this there no substring answers hence s queries this substring range decimal value answer either or secondi
last substring in lexicographical order string last substring s lexicographical s substrings lexicographically maximum substring s s contains only lowercase english
target sum integer array nums integer want build expression out nums adding one symbols before each integer nums then concatenate all nums can add before before concatenate them build expression different expressions can which evaluates nums target there ways assign symbols make sum nums target nums target target
minimum amount of time to fill cups have water dispenser can dispense hot every can either fill up cups different types or cup any type integer array amount length where denote hot water cups need fill minimum seconds needed fill up all amount one way fill up cups second fill up cold cup warm second fill up warm cup hot second fill up warm cup hot second fill up warm can proven minimum seconds amount one way fill up cups second fill up cold hot second fill up cold warm second fill up cold warm second fill up warm hot second fill up cold hot second fill up cold warm second fill up hot amount every we fill up cold
categorize box according to criteria four integers representing dimensions mass string representing category box any dimensions box greater or equal volume box greater or equal mass box greater or equal box both then category box neither nor then category box but not then category box but not then category note volume box product width length width height mass none dimensions box greater or equal volume so cannot categorized however mass so box since box not but we length width height mass none dimensions box greater or equal volume so cannot categorized mass also less than so cannot categorized since neither two above we height mass
robot bounded in circle infinite robot initially stands faces note north direction positive direction south direction negative direction east direction positive direction west direction negative direction robot can receive one three go straight turn degrees left turn degrees right clockwise robot performs instructions repeats them true only there exists circle plane such robot never leaves instructions true robot initially facing north move one move one turn degrees turn degrees move one move one repeating robot goes into based we instructions false robot initially facing north move one move one repeating keeps advancing north direction does not go into based we instructions true robot initially facing north move one turn degrees move one turn degrees move one turn degrees move one turn degrees repeating robot goes into based we
greatest common divisor of strings two strings s we say divides only s t t t concatenated itself one or more two strings largest string x such x divides both consist english uppercase
interleaving string strings find whether formed interleaving interleaving two strings s t configuration where s t divided into m substrings such s sn t tm interleaving or b concatenation strings true one way obtain split into into interleaving two we get since can obtained interleaving we false notice how impossible interleave any other string obtain true consist lowercase english follow could solve using only additional memory
hamming distance hamming distance between two integers positions which corresponding bits two integers x hamming distance between x y above arrows point positions where corresponding bits x y y
find greatest common divisor of array integer array greatest common divisor smallest largest greatest common divisor two numbers largest positive integer evenly divides both nums smallest nums largest nums greatest common divisor nums smallest nums largest nums greatest common divisor nums smallest nums largest nums greatest common divisor
search insert position sorted array distinct integers target index target index where would inserted must write algorithm runtime nums target nums target nums target nums contains distinct values sorted ascending target
path sum root binary tree integer true tree path such adding up all values along path equals leaf node no root targetsum true path target sum root targetsum false there two paths sum sum there no path sum root targetsum false since tree there no nodes tree range targetsum
finding pairs with a certain sum two integer arrays tasked implement data structure supports queries two add positive integer element index array count pairs such equals value i j implement findsumpairs initializes findsumpairs object two integer arrays void int adds val apply int returns pairs such input output explanation findsumpairs findsumpairs new pairs make pairs make now pairs make pair makes now now pairs make pairs make index val tot most calls made add count
count number of nice subarrays array integers nums integer continuous subarray called nice there k odd numbers nice nums k only odd numbers nums k there no odd numbers nums k k
maximum rows covered by columns m x binary matrix matrix integer which denotes distinct columns must select let us consider s set columns selected row row covered s each cell col where col present s no cell row value need choose numselect columns such rows covered maximum rows can covered set numselect matrix numselect one possible way cover rows shown diagram we choose s row covered because no occurrences row covered because columns value present row not covered because but not present row covered because present we can cover three note s also cover but can shown no more than three rows can matrix numselect selecting only column result both rows being covered since entire matrix we m either or numselect
number of substrings with only 1s binary string substrings all characters since answer may too modulo s there substring total only s substring shown times s each substring contains only either or
reformat date date string form day month day set month set year range convert date string format yyyy denotes digit mm denotes digit dd denotes digit date oct date jun date may dates guaranteed so no error handling
minimum area rectangle ii array points plane points where minimum area any rectangle formed these sides not necessarily parallel x y there not any such answers within actual answer points minimum area rectangle occurs area points minimum area rectangle occurs area points there no possible rectangle form these yi all points
form largest integer with digits that add up to target array integers cost integer maximum integer can paint under following cost painting digit total cost used must equal integer does not have since answer may very there no way paint any integer cost target cost paint digit digit then could also paint but largest digit cost cost target cost paint digit digit then cost target impossible paint any integer total cost equal target
construct string with repeat limit string s integer construct new string repeatlimitedstring using characters s such no letter appears more than repeatlimit times do not have use all characters lexicographically largest repeatlimitedstring string lexicographically larger than string b first position where b string letter appears later alphabet than corresponding letter first characters do not then longer string lexicographically larger s repeatlimit we use all characters s construct repeatlimitedstring letter appears most time letter appears most times letter appears most times no letter appears more than repeatlimit times row string valid string lexicographically largest repeatlimitedstring possible so we note string lexicographically larger but letter appears more than times so not valid s repeatlimit we use only some characters s construct repeatlimitedstring letter appears most times letter appears most times no letter appears more than repeatlimit times row string valid string lexicographically largest repeatlimitedstring possible so we note string lexicographically larger but letter appears more than times so not valid repeatlimit s consists lowercase english
linked list random node singly linked random value linked each node must have same probability being implement solution initializes object head list int chooses node randomly list returns all nodes list should equally likely input output explanation solution solution new should either or each element should have equal probability nodes linked list range most calls made follow what linked list extremely large length unknown could solve this efficiently without using extra
the skyline problem skyline outer contour silhouette formed all buildings city when viewed locations heights all skyline formed these buildings geometric information each building array buildings where lefti x coordinate left edge ith righti x coordinate right edge ith heighti height ith may assume all buildings perfect rectangles grounded absolutely flat surface height skyline should represented list sorted their form each key point left endpoint some horizontal segment skyline except last point which always used mark termination where rightmost building any ground between leftmost rightmost buildings should part there must no consecutive horizontal lines equal height output not three lines height should merged into one final output buildings figure shows buildings figure b shows skyline formed those red points figure b represent key points output buildings lefti righti heighti buildings sorted lefti
successful pairs of spells and potions two positive integer arrays spells length m where represents strength ith spell represents strength jth also integer spell potion pair considered successful product their strengths least integer array pairs length where potions form successful pair ith spells potions success pairs pairs pairs spells potions success pairs pairs pairs m m success
print foobar alternately suppose following class foobar public void i i public void i i same instance foobar passed two different thread call while thread b call modify program output there two threads being fired one them calls while other calls being output being output
longest valid parentheses string containing just characters length longest valid parentheses substring s longest valid parentheses substring s longest valid parentheses substring s or
number of distinct averages integer array nums even long nums not must find minimum nums remove find maximum nums remove calculate average two removed average two numbers b average distinct averages calculated using above note when there tie minimum or maximum any can nums remove average nums remove average nums remove average since there distinct numbers among we nums there only one average calculated after removing so we
super pow your task calculate ab mod where positive integer b extremely large positive integer form b b b b does not contain leading
maximum binary tree integer array nums no maximum binary tree can built recursively nums using following create root node whose value maximum value recursively build left subtree subarray prefix left maximum recursively build right subtree subarray suffix right maximum maximum binary tree built nums recursive calls largest value left prefix right suffix largest value left prefix right suffix empty so no largest value left prefix right suffix empty so no only one so child node value largest value left prefix right suffix only one so child node value empty so no nums all integers nums
find n unique integers sum up to zero integer any array containing unique integers such they add up these arrays also accepted
longest nice subarray array nums consisting positive we call subarray nums nice bitwise every pair elements different positions subarray equal length longest nice subarray contiguous part note subarrays length always considered nums longest nice subarray this subarray satisfies can proven no longer nice subarray can so we nums length longest nice subarray any subarray length can
minimum adjacent swaps for k consecutive ones integer integer nums comprises only one can choose two adjacent indices swap their minimum moves required so nums k consecutive nums k nums could have consecutive nums k leftmost can shifted right until nums nums k nums already consecutive or k
cells with odd values in a matrix there m x matrix initialized all there also array indices where each represents location perform some increment operations each location do both increment all cells row increment all cells column cells matrix after applying increment all locations m indices initial matrix after applying first increment becomes final matrix which contains odd m indices final matrix there no odd numbers final ri m ci follow could solve this m time only extra
sort array by parity integer array move all even integers beginning array followed all odd any array satisfies this nums outputs would also nums
find in mountain array problem interactive may recall array arr mountain array only there exists some i i such mountain array minimum index such such index does not cannot access mountain array may only access array using mountainarray returns element array index k returns length submissions making more than calls judged wrong any solutions attempt circumvent judge result array target exists minimum which array target does not exist so we target
count the number of ideal arrays two integers which used describe ideal integer array arr length considered ideal following conditions every value i every divisible i distinct ideal arrays length since answer may very modulo maxvalue following possible ideal arrays starting value arrays starting value arrays starting value arrays starting value arrays starting value there total distinct ideal maxvalue following possible ideal arrays starting value no other distinct values distinct value distinct value arrays starting value arrays starting value there total distinct ideal maxvalue
kth smallest number in multiplication table nearly everyone used multiplication multiplication table size m x integer matrix mat where i j three integers kth smallest element m x multiplication m k smallest m k smallest k m
maximum candies you can get from boxes have boxes labeled four containedboxes ith box open ith box candies ith list labels boxes can open after opening ith list boxes found inside ith integer array initialboxes contains labels boxes initially can take all candies any open box can use keys open new boxes also can use boxes find maximum candies can get following rules status candies keys containedboxes initialboxes initially box find candies boxes box closed do not have key so open box find candies key box box box find candies box but not find key box so box remain total candies collected status candies keys containedboxes initialboxes have initially box opening can find boxes their total candies either or all values all values each box contained one box
binary tree level order traversal root binary level order traversal left level root root root nodes tree range
cinema seat allocation cinema rows numbered there ten seats each labelled shown figure array reservedseats containing numbers seats already means seat located row labelled already maximum groups can assign cinema group occupies four adjacent seats one single seats across aisle not considered but there exceptional case which aisle split aisle split group which means have two people each reservedseats figure above shows optimal allocation four where seats mark blue already reserved contiguous seats mark orange one reservedseats reservedseats all
sudoku solver write program solve sudoku puzzle filling empty sudoku solution must satisfy all following each digits must occur exactly once each each digits must occur exactly once each each digits must occur exactly once each character indicates empty board input board shown above only valid solution shown digit or guaranteed input board only one
maximum product of two elements in an array array integers choose two different indices i j maximum value nums choose indices get maximum nums choosing indices get maximum value nums
divide nodes into the maximum number of groups positive integer representing nodes undirected nodes labeled also integer array where indicates there bidirectional edge between nodes ai notice graph may divide nodes graph into m groups such each node graph belongs exactly one every pair nodes graph connected edge ai belongs group index bi belongs group index then maximum groups maximum into which can divide impossible group nodes edges shown image add node first add node second add nodes third add nodes fourth we can see every edge can shown we create fifth group move any node third or fourth group least edges not edges we add node first node second node third group satisfy first two we can see third edge not can shown no grouping bi ai bi there most one edge between any pair
reverse prefix of word string word character reverse segment word starts index ends index first occurrence ch character ch does not exist do word ch then should reverse segment starts ends resulting string resulting word ch first occurrence index reverse part word resulting string word ch first only occurrence index reverse part word resulting string word ch does not exist should not do any reverse resulting string word consists lowercase english ch lowercase english
strong password checker password considered strong below conditions all least characters most contains least one lowercase least one uppercase least one does not contain three repeating characters row but string minimum steps required make password password already one insert one character delete one character or replace one character password another password password password password consists dot or exclamation mark
add edges to make degrees of all nodes even there undirected graph consisting nodes numbered integer array edges where indicates there edge between nodes ai graph can can add most two additional edges this graph so there no repeated edges no true possible make degree each node graph otherwise degree node edges connected edges true above diagram shows valid way adding every node resulting graph connected even edges true above diagram shows valid way adding two edges false not possible obtain valid graph adding most bi ai bi there no repeated
divide two integers two integers dividend divide two integers without using mod integer division should truncate toward which means losing fractional would truncated would truncated quotient after dividing dividend assume we dealing environment could only store integers within signed integer this quotient strictly greater than then quotient strictly less than then dividend divisor which truncated dividend divisor which truncated divisor divisor
bitwise ors of subarrays integer array distinct bitwise ors all subarrays bitwise or subarray bitwise or each integer bitwise or subarray one integer subarray contiguous sequence elements within arr there only one possible arr possible subarrays these yield results there unique so answer arr possible results
delete columns to make sorted iii array strings all same we may choose any deletion we delete all characters those indices each we have strs deletion indices then final array after deletions suppose we chose set deletion indices answer such after final array every string lexicographic so minimum possible value strs after deleting columns final array strs both these rows individually lexicographic order note array strs not necessarily lexicographic strs we delete less than only row not lexicographically strs all rows already lexicographically consists lowercase english
decode xored array there hidden integer array arr consists encoded into another integer array encoded length such xor arr then encoded encoded also integer first element original array can proved answer exists encoded first arr then first encoded xor xor xor encoded first first
cracking the safe there safe protected password sequence digits where each digit can range k safe peculiar way checking when enter checks most recent digits entered each time type correct password enter after typing most recent digits which after typing most recent digits which after typing most recent digits which after typing most recent digits which after typing most recent digits which after typing most recent digits which correct safe any string minimum length unlock safe some point entering k password single so enter each would also unlock k each possible typed starting typed starting typed starting typed starting thus unlock would also unlock k kn
next greater node in linked list head linked list each node find value next greater each find value first node next strictly larger value than integer array answer where value next greater node ith node ith node does not have next greater set head head nodes list
valid sudoku determine x sudoku board only filled cells need validated according following each row must contain digits without each column must contain digits without each nine x grid must contain digits without sudoku board could valid but not necessarily only filled cells need validated according mentioned board true board false same except top left corner being modified since there two top left digit or
minimum size subarray sum array positive integers nums positive integer minimal length subarray whose sum greater than or equal there no such target nums subarray minimal length under problem target nums target nums target follow have figured out try coding another solution which time complexity
construct binary tree from preorder and postorder traversal two integer preorder postorder where preorder preorder traversal binary tree distinct values postorder postorder traversal same reconstruct binary there exist multiple can any preorder postorder preorder postorder all values preorder all values postorder guaranteed preorder postorder preorder traversal postorder traversal same binary
find longest awesome substring string awesome substring substring s such we can make any swaps order make length maximum length awesome substring s longest awesome we can form palindrome some s s longest awesome we can form palindrome some s consists only
island perimeter row x col grid representing map where represents land represents grid cells connected grid completely surrounded there exactly one island one or more connected land island have meaning water inside connected water around one cell square side length grid width height exceed determine perimeter grid perimeter yellow stripes image grid grid row col col or there exactly one island
matchsticks to square integer array matchsticks where length ith want use all matchsticks make one should not break any but can link them each matchstick must used exactly one true can make this square false matchsticks true can form square length one side square came two sticks length matchsticks false cannot find way form square all
longest turbulent subarray integer array length maximum size turbulent subarray subarray turbulent comparison sign flips between each adjacent pair elements more subarray arr said turbulent only i k when k when k i k when k when k arr arr arr
minimum operations to make array equal have array arr length where all valid values i i one can select two indices x y where y subtract add perform goal make all elements array guaranteed all elements array can made equal using some integer length minimum operations needed make all elements arr arr first operation choose x y this leads arr second operation choose x y thus arr
minimum deletions to make array beautiful integer array array nums beautiful all i note empty array considered can delete any elements when delete all elements right deleted element shifted one unit left fill gap created all elements left deleted element remain minimum elements delete nums make nums can delete either or make nums which can proven need least deletion make nums nums can delete make nums which can proven need least deletions make nums
find the most competitive subsequence integer array nums positive integer most competitive subsequence nums size subsequence resulting sequence obtained erasing some elements we define subsequence more competitive than subsequence b same first position where b subsequence less than corresponding more competitive than because first position they differ final less than nums k among set every possible most nums k k
design twitter design simplified version twitter where users can post another able see most recent tweets news implement twitter initializes your twitter void int composes new tweet id tweetid user each call this function made unique retrieves most recent tweet ids news each item news feed must posted users who user followed or user tweets must ordered most recent least void int user id followerid started following user id void int user id followerid started unfollowing user id input output explanation twitter twitter new user posts new tweet user news feed should list tweet id user follows user user posts new tweet user news feed should list tweet ids tweet id should precede tweet id because posted after tweet id user unfollows user user news feed should list tweet id since user no longer following user followeeid tweetid all tweets have unique most calls made
moving stones until consecutive ii there some stones different positions integer array positions call stone endpoint stone smallest or largest one pick up endpoint stone move unoccupied position so no longer endpoint stones stones cannot move endpoint stone position since moving any position or still keep stone endpoint game ends when cannot make any more moves stones three consecutive integer array answer length minimum moves can maximum moves can stones we can move one move finish we can move two moves finish stones we can move then finish we can move finish notice we cannot move finish because would illegal all values stones
solving questions with brainpower integer array questions where array describes questions where have process questions order starting question make decision whether solve or skip each solving question i earn pointsi points but unable solve each next brainpoweri skip question get make decision next questions question earn points but unable solve questions question skipped question earn points but unable solve questions maximum points can earn questions maximum points can earned solving questions solve question earn unable solve next questions unable solve questions solve question earn points total points there no other way earn or more questions maximum points can earned solving questions skip question solve question earn unable solve next questions unable solve questions solve question earn points total points there no other way earn or more brainpoweri
next greater element iii positive integer find smallest integer which exactly same digits existing integer greater value than no such positive integer note returned integer should fit there valid answer but does not fit
count palindromic subsequences string digits palindromic subsequences s having length since answer may very modulo string palindromic reads same forward subsequence string can derived another string deleting some or no characters without changing order remaining s there possible subsequences length two them equal s all subsequences which s only two palindromic subsequences s consists
prime in diagonal integer array largest prime lies least one diagonals no prime present any note integer prime greater than no positive integer divisors other than integer val one diagonals nums there exists integer i which val or i which i above one diagonal another diagonal nums numbers only numbers present least one since largest we nums numbers all present least one largest so we
count vowel substrings of a string substring contiguous sequence characters within vowel substring substring only consists vowels all five vowels present string vowel substrings word vowel substrings word follows word not all vowels so there no vowel word vowel substrings word follows word consists lowercase english letters
delete leaves with a given value binary tree root integer delete all leaf nodes value note once delete leaf node value parent node becomes leaf node value should also deleted need continue doing until root target leaf nodes green value removed after new nodes become leaf nodes value root target root target leaf nodes green value removed each nodes tree range target
pacific atlantic water flow there m x rectangular island borders both pacific ocean atlantic pacific ocean touches left top atlantic ocean touches right bottom island partitioned into grid square m x integer matrix heights where represents height above sea level cell coordinate island receives lot rain water can flow neighboring cells directly west neighboring height less than or equal current water can flow any cell adjacent ocean into list grid coordinates result where denotes rain water can flow cell both pacific atlantic heights following cells can flow pacific atlantic shown pacific ocean atlantic ocean pacific ocean atlantic ocean pacific ocean atlantic ocean pacific ocean atlantic ocean pacific ocean atlantic ocean pacific ocean atlantic ocean pacific ocean atlantic ocean note there other possible paths these cells flow pacific atlantic heights water can flow only cell pacific atlantic m
reverse linked list head singly linked reverse reversed head head head nodes list range follow linked list can reversed either iteratively or could implement
longest well-performing interval we list hours worked per day day considered tiring day only hours worked greater than interval interval days which tiring days strictly larger than length longest hours longest interval hours
shortest path in binary matrix x binary matrix length shortest clear path there no clear clear path binary matrix path cell cell such all visited cells path all adjacent cells path connected they different they share edge or length clear path visited cells this grid grid grid or
minimum cost to make array equal two arrays nums cost consisting each positive can do following operation any increase or decrease any element array nums cost doing one operation ith element minimum total cost such all elements array nums become nums cost we can make all elements equal following increase element one cost decrease element one cost decrease element three cost total cost can shown we cannot make array equal smaller nums cost all elements already so no operations
add to array-form of integer integer num array representing digits left right num array form integer integer num num k num k num k num does not contain any leading zeros except zero k
frog position after t seconds undirected tree consisting vertices numbered frog starts jumping vertex one frog jumps current vertex another unvisited vertex they directly frog can not jump back visited case frog can jump several jumps randomly one them same when frog can not jump any unvisited jumps forever same edges undirected tree array where means exists edge connecting vertices ai probability after t seconds frog vertex answers within actual answer edges t target figure above shows frog starts vertex jumping probability vertex after second then jumping probability vertex after second thus probability frog vertex after seconds edges t target figure above shows frog starts vertex jumping probability vertex after second bi t target
shortest unsorted continuous subarray integer array need find one continuous subarray such only sort this subarray then whole array sorted shortest such subarray output nums need sort ascending order make whole array sorted ascending nums nums follow can solve time
maximum number of occurrences of a substring string maximum occurrences any substring under following unique characters substring must less than or equal substring size must between minsize maxsize s maxletters minsize maxsize substring occurrences original satisfies unique letters size minsize s maxletters minsize maxsize substring occur times can maxletters minsize maxsize s consists only lowercase english
kth smallest element in a sorted matrix x matrix where each rows columns sorted ascending kth smallest element note kth smallest element sorted not kth distinct must find solution memory complexity better than matrix k elements matrix smallest matrix k all rows columns matrix guaranteed sorted k follow could solve problem constant memory memory could solve problem time solution may too advanced interview but may find reading this paper
debounce function fn time milliseconds debounced version debounced function function whose execution delayed t milliseconds whose execution cancelled called again within window debounced function should also recieve passed say t function called first function calls would function call would executed instead t call would would executed would executed above diagram shows how debounce transform each rectangle represents debounce time each color represents different set please solve without using t calls let start function inputs const dlog call cancelled call because call occurred before call delayed executed inputs t calls call delayed until inputs call delayed until inputs t calls call delayed ran inputs call cancelled call call delayed ran inputs t
number of ways to split a string binary string can split s into strings where ways s can split such ones same since answer may too modulo s there four ways split s parts where each part contain same letters s s there three ways split s either or
spiral matrix iv two integers m which represent dimensions also head linked list generate m x matrix contains integers linked list presented spiral order starting there remaining empty fill them generated m head diagram above shows how values printed note remaining spaces matrix filled m head diagram above shows how values printed left right last space matrix set m nodes list range m
find the original array of prefix xor integer array pref size find array arr size note denotes can proven answer pref array we have pref we have
find the divisibility array of a string string word length consisting positive integer divisibility array div word integer array length such numeric value divisible or divisibility array word m there only prefixes divisible word m there only prefixes divisible word consists digits m
minimum deletions to make string balanced string s consisting only characters can delete any characters s make s s balanced there no pair indices such i j minimum deletions needed make s s can delete characters positions or delete characters positions s only solution delete first two or
number of steps to reduce a number in binary representation to one binary representation integer string steps reduce under following current have divide current have add guaranteed can always reach one all test s corressponds their decimal step add obtain step divide obtain step add obtain step divide obtain step divide obtain step divide obtain s corressponds their decimal step divide obtain s s consists characters or
remove covered intervals array intervals where represent interval remove all intervals covered another interval interval covered interval only c b remaining intervals interval covered therefore intervals li ri all intervals
max dot product of two subsequences two arrays maximum dot product between subsequences same subsequence array new array which formed original array deleting some characters without disturbing relative positions remaining subsequence while take subsequence subsequence their dot product take subsequence subsequence their dot product take subsequence subsequence their dot product
construct smallest number from di string string pattern length consisting characters meaning increasing meaning string num length created using following num consists digits where each digit used most then then lexicographically smallest possible string num meets pattern indices we must have indices we must have some possible values num can proven smallest possible num meets note not possible because digit used more than pattern some possible values num can proven smallest possible num meets pattern consists only letters
combination sum iii find all valid combinations k numbers sum up such following conditions only numbers through each used most list all possible valid list must not contain same combination combinations may returned any k there no other valid k there no other valid k there no valid using different numbers range smallest sum we can get since there no valid k
largest palindrome product integer largest palindromic integer can represented product two since answer can very modulo x
minimum common value two integer arrays sorted minimum integer common both there no common integer amongst note integer said common both arrays have least one occurrence smallest element common both arrays so we there two common elements array out which so both sorted
top k frequent words array strings words integer k most frequent answer sorted frequency highest sort words same frequency their lexicographical words k two most frequent note comes before due lower alphabetical words k four most frequent occurrence being consists lowercase english k range unique could solve time extra
move zeroes integer array move all end while maintaining relative order note must do this without making copy nums nums follow could minimize total operations
frog jump ii integer array stones sorted strictly increasing order representing positions stones initially first wants travel last stone then first can jump any stone most length jump absolute difference between position stone frog currently position stone which frog more frog jumping length jump cost path maximum length jump among all jumps minimum cost path stones above figure represents one optimal paths frog can cost this path which maximum length since not possible achieve cost less than we stones frog can jump directly last stone come back first this length each jump cost path can shown this minimum achievable stones sorted strictly increasing
minimum number of k consecutive bit flips binary array nums integer flip choosing subarray length k nums simultaneously changing every subarray every subarray minimum flips required so there no not subarray contiguous part nums k flip then flip nums k no matter how we flip subarrays size we cannot make array become nums k flip nums becomes flip nums becomes flip nums becomes k
deepest leaves sum root binary sum values deepest root root nodes tree range
repeated string match two strings minimum times should repeat string so string b substring impossible b substring after repeating string repeated times repeated time repeated times b we because repeating three times b substring b b consist lowercase english
make the string great string s lower upper case english good string string which have two adjacent characters i letter same letter but or make string can choose two adjacent characters make string bad remove can keep doing this until string becomes string after making answer guaranteed unique under notice empty string also s first either choose i or i both result reduced s we have many possible all lead same s s contains only lower upper case english
sum of beauty of all substrings beauty string difference frequencies between most frequent least frequent beauty string sum beauty all s substrings beauty each beauty equal s s consists only lowercase english
lexicographically smallest palindrome string s consisting lowercase english allowed perform operations one can replace character s another lowercase english your task make s palindrome minimum operations there multiple palindromes can made using minimum make lexicographically smallest string lexicographically smaller than string b same first position where b string letter appears earlier alphabet than corresponding letter resulting palindrome s minimum operations make palindrome lexicographically smallest palindrome string we can get modifying one character changing s minimum operations make palindrome lexicographically smallest palindrome string we can get modifying two characters s minimum operations make palindrome lexicographically smallest palindrome string we can get modifying one character s consists only lowercase english
remove duplicates from sorted list ii head sorted linked delete all nodes have duplicate leaving only distinct numbers original linked list sorted head head nodes list range list guaranteed sorted ascending
minimum moves to equal array elements ii integer array nums size minimum moves required make all array elements one can increment or decrement element array test cases designed so answer fit nums only two moves needed each move increments or decrements one nums
number of ways to divide a long corridor along long library there line seats decorative string corridor length consisting letters where each represents seat each represents one room divider already been installed left index another right index additional room dividers can each position between indices i i i most one divider can divide corridor into where each section exactly two seats any there may multiple ways perform two ways different there position room divider installed first way but not second ways divide since answer may very modulo there no corridor there different ways divide black bars above image indicate two room dividers already note each each section exactly two corridor there only way divide not installing any additional installing any would create some section does not have exactly two corridor there no way divide corridor because there always section does not have exactly two either or
distribute candies to people we distribute some row people following we then give candy first candies second so until we give candies last we go back start giving candies first candies second so until we give candies last this process repeats us giving one more candy each moving start row after we reach until we run out last person receive all our remaining candies necessarily one more than previous array length sum represents final distribution candies first array second array third array fourth there only one candy final array candies first array second array third array fourth final array candies
maximum product of splitted binary tree root binary split binary tree into two subtrees removing one edge such product sums subtrees maximum product sums two since answer may too modulo note need maximize answer before taking mod not after taking root remove red edge get binary trees sum their product root remove red edge get binary trees sum product nodes tree range
count good numbers digit string good digits even indices even digits odd indices prime or good because digits even positions even digits odd positions not good because even index but not integer total good digit strings length since answer may modulo digit string string consisting digits through may contain leading good numbers length
check if binary string has at most one segment of ones binary string s without leading true s contains most one contiguous segment s false ones do not form contiguous s true either or
the employee that worked on the longest task there each unique id integer array logs where idi id employee worked ith leavetimei time which employee finished ith all values leavetimei note ith task starts moment right after task task starts time id employee worked task longest there tie between two or more smallest id among logs task started ended units task started ended units task started ended units task started ended units task longest time task employee id one worked so we logs task started ended unit task started ended units task started ended units task started ended units tasks longest time task employee worked so we logs task started ended units task started ended units tasks longest time tasks employees worked them so we smallest id idi leavetimei idi leavetimei sorted strictly increasing
exchange seats sql schema seat column name type id int student varchar id primary key column this each row this table indicates name id id continuous write sql query swap seat id every two consecutive students id last student not result table ordered id ascending query result format following seat id student abbot doris emerson green jeames id student doris abbot green emerson jeames note students there no need change last
delete characters to make fancy string fancy string string where no three consecutive characters string delete minimum possible characters s make final string after can shown answer always s remove first group create no three consecutive characters so s remove first group create remove two second group create no three consecutive characters so s no three consecutive characters so s consists only lowercase english
alphabet board path alphabet we start position corresponding character board shown diagram we may make following moves our position up one position exists moves our position down one position exists moves our position left one position exists moves our position right one position exists adds character our current position only positions exist board positions letters sequence moves makes our answer equal target minimum may any path does target target target consists only english lowercase
subrectangle queries implement class subrectanglequeries which receives rows x cols rectangle matrix integers constructor supports two int int int int updates all values newvalue subrectangle whose upper left coordinate bottom right coordinate int returns current value coordinate input output explanation subrectanglequeries subrectanglequeries new initial rectangle looks after this update rectangle looks after this update rectangle looks input output explanation subrectanglequeries subrectanglequeries new there most operations considering both updatesubrectangle cols rows cols rows cols row rows col cols
make sum divisible by p array positive integers remove smallest subarray such sum remaining elements divisible not allowed remove whole length smallest subarray need or subarray defined contiguous block elements nums p sum elements nums which not divisible we can remove subarray sum remaining elements which divisible nums p we cannot remove single element get sum divisible best way remove subarray leaving us sum nums p here sum which already divisible thus we do not need remove p
trim a binary search tree root binary search tree lowest highest boundaries low trim tree so all elements lies trimming tree should not change relative structure elements remain tree any descendant should remain can proven there unique root trimmed binary search note root may change depending root low high root low high nodes tree range value each node tree root guaranteed valid binary search low high
count common words with one occurrence two string arrays strings appear exactly once each two appears exactly once each two we count this appears exactly once each two we count this appears each two but there occurrences we do not count this appears once but does not appear we do not count this there strings appear exactly once each two there no strings appear each two only string appears exactly once each two arrays consists only lowercase english
arranging coins have coins want build staircase these staircase consists k rows where ith row exactly i last row staircase may integer complete rows staircase because row we because row we
check if string is a prefix of array string s array strings determine whether s prefix string string s prefix string words s can made concatenating first k strings words some positive k no larger than true s prefix string or false s words true s can made concatenating s words false impossible make s using prefix s consist only lowercase english
open the lock have lock front circular each wheel wheels can rotate freely wrap we can turn or each move consists turning one wheel one lock initially starts string representing state list deadends dead meaning lock displays any these wheels lock stop turning unable open target representing value wheels unlock minimum total turns required open or deadends target sequence valid moves would note sequence like would because wheels lock become stuck after display becomes dead end deadends target we can turn last wheel reverse move deadends target we cannot reach target without getting target not list target consist digits
find k pairs with smallest sums two integer arrays sorted ascending order integer define pair which consists one element first array one element second k pairs smallest k first pairs returned k first pairs returned k all possible pairs returned both sorted ascending k
minimum depth of binary tree binary find minimum minimum depth nodes along shortest path root node down nearest leaf leaf node no root root nodes tree range
jump game integer array initially positioned first each element array represents your maximum jump length true can reach last or false nums true jump step index then steps last nums false always arrive index no matter maximum jump length which makes impossible reach last
minimum moves to move a box to their target location storekeeper game which player pushes boxes around warehouse trying get them target game represented m x grid characters grid where each element or your task move box target position under following character represents player can move right grid floor character represents floor which means free cell character represents wall which means obstacle walk there only one box one target cell box can moved adjacent free cell standing next box then moving direction this player cannot walk through minimum pushes move box there no way reach grid we only times box grid grid push box up m grid contains only characters or there only one character
preimage size of factorial zeroes function let zeroes end recall x because no zeroes while because two zeroes integer integers x have property k end k k there no x such ends k k k
minimum number of moves to seat everyone there seats students array seats length where position ith also array students length where position jth may perform following move any increase or decrease position ith student moving ith student position x x or x minimum moves required move each student seat such no two students same note there may multiple seats or students same position seats students students moved first student moved position position using second student moved position position using third student moved position position using moves seats students students moved first student not second student moved position position using third student moved position position using fourth student moved position position using moves seats students note there two seats position two seats position students moved first student moved position position using second student moved position position using third student not fourth student not moves
maximum sum of distinct subarrays with length k integer array nums integer find maximum subarray sum all subarrays nums meet following length subarray all elements subarray maximum subarray sum all subarrays meet no subarray meets subarray contiguous sequence elements within nums k subarrays nums length which meets requirements sum which meets requirements sum which meets requirements sum which does not meet requirements because element which does not meet requirements because element we because maximum subarray sum all subarrays meet conditions nums k subarrays nums length which does not meet requirements because element we because no subarrays meet k
unique paths iii m x integer array grid where could representing starting there exactly one starting representing ending there exactly one ending representing empty squares we can walk representing obstacles we cannot walk walks starting square ending walk over every square exactly grid we have following two grid we have following four grid there no path walks over every empty square exactly note starting ending square can anywhere m m there exactly one starting cell one ending
second minimum node in a binary tree special binary tree consisting nodes where each node this tree exactly two or zero node two then this value smaller value among two more property always such binary need output second minimum value set made all value whole no such second minimum value output root smallest value second smallest value root smallest value but there any second smallest nodes tree range each internal node
maximum number of visible points array integer your where location both denote integral coordinates facing directly east your cannot move your but can other posx posy cannot your field view degrees represented determining how wide can see any view let d amount degrees rotate your field view inclusive range angles d your browser does not support video tag or this video can see some set points each angle formed your immediate east direction your position your field there can multiple points one there may points your can always see these points regardless your points do not obstruct your vision other maximum points can points angle location shaded region represents your field all points can made visible your field including even though front same line points angle location all points can made visible your field including one your points angle location can only see one two shown angle yi
delete operation for two strings two strings minimum steps required make one can delete exactly one character either need one step make another step make consist only lowercase english
integer to english words convert integer num english words num hundred twenty num thousand three hundred forty num million two hundred thirty four thousand five hundred sixty num
keyboard row array strings words can typed using letters alphabet only one row american keyboard like image american first row consists characters second row consists characters third row consists characters words words words consists english letters lowercase
maximum width ramp ramp integer array nums pair which i j width such ramp j integer array maximum width ramp there no ramp nums maximum width ramp achieved nums maximum width ramp achieved
apply bitwise operations to make strings equal two binary strings s target same length can do following operation s any choose two different indices i j where j replace or xor s can choose i j then simultaneously replace or or xor xor so we have s true can make string s equal or false s target true we can do following choose i j we have now s choose i j we have now s since we can make s equal we s target false not possible make s equal target any s target consist only digits
number of common factors two positive integers common factors integer x common factor b x divides both b common factors b common factors b
make number of distinct characters equal two strings move consists choosing two indices i j such i j swapping true possible get distinct characters equal exactly one false false any pair swaps would yield two distinct characters first one second true we swap index first string index second resulting strings which both have distinct true both resulting strings have distinct regardless which indices we consist only lowercase english
minimum money required before transactions integer array where array describes where each transaction must completed exactly once some any have certain amount order complete transaction money costi must hold after performing money becomes money costi minimum amount money required before any transaction so all transactions can completed regardless order transactions starting money transactions can performed any can shown starting money fail complete all transactions some transactions transactions order minimum money required complete transactions transactions order minimum money required complete transactions starting money transactions can performed any cashbacki
queries quality and percentage sql schema queries column name type varchar result varchar position int rating int there no primary key this may have duplicate this table contains information collected some queries position column value rating column value query rating less than poor we define query quality average ratio between query rating we also define poor query percentage percentage all queries rating less than write sql query find each quality both quality should rounded decimal result table any query result format following queries result position rating dog golden retriever dog german shepherd dog mule cat shirazi cat siamese cat sphynx quality dog cat dog queries quality dog queries cat queries quality equals cat queries
count the repetitions we define str string str which consists string s concatenated str we define string can obtained string we can remove some characters such becomes can obtained based our definition removing bolded underlined two strings two integers have two strings maximum integer m such str can obtained consist lowercase english
maximize grid happiness four have m x there two types introverts there introvertscount introverts extrovertscount should decide how many people want live grid assign each them one grid note do not have have all people living happiness each person calculated introverts start happiness lose happiness each neighbor or extroverts start happiness gain happiness each neighbor or neighbors live directly adjacent cells west grid happiness sum each maximum possible grid m introvertscount extrovertscount assume grid coordinates we can put introvert cell put extroverts cells introvert extrovert extrovert grid happiness above figure shows grid this each introvert stays light green cell while extroverts live light purple m introvertscount extrovertscount place two introverts extrovert introvert extrovert introvert grid happiness m introvertscount extrovertscount extrovertscount
count special quadruplets integer array distinct quadruplets such b c d nums only quadruplet satisfies requirement because nums there no such quadruplets nums quadruplets satisfy requirement
apply transform over each element in array integer array arr mapping function new array transformation applied each returned array should created such please solve without arr fn function const newarray function increases each value array arr fn function function increases each value index resides arr fn function function always returns fn returns
cache with time limit write class allows getting setting however time until expiration associated each class three public accepts integer integer duration once duration key should method should true same key already exists false both value duration should overwritten key already key should associated otherwise should returns count cache pair added time limit value exist so false requested value called there one active key called but returned because cache cache pair added time limit value exist so false pair added time limit value already existed so true returned old value called which returned called which returned called but cache empty so returns because cache key value duration total method calls not exceed
maximize sum of array after k negations integer array nums integer modify array following choose index i replace should apply this process exactly k may choose same index i multiple largest possible sum array after modifying this nums k choose index nums becomes nums k choose indices nums becomes nums k choose indices nums becomes k
task scheduler characters array representing tasks cpu needs where each letter represents different tasks could done any each task done one unit each unit cpu could complete either one task or just there integer represents cooldown period between two same tasks same letter there must least units time between any two same least units times cpu take finish all tasks b idle b idle b there least units time between any two same tasks this case any permutation size would work since so tasks one possible solution b c d e f g idle idle idle idle english integer range
parsing a boolean expression boolean expression expression evaluates either true or can one following evaluates evaluates evaluates logical not inner expression evaluates logical inner expressions subexprn where evaluates logical or inner expressions subexprn where string expression represents boolean evaluation guaranteed expression valid follows expression false evaluate expression now evaluate expression now expression true evaluation or false or false or expression true evaluate false expression now evaluate not false we one following
escape the spreading fire integer array grid size m x which represents each cell one three represents represents represents wall fire cannot pass situated want travel safehouse every may move adjacent grass after your every fire cell spread all adjacent cells not maximum minutes can stay your initial position before moving while still safely reaching this can always reach safehouse regardless minutes note even fire spreads safehouse immediately after have reached counted safely reaching cell adjacent another cell former directly or west latter their sides grid figure above shows scenario where stay initial position still able safely reach staying more than minutes not allow safely reach grid figure above shows scenario where immediately move towards fire spread any cell move towards impossible safely reach grid figure above shows initial notice fire contained walls always able safely reach m m either or
special array with x elements greater than or equal x array nums nums considered special there exists x such there exactly x numbers nums greater than or equal notice x does not have element x array can proven nums value x nums there values greater than or equal nums no numbers fit criteria x there should numbers but there x there should but there x there should numbers but there x cannot greater since there only numbers nums there values greater than or equal
knight dialer chess knight unique may move two squares vertically one square or two squares horizontally one square vertically both forming shape possible movements chess knight shown this chess knight can move indicated chess diagram we have chess knight phone pad shown knight can only stand numeric cell blue integer how many distinct phone numbers length we can allowed place knight any numeric cell initially then should perform jumps dial length all jumps should valid knight answer may very answer modulo we need dial length so placing knight over any numeric cell cells all valid we can dial please take care
guess the word array unique strings words where six letters one word words chosen secret also helper object may call where word must word not or integer representing exact matches your guess secret there parameter allowedguesses each test case where allowedguesses maximum times can call each test should call secret word without exceeding maximum allowed took too many or did not find secret called more than allowedguesses times or did not call secret or guessed secret word called secret word calls less than or equal test cases generated such can guess secret word reasonable strategy than using bruteforce secret words allowedguesses guessed secret word returns because not returns because secret all returns because returns because returns because we made calls one them so we pass test secret words allowedguesses guessed secret word since there two can guess consist lowercase english all strings wordlist secret exists allowedguesses
prime palindrome integer smallest prime palindrome greater than or equal integer prime exactly two note not prime all integer palindrome reads same left right does right test cases generated so answer always exists range
group sold products by the date sql schema table column name type date product varchar there no primary key this may contain each row this table contains product name date sold write sql query find each date different products sold their sold products names each date should sorted result table ordered query result format following activities product headphone pencil mask basketball bible mask products mask sold items we sort them lexicographically separate them sold items we sort them lexicographically separate them sold item we just
maximum binary tree ii maximum tree tree where every node value greater than any other value root maximum binary tree integer just previous tree constructed list recursively following let largest element create root node value left child root right child root note we not only root node root suppose b copy value val appended guaranteed b unique root val b root val b root val b nodes tree range all values tree val
minimum number of moves to make palindrome string s consisting only lowercase english one can select any two adjacent characters s swap minimum moves needed make s note input generated such s can always converted s we can obtain two palindromes we can obtain s we can obtain s minimum moves needed make s palindrome s one palindromes we can obtain s moves one ways we can obtain other palindromes such can also obtained can shown not possible obtain palindrome less than s consists only lowercase english s can converted palindrome using finite
decrypt string from alphabet to integer mapping string s formed digits we want map s english lowercase characters characters represented characters represented string formed after test cases generated so unique mapping always s s s consists digits s valid string such mapping always
range module range module module tracks ranges design data structure track ranges represented intervals query about interval denotes all real numbers x where left x implement rangemodule initializes object data void int adds interval tracking every real adding interval partially overlaps currently tracked numbers should add any numbers interval not already boolean int returns true every real interval currently being false void int stops tracking every real currently being tracked interval input output explanation rangemodule rangemodule new being like not being still being despite remove left right most calls made
shuffle the array array nums consisting elements form array form nums since then answer nums nums
largest positive integer that exists with its negative integer array nums does not contain any find largest positive integer k such also exists positive integer there no such nums only valid k we can find nums both have their corresponding negative values larger nums there no single valid we
minimum white tiles after covering with carpets binary string which represents colors tiles denotes ith tile floor colored other denotes ith tile floor colored also numcarpets have numcarpets black each length carpetlen cover tiles carpets such white tiles still visible carpets may overlap one minimum white tiles still floor numcarpets carpetlen figure above shows one way covering tiles carpets such only white tiles no other way covering tiles carpets can leave less than white tiles floor numcarpets carpetlen figure above shows one way covering tiles carpets such no white tiles note carpets able overlap one carpetlen either or numcarpets
number of wonderful substrings wonderful string string where most one letter appears odd but string word consists first ten lowercase english letters through wonderful substrings same substring appears multiple times then count each occurrence substring contiguous sequence characters word four wonderful substrings underlined word nine wonderful substrings underlined word two wonderful substrings underlined word consists lowercase english letters
partition array into three parts with equal sum array integers true we can partition array into three parts equal we can partition array we can find indexes i j arr true arr false arr true
valid arrangement of pairs integer array pairs where arrangement pairs valid every index i where i we have any valid arrangement inputs generated such there exists valid arrangement pairs this valid arrangement since always equals pairs this valid arrangement since always equals arrangements also pairs this valid arrangement since always equals endi starti endi no two pairs exactly there exists valid arrangement
average of levels in binary tree root binary average value nodes each level form answers within actual answer root average value nodes level level level hence root nodes tree range
reconstruct a 2-row binary matrix following details matrix columns rows matrix binary which means each element matrix can or sum elements row sum elements row sum elements where colsum integer array length your task reconstruct matrix lower integer there more than one valid any them no valid solution empty upper lower colsum also correct upper lower colsum upper lower colsum lower
count unhappy friends list preferences where always each person contains list friends sorted order other friend earlier list more preferred than friend later friends each list denoted integers all friends divided into pairings list where denotes xi paired yi yi paired this pairing may cause some friends friend x unhappy x paired y there exists friend u who paired v x prefers u over u prefers x over unhappy preferences pairs friend unhappy paired but prefers over prefers over friend unhappy paired but prefers over prefers over friends preferences pairs both friends preferences pairs does not contain all values xi yi yi each person contained exactly one
longest square streak in an array integer array subsequence nums called square streak length subsequence least after sorting each element first square previous length longest square streak or there no square subsequence array can derived another array deleting some or no elements without changing order remaining nums choose subsequence after sorting becomes square can shown every subsequence length not square nums there no square streak nums so
minimum moves to reach target score playing game start integer want reach integer one can increment current integer one x x double current integer x can use increment operation any can only use double operation most maxdoubles two integers target minimum moves needed reach target starting target maxdoubles keep incrementing until reach target maxdoubles x increment times so x double once so x increment once so x double again so x increment once so x target maxdoubles x increment once so x double once so x increment once so x double again so x target maxdoubles
queries on a permutation with key array queries positive integers between have process all according following have permutation current find position permutation p then move this beginning permutation notice position p result array containing result queries m queries processed position p then we move beginning p resulting position p then we move beginning p resulting position p then we move beginning p resulting position p then we move beginning p resulting array containing result queries m queries m m m m
replace words we have concept called which can followed some other word form another longer word call this word when root followed successor word we can form new word dictionary consisting many roots sentence consisting words separated replace all successors sentence root forming successor can replaced more than one replace root shortest sentence after dictionary sentence cattle rattled cat rat dictionary sentence absbs bbab b consists only sentence consists only letters words sentence range length each word sentence range every two consecutive words sentence separated exactly one sentence does not have leading or trailing
find the distance value between two arrays two integer arrays integer distance value between two distance value defined elements such there not any element where d we we we d d d
combination sum iv array distinct integers nums target integer possible combinations add up test cases generated so answer can fit nums target possible combination ways note different sequences counted different nums target all elements nums target follow what negative numbers allowed how does change what limitation we need add question allow negative
largest merge of two strings two strings want construct string merge following while either or choose one following append first character merge delete merge then after choosing this merge append first character merge delete merge then after choosing this merge lexicographically largest merge can string lexicographically larger than string b same first position where b character strictly larger than corresponding character lexicographically larger than because first position they differ fourth d greater than one way get lexicographically largest merge take merge take merge take merge take merge take merge append remaining end consist only lowercase english
left and right sum differences integer array find integer array answer sum elements left index i array there no such sum elements right index i array there no such array nums array leftsum array rightsum array answer nums array leftsum array rightsum array answer
binary tree postorder traversal root binary postorder traversal root root root nodes tree range follow recursive solution could do
powerful integers three integers list all powerful integers have value less than or equal integer powerful can represented xi yj some integers i j may answer any your each value should occur most x y bound x y bound y bound
minimum recolors to get k consecutive black blocks string blocks length where either or representing color ith characters denote colors white also integer which desired consecutive black one can recolor white block such becomes black minimum operations needed such there least one occurrence k consecutive black blocks k one way achieve consecutive black blocks recolor blocks so blocks can shown there no way achieve consecutive black blocks less than we blocks k no changes need since consecutive black blocks already we either or k
minimum value to get positive step by step sum array integers start initial positive value each calculate step step sum startvalue plus elements nums left minimum positive value startvalue such step step sum never less than nums choose startvalue third iteration your step step sum less than step step sum startvalue startvalue nums nums minimum start value should nums
find the array concatenation value integer array concatenation two numbers formed concatenating their concatenation concatenation value nums initially equal perform this operation until nums becomes there exists more than one pick first element last element nums respectively add value their concatenation concatenation value then delete first last element one element add value concatenation value then delete concatenation value nums before performing any nums concatenation value first we pick first last their concatenation we add concatenation so becomes equal then we delete them so nums becomes equal second we pick first last their concatenation we add concatenation so becomes equal then we delete them so nums becomes since concatenation value so answer nums before performing any nums concatenation value first we pick first last their concatenation we add concatenation so becomes equal then we delete them so nums becomes equal second we pick first last their concatenation we add concatenation so becomes equal then we delete them so nums becomes equal third nums only one so we pick add concatenation so becomes equal then we delete so nums become since concatenation value so answer
making file names unique array strings names size create folders your file system such ith create folder name since two files cannot have same enter folder name previously system have suffix addition name form k smallest positive integer such obtained name remains array strings length where actual name system assign ith folder when create names see how file system creates folder not assigned remains not assigned remains not assigned remains not assigned remains names see how file system creates folder not assigned remains not assigned remains name system adds since also systems put k becomes not assigned remains names when last folder smallest positive valid k becomes consists lowercase english round
maximum building height want build new buildings new buildings built line labeled there city restrictions heights new height each building must height first building must height difference between any two adjacent buildings cannot exceed there city restrictions maximum height specific these restrictions integer array restrictions where indicates building idi must have height less than or equal guaranteed each building appear most once building not maximum possible height tallest restrictions green area image indicates maximum allowed height each we can build buildings heights tallest building height restrictions green area image indicates maximum allowed height each we can build buildings heights tallest building height restrictions green area image indicates maximum allowed height each we can build buildings heights tallest building height idi idi maxheighti
boats to save people array people where weight ith infinite boats where each boat can carry maximum weight each boat carries most two people same provided sum weight those people most minimum boats carry every people limit boat people limit boats people limit boats limit
minimum number of operations to make string sorted string s asked perform following operation s until get sorted find largest index i such i find largest index j such i j all possible values k range swap two characters indices i reverse suffix starting index operations needed make string since answer can too modulo s simulation goes operation swap get then reverse suffix starting operation swap get then reverse suffix starting operation swap get then reverse suffix starting operation swap get then reverse suffix starting operation swap get then reverse suffix starting s simulation goes operation swap get then reverse substring starting operation swap get then reverse substring starting s consists only lowercase english
serialize and deserialize binary tree serialization process converting data structure or object into sequence bits so can stored file or memory or transmitted across network connection link reconstructed later same or another computer design algorithm serialize deserialize binary there no restriction how your algorithm should just need ensure binary tree can serialized string this string can deserialized original tree format same how leetcode serializes binary do not necessarily need follow this so please creative come up different approaches root root nodes tree range
minimum operations to convert number integer array nums containing distinct integer integer there integer x initially set want perform operations x such converted can perform following operation repeatedly x then any index i array i can set x any x x x note can use each any times any operations set x out range x but no more operations can done minimum operations needed convert x start into not nums start goal we can go following nums start goal we can go following note last operation sets x out range x which nums start goal there no way convert into goal start start goal all integers nums
detect pattern of length m repeated k or more times array positive integers find pattern length m repeated k or more pattern subarray consists one or more repeated multiple times consecutively without pattern defined length true there exists pattern length m repeated k or more otherwise arr m k true pattern length repeated consecutive notice pattern can repeated k or more times but not arr m k true pattern length repeated consecutive another valid pattern also repeated arr m k false pattern length but repeated only there no pattern length repeated or more m k
maximum number of groups entering a competition positive integer array grades which represents grades students would like enter all these students into competition ordered such ordering meets following sum grades students ith group less than sum grades students all groups total students ith group less than total students all groups maximum groups can grades following possible way form groups group students grades sum student group students grades sum student group students grades sum student can shown not possible form more than grades we can only form since forming groups would lead equal students both
roman to integer roman numerals represented seven different d symbol value i v x l c d m written ii roman just two ones added written which simply x written which xx v roman numerals usually written largest smallest left numeral four not four written because one before five we subtract making same principle applies which written there six instances where subtraction i can placed before v x make x can placed before l c make c can placed before d m make roman convert s iii s l iii s m cm xc iv s contains only characters guaranteed s valid roman numeral range
water and jug problem two jugs capacities there infinite amount water supply determine whether possible measure exactly targetcapacity liters using these two targetcapacity liters water must have targetcapacity liters water contained within one or both buckets operations fill any jugs empty any pour water one jug into another till other jug completely or first jug itself targetcapacity true famous die hard targetcapacity false targetcapacity true targetcapacity
sum of k-mirror numbers positive integer without leading zeros reads same both forward backward well representation which read same both forward not representation which does not read same both forward base k sum smallest k smallest numbers their representations listed their sum k smallest numbers their representations listed their sum k smallest numbers k
cells in a range on an excel sheet cell excel sheet represented string denotes column c represented alphabetical column denoted so row r rth row represented integer string s format where represents column represents row represents column represents row such list cells such x y cells should represented strings format mentioned above sorted order first columns then s above diagram shows cells which should present red arrows denote order which cells should s above diagram shows cells which should present red arrow denotes order which cells should s consists uppercase english digits
apply discount every n orders there supermarket frequented many products sold supermarket represented two parallel integer arrays products where ith product id price when customer their bill represented two parallel integer arrays product where jth product they purchased id how much product they their subtotal calculated sum each jth supermarket decided have every nth customer paying their groceries percentage discount amount where they discount percent off their more their subtotal then they would actually pay bill implement cashier int initializes object products their double returns final total bill discount applied answers within actual value input output explanation cashier cashier new no bill no bill original bill actual bill no no original bill but actual bill no discount elements products exists elements product most calls made answers within actual value
permutation sequence set contains total unique listing labeling all permutations we get following sequence kth permutation k k k k
number of ways to earn points there test types integer target integer array types where indicates there counti questions ith each one them worth marksi ways can earn exactly target points since answer may too modulo note questions same type there questions same then solving questions same solving or target types can earn points one seven solve questions solve questions type question solve questions type questions solve questions type question solve question question type question solve questions solve questions target types can earn points one four solve questions solve questions type question solve questions type questions solve question target types can only earn points answering all target marksi
trips and users sql schema trips column name type id int int int int status enum date id primary key this table holds all taxi each trip unique while foreign keys users status enum type users column name type int banned enum role enum primary key this table holds all each user unique role enum type banned enum type cancellation rate computed dividing canceled client or requests unbanned users total requests unbanned users write sql query find cancellation rate requests unbanned users client driver must not each day between round cancellation rate two decimal result table any query result format following trips id status completed completed completed completed completed completed completed users banned role no client yes client no client no client no driver no driver no driver no driver day cancellation rate there requests which request made banned client so ignored hence there unbanned requests which cancellation rate there requests which request made banned so hence there unbanned requests which cancellation rate there requests which request made banned so hence there unbanned request which cancellation rate
number of ways to rearrange sticks with k sticks visible there sticks whose lengths integers want arrange sticks such exactly k sticks visible stick visible left there no longer sticks left sticks arranged then sticks lengths visible such since answer may modulo k only arrangements such exactly sticks visible sticks k only arrangement such all sticks visible sticks k there ways rearrange sticks such exactly sticks k
maximum binary string after change binary string binary consisting only or can apply each following operations any operation contains substring can replace operation contains substring can replace maximum binary string can obtain after any binary string x greater than binary string y decimal representation greater than decimal binary valid transformation sequence can binary cannot transformed any binary consist
count unique characters of all substrings of a given string define function returns unique characters calling s then unique characters since they appear only once therefore string sum where t substring test cases generated such answer fits notice some substrings can repeated so this case have count repeated ones s all possible substrings every substring composed only unique sum lengths all substring s same except s s consists uppercase english letters
ones and zeroes array binary strings strs two integers m size largest subset strs such there most m set x subset set y all elements x also elements strs m largest subset most so answer other valid but smaller subsets include invalid subset because contains greater than maximum strs m largest subset so answer consists only digits
maximize palindrome length from subsequences two want construct string following choose some subsequence choose some subsequence concatenate make length longest palindrome can constructed described no palindromes can subsequence string s string can made deleting some characters s without changing order remaining palindrome string reads same forward well choose make which choose make which cannot construct palindrome described so consist lowercase english
coin change ii integer array coins representing coins different denominations integer amount representing total amount combinations make up amount money cannot made up any combination may assume have infinite each kind answer guaranteed fit into signed amount coins there four ways make up amount coins amount cannot made up just coins amount coins all values coins amount
longest uploaded prefix stream each represented distinct need need implement data structure calculates length longest uploaded prefix various points upload we consider i uploaded prefix all videos range i have been uploaded longest uploaded prefix maximum value i satisfies this implement luprefix initializes object stream void uploads video int returns length longest uploaded prefix defined input output explanation luprefix server new initialize stream upload video since video not been uploaded there no we upload video prefix longest uploaded so we upload video prefix longest uploaded so we video all values video most calls total made upload least one call made
count pairs of similar strings string array two strings similar they consist same similar since both consist characters not similar since they do not consist same pairs such i j two strings words there pairs satisfy i j both only consist characters i j both only consist characters words there pairs satisfy i j both only consist characters i j both only consist characters i j both only consist characters words since there does not exist any pair satisfies we consist only lowercase english
power of two integer true power integer power there exists integer x such true true false follow could solve without
maximum difference by remapping a digit integer know danny mittal sneakily remap one possible digits another difference between maximum minimum values danny can make remapping exactly one digit when danny remaps digit another digit danny replaces all occurrences num danny can remap digit which case num does not danny can remap different digits obtaining minimum maximum values resulting after remapping can contain leading we mentioned congratulate him being top weekly contest num achieve maximum danny can remap digit digit yield achieve minimum danny can remap digit digit yielding difference between these two numbers num maximum value can returned function replaced minimum value can returned function replaced we num
thousand separator integer add dot thousands separator string
range sum query 2d - immutable matrix handle multiple queries following calculate sum elements matrix inside rectangle defined upper left corner lower right corner implement nummatrix initializes object integer matrix int int int int returns sum elements matrix inside rectangle defined upper left corner lower right corner must design algorithm where sumregion works time input output explanation nummatrix nummatrix new sum red sum green sum blue m m most calls made
pancake sorting array integers sort array performing series pancake one pancake flip we do following choose integer k where k reverse arr we performed pancake flip choosing k we reverse so arr after pancake flip k array corresponding sequence pancake flips sort any valid answer sorts array within flips judged arr we perform pancake k values starting arr after flip arr after flip arr after flip arr after flip arr which arr input already so there no need flip note other such would also all integers arr unique arr permutation integers
integer break integer break into sum k positive where k maximize product those maximum product can
second minimum time to reach destination city represented connected graph vertices where each vertex labeled edges graph represented integer array where each denotes edge between vertex ui vertex every vertex pair connected most one no vertex edge time taken traverse any edge time each vertex traffic signal which changes color green red vice versa every change all signals change same can enter vertex any but can leave vertex only when signal cannot wait vertex signal second minimum value defined smallest value strictly larger than minimum second minimum value second minimum value second minimum time take go vertex vertex can go through any vertex any including can assume when journey all signals have just turned edges time change figure left shows blue path figure right minimum time time taken start time time time hence minimum time needed red path shows path get second minimum start time time time wait time time hence second minimum time edges time change minimum time path time second minimum time path time vi ui vi there no duplicate each vertex can reached directly or indirectly every other change
maximum count of positive integer and negative integer array nums sorted maximum between positive integers negative other positive integers nums pos negative integers then maximum pos note neither positive nor nums there positive integers negative maximum count among them nums there positive integers negative maximum count among them nums there positive integers negative maximum count among them nums sorted follow can solve problem time
smallest subsequence of distinct characters string lexicographically smallest subsequence s contains all distinct characters s exactly s s s consists lowercase english this question same
relative sort array two arrays elements all elements also sort elements such relative ordering items same elements do not appear should placed end ascending all elements each
longest arithmetic subsequence array nums length longest arithmetic subsequence note subsequence array can derived another array deleting some or no elements without changing order remaining sequence seq arithmetic all same value i nums whole array arithmetic sequence steps length nums longest arithmetic subsequence nums longest arithmetic subsequence
is graph bipartite? there undirected graph where each node numbered between array where array nodes node u adjacent more each v there undirected edge between node u node graph following there no does not contain there no parallel edges does not contain duplicate v then u graph graph may not meaning there may two nodes u v such there no path between graph bipartite nodes can partitioned into two independent sets b such every edge graph connects node set node set true only graph false there no way partition nodes into two independent sets such every edge connects node one node graph true we can partition nodes into two does not contain all values contains then contains
minimum falling path sum x array integers minimum sum any falling path through falling path starts any element first row chooses element next row either directly below or diagonally next element position col or col matrix there two falling paths minimum sum matrix falling path minimum sum
minimum limit of balls in a bag integer array nums where ith bag contains also integer can perform following operation most maxoperations take any bag balls divide into two new bags positive bag balls can become two new bags or two new bags your penalty maximum balls want minimize your penalty after minimum possible penalty after performing nums maxoperations divide bag balls into two bags sizes divide bag balls into two bags sizes bag most balls so your penalty should nums maxoperations divide bag balls into two bags sizes divide bag balls into two bags sizes divide bag balls into two bags sizes divide bag balls into two bags sizes bag most balls so your penalty should
can make arithmetic progression from sequence sequence numbers called arithmetic progression difference between any two consecutive elements array numbers true array can rearranged form arithmetic arr true we can reorder elements or differences between each consecutive arr false there no way reorder elements obtain arithmetic
coordinate with maximum network quality array network towers where denotes ith network tower location quality factor all coordinates integral coordinates distance between two coordinates euclidean also integer radius where tower reachable distance less than or equal outside signal becomes tower not signal quality ith tower coordinate calculated formula where d distance between tower network quality coordinate sum signal qualities all reachable array representing integral coordinate where network quality there multiple coordinates same network lexicographically minimum coordinate lexicographically smaller than or greatest integer less than or equal val floor towers radius coordinate total quality quality results quality results quality results no other coordinate higher network towers radius since there only one network quality highest right towers radius coordinate highest network qi radius
the time when the network becomes idle there network labeled integer array where indicates there message channel between servers ui they can pass any messages each other directly one also integer array patience length all servers message can passed one server any other directly or indirectly through message server labeled master rest data each data server needs send message master server processing wait messages move between servers so every message takes least amount time arrive master master server process all newly arrived messages instantly send reply originating server via reversed path message had gone beginning second each data server sends message starting second beginning every each data server check received reply message sent any newly arrived master resend message data server i resend message every data server i resend message have elapsed since last time message sent this no more resending occur this network becomes idle when there no messages passing between servers or arriving earliest second starting which network becomes edges patience beginning second data server sends message master data server sends message master second message arrives master master server processes message instantly sends reply server not received any second elapsed since this server sent therefore does not resend server not received any second elapsed since this server sent therefore resends message second reply arrives server no more resending occur server message arrives master master server processes message instantly sends reply server resends message second reply arrives server no more resending occur server second reply arrives server starting beginning second there no messages passing between servers or arriving this time when network becomes edges patience data servers receive reply back beginning second beginning second network becomes i vi ui vi there no duplicate each server can directly or indirectly reach another
distinct prime factors of product of array array positive integers distinct prime factors product elements note greater than called prime divisible only integer factor another integer nums product all elements nums there distinct prime factors so we nums product all elements nums there distinct prime factor so we
k-concatenation maximum sum integer array arr integer modify array repeating k arr k then modified array maximum sum modified note length can sum case answer can very answer modulo arr k arr k arr k k
spiral matrix iii start cell rows x cols grid facing northwest corner first row column southeast corner last row walk clockwise spiral shape visit every position this whenever move outside we continue our walk outside grid may grid boundary we reach all rows cols spaces array coordinates representing positions grid order visited rows cols rstart cstart rows cols rstart cstart cols rstart rows cstart cols
bricks falling when hit m x binary where each represents brick represents empty brick stable directly connected top or least one other brick four adjacent cells also array which sequence erasures we want each time we want erase brick location brick location some other bricks may no longer stable because erasure once brick immediately erased grid does not land other stable array where each bricks fall after ith erasure note erasure may refer location no no bricks grid hits starting we erase underlined brick resulting two underlined bricks no longer stable they no longer connected top nor adjacent another stable so they resulting grid hence result grid hits starting we erase underlined brick resulting all remaining bricks still so no bricks grid remains we erase underlined brick resulting once all remaining bricks still so no bricks hence result m or xi m yi all
design linked list design your implementation linked can choose use singly or doubly linked node singly linked list should have two val val value current next next want use doubly linked need one more attribute prev indicate previous node linked assume all nodes linked list implement mylinkedlist initializes mylinkedlist int get value indexth node linked index void add node value val before first element linked after new node first node linked void append node value val last element linked void int add node value val before indexth node linked index equals length linked node appended end linked index greater than node not void delete indexth node linked index input output explanation mylinkedlist mylinkedlist new linked list becomes now linked list val please do not use linkedlist most calls made addatindex
out of boundary paths there m x grid ball initially position allowed move ball one four adjacent cells grid out grid crossing grid can apply most maxmove moves five integers paths move ball out grid since answer can very modulo m maxmove startrow startcolumn m maxmove startrow startcolumn maxmove startrow m startcolumn
count vowels permutation integer your task count how many strings length can formed under following each character lower case vowel each vowel may only followed each vowel may only followed or each vowel may not followed another each vowel may only followed or each vowel may only followed since answer may too modulo all possible strings all possible strings
probability of a two boxes having the same number of distinct balls balls k distinct integer array balls size k where balls color all balls shuffled uniformly then we distribute first balls first box remaining balls other box read explanation second please note two boxes considered we have two balls colors two boxes then distribution considered different than distribution read explanation first probability two boxes have same distinct answers within actual value accepted balls only ways divide balls ball color box ball color box ball color box ball color box both distinct colors each box probability balls we have set balls this set balls shuffled randomly we may have one distinct shuffles equal probability after we add first two balls first box second two balls second we can see these possible random distributions have same distinct colors balls each probability balls set balls hard display all possible random shuffles this set but easy check them have same distinct colors each probability
delivering boxes from storage to ports have task delivering some boxes storage their ports using only one this ship limit boxes total weight can array where three integers portsi port where need deliver ith box weightsi weight ith portscount maxboxes maxweight respective box weight limits boxes need delivered order they ship follow these ship take some boxes boxes not violating maxboxes maxweight each loaded box ship make trip port box needs delivered deliver ship already correct no trip box can immediately ship then makes trip storage take more boxes ship must end storage after all boxes have been minimum trips ship needs make deliver all boxes their respective boxes portscount maxboxes maxweight optimal strategy ship takes all boxes goes port then port then port then returns so total trips note first third boxes cannot delivered together because boxes need delivered order second box needs delivered port before third boxes portscount maxboxes maxweight optimal strategy ship takes first goes port then returns ship takes third fourth goes port then returns ship takes fifth goes port then returns so total trips boxes portscount maxboxes maxweight optimal strategy ship takes first second goes port then returns ship takes third fourth goes port then returns ship takes fifth sixth goes port then returns so total trips maxweight portsi portscount weightsi maxweight
range sum query - immutable integer array handle multiple queries following calculate sum elements nums between indices left right inclusive where left implement numarray initializes object integer array int int returns sum elements nums between indices left right inclusive input output explanation numarray numarray new left right most calls made
heaters winter during your first job design standard heater fixed warm radius warm all every house can long house within warm radius positions houses heaters horizontal minimum radius standard heaters so those heaters could cover all notice all heaters follow your radius warm radius houses heaters only heater placed position we use radius then all houses can houses heaters two heater placed position we need use radius then all houses can houses heaters
perfect number perfect positive integer equal sum positive excluding divisor integer x integer can divide x integer true perfect otherwise num true all divisors num false num
minimum swaps to make sequences increasing two integer arrays same length one allowed swap can swap element i obtain minimum needed operations make strictly test cases generated so input always makes array arr strictly increasing only swap then sequences which both strictly
number of atoms string formula representing chemical count each atomic element always starts uppercase then zero or more lowercase representing one or more digits representing count may follow count greater than count no digits but two formulas concatenated together produce another also formula placed count also count all elements string following first name sorted followed count count more than followed second name sorted followed count count more than so test cases generated so all values output fit formula count elements formula count elements formula count elements formula consists english formula always
count number of teams there soldiers standing each soldier assigned unique rating have form team soldiers amongst them under following choose soldiers index rating team valid or where i j k teams can form can part multiple rating we can form three teams rating we form any team rating all integers rating
broken calculator there broken calculator integer startvalue display one multiply display or subtract two integers startvalue minimum operations needed display target startvalue target use double operation then decrement operation startvalue target use decrement then double startvalue target use decrement double target
counting bits integer array ans length such each i i binary representation follow very easy come up solution runtime log can do linear time possibly single can do without using any function like
slowest key newly designed keypad where tester pressed sequence one string keyspressed length where ith key pressed testing sorted list where time ith key both arrays key pressed time every subsequent key pressed exact time previous key tester wants know key keypress had longest ith keypress had duration keypress had duration note same key could have been pressed multiple times during these multiple presses same key may not have had same key keypress had longest there multiple such lexicographically largest key releasetimes keyspressed keypresses keypress had duration time released time keypress had duration time right after release previous character released time keypress had duration time right after release previous character released time keypress had duration time right after release previous character released time longest these keypress second keypress both duration lexicographically larger than so answer releasetimes keyspressed keypresses keypress had duration keypress had duration keypress had duration keypress had duration keypress had duration longest these keypress duration keyspressed contains only lowercase english
defuse the bomb have bomb your time running your informer provide circular array code length key decrypt must replace every all numbers replaced k replace ith sum next k k replace ith sum previous k k replace ith code next element previous element circular array code integer key decrypted code defuse code k each replaced sum next decrypted code notice numbers wrap code k when k numbers replaced code k decrypted code notice numbers wrap around k sum previous k
non-decreasing array array nums your task check could become modifying most one we define array holds every i such i nums true could modify first get nums false cannot get array modifying most one
replace all ?'s to avoid consecutive repeating characters string s containing only lowercase english letters convert all characters into lowercase letters such final string does not contain any consecutive repeating cannot modify non guaranteed there no consecutive repeating characters string except final string after all conversions have been there more than one any can shown answer always possible s there solutions this all only invalid modification string consist consecutive repeating characters s there solutions this only invalid modifications strings consist consecutive repeating characters s consist lowercase english letters
check if n and its double exist array arr check there exist two indices i j such i j j arr true i j arr false there no i j satisfy
merge two sorted lists heads two sorted linked lists merge two lists one sorted list should made splicing together nodes first two head merged linked nodes both lists range both sorted
maximum length of pair chain array pairs pairs where lefti pair follows pair b chain pairs can formed this length longest chain which can do not need use up all can select pairs any pairs longest chain pairs longest chain lefti righti
reverse subarray to maximize array value integer array value this array defined sum all i allowed select any subarray array reverse can perform this operation only find maximum possible value final nums reversing subarray array becomes whose value nums
bitwise xor of all pairings two consisting there exists another which contains bitwise xor all pairings integers between integer paired every integer exactly bitwise xor all integers possible array bitwise xor all these numbers so we all possible pairs bitwise xors one possible array so we
first letter to appear twice string s consisting lowercase english first letter appear letter appears twice before another letter b second occurrence before second occurrence s contain least one letter appears s letter appears indexes letter appears indexes letter appears indexes letter appears index letter first letter appear because out all letters index second occurrence s only letter appears twice so we s consists lowercase english s least one repeated
sum of scores of built strings building string s length one character prepending each new character front strings labeled where string length i labeled s score si length longest common prefix between si sn s final string sum score every s longest common prefix which score there no common prefix so score longest common prefix which score there no common prefix so score longest common prefix which score sum scores so we s longest common prefix which score longest common prefix which score longest common prefix which score all other score sum scores so we s consists lowercase english
longest nice substring string s nice every letter alphabet s appears both uppercase nice because not because but does string longest substring s there substring earliest there empty s nice string because only letter alphabet both longest nice s nice string because both whole string s there no nice s consists uppercase lowercase english
intersection of two arrays ii two integer arrays array their each element result must appear many times shows both arrays may result any also follow what array already how would optimize your what size small compared which algorithm what elements stored memory limited such cannot load all elements into memory
count square submatrices with all ones m matrix ones how many square submatrices have all matrix there squares side there squares side there square side total squares matrix there squares side there square side total squares
critical connections in a network there servers numbered connected undirected connections forming network where represents connection between servers ai any server can reach other servers directly or indirectly through critical connection connection make some servers unable reach some other all critical connections network any connections also connections bi ai bi there no repeated
patching array sorted integer array nums integer elements array such any range inclusive can formed sum some elements minimum patches nums combinations nums which form possible sums now we combinations possible sums which now covers range so we only need nums two patches can nums nums sorted ascending
bag of tokens have initial power initial score bag tokens where value ith token your goal maximize your total score potentially playing each token one two your current power least may play ith token face losing power gaining your current score least may play ith token face gaining power losing each token may played most once any do not have play all largest possible score can achieve after playing any tokens power playing only token bag impossible because either have too little power or too little tokens power play token face your power becomes score becomes there no need play token since cannot play face up add your tokens power play tokens this order get score play token face your power becomes score becomes play token face your power becomes score becomes play token face your power becomes score becomes play token face your power becomes score becomes power
longest increasing path in a matrix m x integers length longest increasing path each can either move four or may not move diagonally or move outside boundary not matrix longest increasing path matrix longest increasing path moving diagonally not matrix m
remove duplicates from sorted list head sorted linked delete all duplicates such each element appears only linked list sorted head head nodes list range list guaranteed sorted ascending
minimum replacements to sort the array integer array one operation can replace any element array any two elements sum consider nums one we can replace convert nums minimum operations make array sorted nums here steps sort array replace so array becomes replace so array becomes there steps sort array we nums array already we
best team with no conflicts manager basketball upcoming want choose team highest overall score team sum scores all players basketball team not allowed have conflict exists younger player strictly higher score than older conflict does not occur between players same two scores where each represents score age ith highest overall score all possible basketball scores ages can choose all scores ages best choose last notice allowed choose multiple people same scores ages best choose first
closest nodes queries in a binary search tree root binary search tree array queries size consisting positive find array answer size where mini largest value tree smaller than or equal such value does not add maxi smallest value tree greater than or equal such value does not add array root queries we answer queries following largest smaller or equal than tree smallest greater or equal than still so answer first query largest smaller or equal than tree smallest greater or equal than so answer second query largest smaller or equal than tree smallest greater or equal than does not so answer third query root queries largest smaller or equal tree does not smallest greater or equal so answer query nodes tree range
least number of unique integers after k removals array integers arr integer find least unique integers after removing exactly k arr k remove single only arr k remove either one two or three k
number of closed islands grid consists island maximal connected group closed island island totally surrounded closed grid islands gray closed because they completely surrounded water grid grid
minimum one bit operations to make integers zero integer must transform into using following operations any change rightmost bit binary representation change ith bit binary representation bit set through bits set minimum operations transform into binary representation operation since bit binary representation operation since bit through bits operation since bit
contain virus virus spreading your task quarantine infected area installing world modeled m x binary grid where represents uninfected represents cells contaminated wall only one can installed between any two adjacent shared every virus spreads all neighboring cells all four directions unless blocked resources each can install walls around only one region affected area block infected threatens most uninfected cells following there never walls used quarantine all infected world become fully walls isinfected there contaminated first add walls quarantine viral region board after virus spreads second add walls quarantine viral region virus fully isinfected even though there only one cell there walls notice walls only built shared boundary two different isinfected region left only builds two new m either or there always contiguous viral region throughout described process infect strictly more uncontaminated squares next
append characters to string to make subsequence two strings s t consisting only lowercase english minimum characters need appended end s so t becomes subsequence subsequence string can derived another string deleting some or no characters without changing order remaining s t append characters end s so s t subsequence s can shown appending any characters end s never make t s t t already subsequence s s t append characters end s so s t subsequence s can shown appending any characters end s never make t s t consist only lowercase english
longest continuous increasing subsequence unsorted array integers length longest continuous increasing subsequence subsequence must strictly continuous increasing subsequence defined two indices l r such each l i nums longest continuous increasing subsequence length even though increasing not continuous elements separated element nums longest continuous increasing subsequence length note must strictly
smallest value of the rearranged number integer rearrange digits num such value minimized does not contain any leading rearranged minimal note sign does not change after rearranging num possible arrangements digits arrangement smallest value does not contain any leading zeros num some possible arrangements digits arrangement smallest value does not contain any leading zeros num
shuffle string string s integer array indices same string s shuffled such character ith position moves shuffled shuffled s indices becomes after s indices after each character remains s consists only lowercase english all values indices
maximum enemy forts that can be captured integer array forts length representing positions several can or represents there no fort ith indicates there enemy fort ith indicates fort ith position under your now have decided move your army one your forts position i empty position j such j army travels over enemy forts all k where k while moving all enemy forts come way maximum enemy forts can case impossible move your or do not have any fort under your forts moving army position position captures enemy moving army position position captures enemy since maximum enemy forts can we forts since no enemy fort can
smallest missing non-negative integer after operations integer array nums integer one can add or subtract value any element nums value can choose subtract value make nums mex array smallest missing integer mex while mex maximum mex nums after applying mentioned operation any nums value one can achieve this result applying following add value twice make nums subtract value once make nums subtract value twice make nums mex nums can shown maximum mex we can nums value one can achieve this result applying following subtract value once make nums mex nums can shown maximum mex we can value
max chunks to make sorted ii integer array we split arr into some chunks individually sort each after concatenating result should equal sorted largest chunks we can make sort arr splitting into two or more chunks not required splitting into result which arr we can split into two such splitting into highest chunks
count number of distinct integers after reverse operations array nums consisting positive have take each integer reverse add end should apply this operation original integers distinct integers final nums after including reverse each resulting array reversed integers added end array note integer after reversing becomes which just distinct integers this array numbers nums after including reverse each resulting array distinct integers this array
minimum insertions to balance a parentheses string parentheses string s containing only characters parentheses string balanced any left parenthesis must have corresponding two consecutive right parenthesis left parenthesis must go before corresponding two consecutive right parenthesis other we treat opening parenthesis closing not can insert characters any position string balance minimum insertions needed make s s second two matching but first only we need add one more end string which s string already s add match first add match last s consists
minimum cost to split an array integer array nums integer split array into some cost split sum importance value each subarray let version subarray where all numbers which appear only once importance value subarray k subarray then importance value this subarray k minimum possible cost split subarray contiguous sequence elements within nums k we split nums have two importance value importance value cost split can shown this minimum possible cost among all possible nums k we split nums have two importance value importance value cost split can shown this minimum possible cost among all possible nums k we split nums have one importance value cost split can shown this minimum possible cost among all possible k
tree of coprimes there tree undirected graph no consisting nodes numbered exactly each node value associated root tree node represent this integer array nums array each represents ith each represents edge between nodes uj vj two values x y coprime where greatest common divisor x ancestor node i any other node shortest path node i node not considered ancestor array ans size where closest ancestor node i such or there no such nums edges above each value node no coprime node only one node their values coprime node two nodes node value not coprime but node value so node closest valid node two nodes coprime node so node closest valid nums edges vj uj vj
the number of the smallest unoccupied chair there party where friends numbered there infinite chairs this party numbered when friend arrives they sit unoccupied chair smallest chairs occupied when friend they sit chair when friend leaves their chair becomes unoccupied moment they another friend arrives same they can sit integer array times where indicating arrival leaving times ith friend integer all arrival times chair friend numbered targetfriend sit times targetfriend friend arrives time sits chair friend arrives time sits chair friend leaves time chair becomes friend leaves time chair becomes friend arrives time sits chair since friend sat chair we times targetfriend friend arrives time sits chair friend arrives time sits chair friend arrives time sits chair friend leaves time chair becomes friend leaves time chair becomes friend leaves time chair becomes since friend sat chair we arrivali leavingi targetfriend each arrivali time
circular permutation in binary representation integers your task any permutation p such start differ only one bit their binary must also differ only one bit their binary start binary representation permutation all adjacent element differ one another valid permutation start binary representation permutation start
maximum employees to be invited to a meeting company organizing meeting list waiting they have arranged large circular capable seating any employees numbered each employee favorite person they attend meeting only they can sit next their favorite person favorite person employee not integer array where denotes favorite person ith maximum employees can invited favorite above figure shows how company can invite employees seat them round all employees cannot invited because employee cannot sit beside employees note company can also invite employees give them their desired maximum employees can invited meeting favorite each employee favorite person least one other only way company can invite them they invite every seating arrangement same figure employee sit between employees employee sit between employees employee sit between employees maximum employees can invited meeting favorite above figure shows how company invite employees seat them round employee cannot invited because two spots next their favorite employee so company leaves them out maximum employees can invited meeting i
cousins in binary tree ii root binary replace value each node tree sum all two nodes binary tree cousins they have same depth different root modified note depth node edges path root node root diagram above shows initial binary tree binary tree after changing value each node value does not have any cousins so sum node value does not have any cousins so sum node value does not have any cousins so sum node value cousin value so sum node value cousin value so sum node value cousins values so sum root diagram above shows initial binary tree binary tree after changing value each node value does not have any cousins so sum node value does not have any cousins so sum node value does not have any cousins so sum nodes tree range
stock price fluctuation stream records about particular each record contains timestamp corresponding price stock unfortunately due volatile nature stock records do not come even some records may another record same timestamp may appear later stream correcting price previous wrong design algorithm updates price stock particular correcting price any previous records finds latest price stock based current latest price price latest timestamp finds maximum price stock been based current finds minimum price stock been based current implement stockprice initializes object no price void int updates price stock int returns latest price int returns maximum price int returns minimum price input output explanation stockprice stockprice new timestamps corresponding prices timestamps corresponding prices latest timestamp price being maximum price timestamp previous timestamp had wrong so updated timestamps corresponding prices maximum price after timestamps corresponding prices minimum price timestamp price most calls made total minimum called only after update been called least
adding spaces to a string string s integer array spaces describes indices original string where spaces each space should inserted before character s spaces we place spaces before which indices we obtain your modified string after spaces have been s spaces helps me indices correspond underlined characters we then place spaces before those s spaces code py indices correspond underlined characters we then place spaces before those s spaces s p c i we also able place spaces before first character s consists only lowercase uppercase english all values spaces strictly
copy list with random pointer linked list length such each node contains additional random which could point any node or construct deep copy deep copy should consist exactly brand new where each new node value set value corresponding original both next random pointer new nodes should point new nodes copied list such pointers original list copied list represent same list none pointers new list should point nodes original there two nodes x y original where then corresponding two nodes x y copied head copied linked linked list represented list each node represented pair integer representing index node random pointer points or null does not point any your code only head original linked head head head null or pointing some node linked
concatenation of consecutive binary numbers integer decimal value binary string formed concatenating binary representations modulo binary corresponds decimal value corresponds after concatenating we have which corresponds decimal value concatenation results decimal value after modulo result
binary tree tilt root binary sum every tree tilt tree node absolute difference between sum all left subtree node values all right subtree node node does not have left then sum left subtree node values treated rule similar node does not have right root tilt node tilt node tilt node subtree just left so sum right subtree just right so sum sum every tilt root tilt node tilt node tilt node tilt node subtree just left so sum right subtree just right so sum tilt node left so sum right subtree just right so sum tilt node subtree values which sums right subtree values which sums sum every tilt root nodes tree range
most profitable path in a tree there undirected tree nodes labeled rooted node integer array edges length where indicates there edge between nodes ai bi every node there also array even integers where price needed open gate node cash reward obtained opening gate node game goes alice node bob node every alice bob each move adjacent alice moves towards some leaf while bob moves towards node every node along their alice bob either spend money open gate or accept note gate already no price nor there any cash alice bob reach node they share opening gate other price open gate then both alice bob pay c reward gate both them receive c alice reaches leaf she stops bob reaches node stops note these events independent each maximum net income alice can have she travels towards optimal leaf edges bob amount above diagram represents game goes alice initially node bob node they open gates their respective net income now both alice bob move node since they reach here they open gate together share net income becomes alice moves node since bob already opened income remains bob moves node stops alice moves node opens gate her net income becomes neither alice nor bob can make any further game not possible alice get higher net edges bob amount alice follows path whereas bob follows path alice opens gate node her net income bi ai bi edges represents valid bob even integer range
elimination game have list arr all integers range sorted strictly increasing apply following algorithm starting left remove first every other afterward until reach end repeat previous step but this time right remove rightmost every other remaining keep repeating steps alternating left right right until single integer last remains arr arr arr arr
root equals sum of children root binary tree consists exactly left right true value root equal sum values two or false root true values left right child equal so we root false values left right child not equal so we tree consists only left right
make the xor of all segments equal to zero array nums integer xor segment where left right xor all elements indices between left xor xor xor minimum elements change array such xor all segments size k equal nums k modify array nums k modify array nums k modify array k
maximum number of coins you can get there piles coins varying your friends take piles coins each choose any piles coins necessarily your alice pick pile maximum pick next pile maximum your friend bob pick last repeat until there no more piles array integers piles where coins ith maximum coins can piles choose triplet alice pick pile pile coins bob last choose triplet alice pick pile pile coins bob last maximum coins which can have other hand we choose this arrangement only get coins which not piles piles
reverse string ii string s integer reverse first k characters every characters counting start there fewer than k characters reverse all there less than but greater than or equal k then reverse first k characters leave other s k s k s consists only lowercase english k
distance between bus stops bus stops numbered form we know distance between all pairs neighboring stops where distance between stops i bus goes along both directions clockwise shortest distance between start destination distance start destination distance between or minimum distance start destination distance between or minimum distance start destination distance between or minimum destination
confirmation rate sql schema signups column name type int datetime primary key this each row contains information about signup time user id confirmations column name type int datetime action enum primary key this foreign key reference signups action enum type each row this table indicates user id requested confirmation message confirmation message either confirmed or expired without confirming confirmation rate user messages divided total requested confirmation confirmation rate user did not request any confirmation messages round confirmation rate two decimal write sql query find confirmation rate each result table any query result format following signups confirmations action timeout timeout confirmed confirmed confirmed confirmed timeout user did not request any confirmation confirmation rate user made requests both timed confirmation rate user made requests all confirmation rate user made requests where one confirmed other timed confirmation rate
reformat department table sql schema department column name type id int revenue int month varchar primary key this table information about revenue each department per month values write sql query reformat table such there department id column revenue column each result table any query result format following department id revenue month jan jan feb feb mar id null null null null null null null revenue apr dec note result table columns department id
unique paths ii m x integer array there robot initially located corner robot tries move corner robot can only move either down or right any point obstacle space marked or respectively path robot takes cannot include any square possible unique paths robot can take reach testcases generated so answer less than or equal obstaclegrid there one obstacle middle grid there two ways reach right right down down down down right right obstaclegrid m or
substring with concatenation of all words string s array strings all strings words same concatenated substring s substring contains all strings any permutation words words then all concatenated not concatenated substring because not concatenation any permutation starting indices all concatenated substrings can answer any s words since concatenated substring length substring starting concatenation which permutation substring starting concatenation which permutation output order does not returning fine s words since concatenated substring length there no substring length s equal concatenation any permutation we empty s words since concatenated substring length substring starting concatenation which permutation substring starting concatenation which permutation substring starting concatenation which permutation s consist lowercase english
bus routes array routes representing bus routes where bus route ith bus repeats this means bus travels sequence start bus stop source not any bus want go bus stop can travel between bus stops buses least buses must take travel source not routes source target best strategy take first bus bus stop then take second bus bus stop routes source target all values target
find the winner of an array game integer array arr distinct integers integer game played between first two elements array each round we compare larger integer wins remains position smaller integer moves end game ends when integer wins k consecutive integer which win guaranteed there winner arr k see rounds round arr winner so we can see rounds played winner because wins consecutive arr k win first rounds arr contains distinct k
contains duplicate ii integer array nums integer true there two distinct indices i j array such nums k true nums k true nums k false k
find the city with the smallest number of neighbors at a threshold distance there cities numbered array edges where represents bidirectional weighted edge between cities fromi integer city smallest cities reachable through some path whose distance most there multiple such city greatest notice distance path connecting cities i j equal sum weights along edges distancethreshold figure above describes neighboring cities distancethreshold each city city city city city city city city city city city cities have neighboring cities distancethreshold but we have city since greatest edges distancethreshold figure above describes neighboring cities distancethreshold each city city city city city city city city city city city city neighboring city distancethreshold fromi toi distancethreshold all pairs
maximum segment sum after removals two integer arrays nums both length ith element nums index splitting nums into different segment contiguous sequence positive integers segment sum sum every element integer array length where maximum segment sum after applying ith same index not removed more than nums removequeries using indicate removed answer query remove nums becomes maximum segment sum segment query remove nums becomes maximum segment sum segment query remove nums becomes maximum segment sum segment query remove nums becomes maximum segment sum segment query remove nums becomes maximum segment sum since there no we nums removequeries using indicate removed answer query remove nums becomes maximum segment sum segment query remove nums becomes maximum segment sum segment query remove nums becomes maximum segment sum segment query remove nums becomes maximum segment sum since there no we all values removequeries
count ways to build rooms in an ant colony ant tasked adding new rooms numbered your expansion plan integer array length where indicates must build room before building room these two rooms must connected room already so expansion plan such once all rooms every room reachable room can only build one room can travel freely between rooms have already built only they can choose build any room long previous room already different orders can build all rooms since answer may modulo prevroom there only one way build additional prevroom ways all i every room reachable room once all rooms
distribute coins in binary tree root binary tree nodes where each node tree there coins total throughout whole one we may choose two adjacent nodes move one coin one node move may parent or child minimum moves required make every node have exactly one root root we move one coin left one coin right root left child we move two coins root two we move one coin root tree right nodes tree sum all
minimum absolute difference queries minimum absolute difference array defined minimum value where i j all elements minimum absolute difference minimum absolute difference array note not because must integer array nums array queries where each query compute minimum absolute difference subarray containing elements nums between indices li ri array ans where answer ith subarray contiguous sequence elements value defined x x x nums queries queries processed subarray minimum absolute difference subarray minimum absolute difference subarray minimum absolute difference subarray minimum absolute difference nums queries queries processed subarray minimum absolute difference because all elements subarray minimum absolute difference subarray minimum absolute difference subarray minimum absolute difference li ri
latest time by replacing hidden digits string time form where some digits string hidden valid times those inclusively between latest valid time can get time replacing hidden time latest hour beginning digit latest minute ending digit time time time format guaranteed can produce valid time
count unreachable pairs of nodes in an undirected graph integer there undirected graph numbered integer array edges where denotes there exists undirected edge connecting nodes ai pairs different nodes unreachable each edges there no pairs nodes unreachable each we edges there pairs nodes unreachable each we bi ai bi there no repeated
fancy sequence write api generates fancy sequences using multall implement fancy initializes object empty void appends integer val end void increments all existing values sequence integer void multiplies all existing values sequence integer int gets current value index idx sequence modulo index greater or equal than length input output explanation fancy fancy new fancy fancy fancy fancy fancy fancy fancy m idx most calls total made
minimum space wasted from packaging have packages trying place one package each there m suppliers each produce boxes different sizes infinite package can placed box size package less than or equal size package sizes integer array where size ith suppliers integer array where array box sizes jth supplier want choose single supplier use boxes them such total wasted space each package we define space wasted size box size total wasted space sum space wasted all have fit packages sizes supplier offers boxes sizes can fit packages into two boxes package into box this would result waste minimum total wasted space choosing box supplier or impossible fit all packages inside since answer may modulo packages boxes optimal choose first using two boxes one total waste packages boxes there no box package size can fit packages boxes optimal choose third using two two two total waste m m elements
count good meals good meal meal contains exactly two different food items sum deliciousness equal power can pick any two different foods make good array integers deliciousness where deliciousness ith item different good meals can make this list modulo note items different indices considered different even they have same deliciousness deliciousness good meals their respective sums all which powers deliciousness good meals
game play analysis i sql schema activity column name type int int date int primary key this this table shows activity players some each row record player who logged played games before logging out someday using some write sql query report first login date each result table any query result format following activity
subarrays with k different integers integer array nums integer good subarrays good array array where different integers array exactly different subarray contiguous part nums k subarrays formed exactly different nums k subarrays formed exactly different k
snapshot array implement snapshotarray supports following initializes data structure each element equals void sets element index equal int takes snapshot array returns total times we called minus int returns value time we took snapshot snapshotarray snapshotarr new set length set take get value length index length val total times we call most calls made
subtree of another tree roots two binary trees root true there subtree root same structure node values subroot false subtree binary tree tree tree consists node tree all this tree tree could also considered subtree root subroot true root subroot false nodes root tree range nodes subroot tree range
find the score of all prefixes of an array we define conversion array conver array arr where maximum value over j we also define score array arr sum values conversion array integer array nums length array ans length where score prefix nums prefix conversion array hence score prefix conversion array hence score prefix conversion array hence score prefix conversion array hence score prefix conversion array hence score nums prefix conversion array hence score prefix conversion array hence score prefix conversion array hence score prefix conversion array hence score prefix conversion array hence score prefix conversion array hence score
check if a string contains all binary codes of size k binary string s integer true every binary code length k substring s k true binary codes length they can all found substrings indices s k true binary codes length clear both exist s k false binary code length does not exist either or k
count the number of fair pairs integer array nums size two integers lower fair pair fair i j lower upper nums lower upper there fair nums lower upper there single fair lower upper
k-diff pairs in an array array integers nums integer unique pairs pair integer pair where following j i j k notice denotes absolute value nums k there two pairs although we have two we should only unique nums k there four pairs nums k there one pair k
fizz buzz integer string array answer i divisible i divisible i divisible i none above conditions
maximum number of eaten apples there special kind apple tree grows apples every day ith tree grows apples rot after day i apples rotten cannot some apple tree does not grow any which denoted decided eat most one apple day keep doctors note can keep eating after first two integer arrays days apples length maximum apples can apples days can eat first eat apple grew first second eat apple grew second third eat apple grew second after this apples grew third day fourth seventh eat apples grew fourth apples days can eat first third day eat apples grew first do nothing fouth fifth sixth seventh days eat apples grew sixth only
3sum integer array all triplets such i i j notice solution set must not contain duplicate nums distinct triplets notice order output order triplets does not nums only possible triplet does not sum up nums only possible triplet sums up
non-decreasing subsequences integer array all different possible subsequences array least two may answer any nums nums
find consecutive integers from a data stream stream implement data structure checks last k integers parsed stream equal implement datastream int initializes object empty integer stream two integers value boolean adds num stream returns true last k integers equal false there less than k condition does not hold so returns input output explanation datastream datastream new k only integer so returns only integers since less than returns integers parsed all equal so returns last k integers parsed stream since not equal returns num k most calls made
splitting a string into descending consecutive values string s consists only check we can split s into two or more substrings such numerical values substrings descending order difference between numerical values every two adjacent substrings equal string s can split into numerical values values descending order adjacent values differ so this way another string s can split into or however all ways invalid because they have numerical values all which not descending true possible split s described or false substring contiguous sequence characters s false there no valid way split s true s can split into numerical values values descending order adjacent values differing s false there no valid way split s only consists
maximize number of nice divisors positive integer asked construct positive integer satisfies following prime factors necessarily most nice divisors note divisor nice divisible every prime factor then prime factors then nice while nice divisors since can too modulo note prime natural greater than not product two smaller natural prime factors list prime numbers such their product equals primefactors valid value prime nice there not other value most prime factors more nice primefactors primefactors
distribute repeating integers array where there most unique values also array m customer order where amount integers ith customer determine possible distribute nums such ith customer gets exactly integers ith customer gets all every customer true possible distribute nums according above nums quantity false customer cannot two different nums quantity true customer integers not nums quantity true customer customer m m there most unique values
implement trie (prefix tree) trie or prefix tree tree data structure used efficiently store retrieve keys dataset there various applications this data such autocomplete implement trie initializes trie void inserts string word into boolean returns true string word trie inserted false boolean returns true there previously inserted string word prefix false input output explanation trie trie new true false true true word prefix consist only lowercase english most calls total made
sort array by increasing frequency array integers sort array increasing order based frequency multiple values have same sort them decreasing sorted nums frequency frequency frequency nums both have frequency so they sorted decreasing nums
linked list in binary tree binary tree root linked list head first true all elements linked list starting head correspond some downward path connected binary tree otherwise this context downward path means path starts some node goes head root true nodes blue form subpath binary head root true head root false there no path binary tree contains all elements linked list nodes tree range nodes list range each node linked list binary
k items with the maximum sum there bag consists each item or written four integers bag initially numones items written numzeroes items written numnegones items written we want pick exactly k items among available maximum possible sum numbers written numones numzeros numnegones k we have bag items numbers written them we take items written them get sum total can proven maximum possible numones numzeros numnegones k we have bag items numbers written them we take items written item written get sum total can proven maximum possible numnegones k numones numzeros numnegones
fair distribution of cookies integer array where denotes cookies ith also integer k denotes children distribute all bags cookies all cookies same bag must go same child cannot split unfairness distribution defined maximum total cookies obtained single child minimum unfairness all cookies k one optimal distribution child receives which total child receives which total unfairness distribution can shown there no distribution unfairness less than cookies k one optimal distribution child receives which total child receives which total child receives which total unfairness distribution can shown there no distribution unfairness less than k
count elements with strictly smaller and greater elements integer array elements have both strictly smaller strictly greater element appear nums element element strictly smaller than element strictly greater than element element strictly smaller than element strictly greater than total there elements having both strictly smaller strictly greater element appear nums element element strictly smaller than element strictly greater than since there two elements value total there elements having both strictly smaller strictly greater element appear
decode the message strings key which represent cipher key secret steps decode message use first appearance all lowercase english letters key order substitution align substitution table regular english each letter message then substituted using spaces transformed key key would have least one instance each letter we have partial substitution table decoded key quick brown fox jumps over lazy message bs t diagram above shows substitution obtained taking first appearance each letter quick brown fox jumps over lazy key message hnfx lqantp mnoeius ycgk five boxing wizards jump diagram above shows substitution obtained taking first appearance each letter key consists lowercase english letters key contains every letter english alphabet least message consists lowercase english letters
add strings two represented sum must solve problem without using any library handling large integers must also not convert inputs integers consist only have any leading zeros except zero
number of subsequences that satisfy the given sum condition array integers nums integer subsequences nums such sum minimum maximum element less or equal since answer may too modulo nums target there subsequences satisfy min value max value target nums target there subsequences satisfy can have repeated nums target there two them do not satisfy condition valid subsequences target
minimum weighted subgraph with the required paths integer denoting nodes weighted directed nodes numbered also integer array edges where denotes there exists directed edge fromi toi weight three distinct integers dest denoting three distinct nodes minimum weight subgraph graph such possible reach dest both via set edges this case such subgraph does not subgraph graph whose vertices edges subsets original weight subgraph sum weights constituent edges dest above figure represents input blue edges represent one subgraphs yield optimal note subgraph also yields optimal not possible get subgraph less weight satisfying all edges dest above figure represents input can seen there does not exist any path node node hence there no subgraphs satisfying all dest fromi toi dest pairwise
find the width of columns of a grid m x integer matrix width column maximum length grid width only column since length integer array ans size where width ith length integer x len digits equal len x len grid length grid only length all integers length both length m
get equal substrings within budget two strings s t same length integer want change s changing ith character s ith character t costs absolute difference between ascii values maximum length substring s can changed same corresponding substring t cost less than or equal there no substring s can changed corresponding substring s t maxcost s can change costs so maximum length s t maxcost each character s costs change character so maximum length s t maxcost cannot make any so maximum length maxcost s t consist only lowercase english
check distances between same letters string s consisting only lowercase english where each letter s appears exactly also integer array distance length each letter alphabet numbered letters between two occurrences ith letter ith letter does not appear then can true s otherwise s distance true appears indices so satisfies appears indices so satisfies appears indices so satisfies note but since does not appear can true because s s distance false appears indices so there zero letters between because s not s consists only lowercase english each letter appears s exactly
implement stack using queues implement stack using only two implemented stack should support all functions normal stack implement mystack void pushes element x top int removes element top stack returns int returns element top boolean returns true stack false must use only standard operations which means only push size empty operations depending your queue may not supported may simulate queue using list or deque long use only standard input output explanation mystack mystack new false x most calls made all calls pop top can implement stack using only one
swap adjacent in lr string string composed like move consists either replacing one occurrence or replacing one occurrence starting string start ending string true only there exists sequence moves transform one string start end true we can transform start end following these rxxlrxrxl xrxlrxrxl xrlxrxrxl xrlxxrrxl xrlxxrrlx start end false both start end only consist characters
knight probability in chessboard x knight starts cell attempts make exactly k rows columns so cell cell chess knight eight possible moves can illustrated each move two cells cardinal then one cell orthogonal each time knight chooses one eight possible moves uniformly random piece would go off moves knight continues moving until made exactly k moves or moved off probability knight remains board after stopped k row column there two moves keep knight each those there also two moves keep knight total probability knight stays board k row column k column
implement magic dictionary design data structure initialized list different provided should determine can change exactly one character this string match any word data implement magicdictionary initializes void sets data structure array distinct strings bool returns true can change exactly one character searchword match any string data otherwise returns input output explanation magicdictionary magicdictionary new false we can change second match so we true false false consists only english all strings dictionary searchword consists only english builddict called only once before most calls made
stickers to spell word we different types each sticker lowercase english word would like spell out string target cutting individual letters your collection stickers rearranging can use each sticker more than once have infinite quantities each minimum stickers need spell out task all test all words chosen randomly most common us english target chosen concatenation two random stickers target we can use after cutting rearrange letters those we can form target this minimum stickers necessary form target stickers target we cannot form target cutting letters target consist lowercase english
change minimum characters to satisfy one of three conditions two strings b consist lowercase one can change any character or b any lowercase your goal satisfy one following three every letter strictly less than every letter b every letter b strictly less than every letter both b consist only one distinct minimum operations needed achieve your b consider best way make each condition change b then every letter less than every letter change b then every letter b less than every letter change b then b consist one distinct best way done operations condition or condition b best way make condition true changing b b consist only lowercase
reverse nodes in even length groups head linked nodes linked list sequentially assigned groups whose lengths form sequence natural numbers length group nodes assigned other node assigned first nodes assigned second nodes assigned third so note length last group may less than or equal length second last reverse nodes each group even head modified linked head length first group which hence no reversal length second group which hence nodes length third group which hence no reversal length last group which hence nodes head length first group no reversal length second group nodes length last group no reversal head length first group no reversal length second group nodes length last group nodes nodes list range
longest zigzag path in a binary tree root binary zigzag path binary tree defined choose any node binary tree direction or current direction move right child current move left change direction right left or left repeat second third steps until move zigzag length defined nodes visited single node length longest zigzag path contained root longest zigzag path blue nodes left root longest zigzag path blue nodes right left root nodes tree range
number of submatrices that sum to target matrix submatrices sum submatrix set all cells x y two submatrices different they have some coordinate matrix target four submatrices only contain matrix target two plus two plus matrix target target
random flip matrix there m x binary grid matrix all values set design algorithm randomly pick index where flips all indices where should equally likely optimize your algorithm minimize calls made random function your language optimize time space implement solution int initializes object size binary matrix m returns random index matrix where flips void resets all values matrix input output explanation solution solution new should equally likely since based previously returned only can all values reset can should equally likely there least one free cell each call most calls made flip
largest plus sign integer have x binary grid grid all values initially except some indices array ith element array mines defined where order largest plus sign contained there plus sign order k some center along four arms length k going made note there could or beyond arms plus only relevant area plus sign checked mines above largest plus sign can only order one them mines there no plus so yi all pairs
rings and rods there rings each ring either or rings distributed across ten rods labeled string rings length describes rings placed onto every two characters rings forms pair used describe each ring first character ith pair denotes ith color second character ith pair denotes rod ith ring placed describes red ring placed onto rod labeled green ring placed onto rod labeled blue ring placed onto rod labeled rods have all three colors rings rings rod labeled holds rings all rod labeled holds but only red rod labeled holds only green rods all three colors rings rod labeled holds rings all rod labeled holds only red rods all three colors rings only one ring no rods have all three where i even either or where i odd digit
flower planting with no adjacent have labeled array paths where describes bidirectional path between garden xi garden each want plant one types all gardens have most paths coming into or leaving your task choose flower type each garden such any two gardens connected they have different types any such choice array where type flower planted flower types denoted or guaranteed answer paths gardens have different gardens have different gardens have different valid other valid answers include paths paths yi xi yi every garden most paths coming into or leaving
maximum number of balloons string want use characters text form many instances word can use each character text most maximum instances can text text text text consists lower case english letters
candy there children standing each child assigned rating value integer array giving candies these children subjected following each child must have least one children higher rating get more candies than their minimum candies need have distribute candies ratings can allocate second third child candies ratings can allocate second third child candies third child gets candy because satisfies above two
number of ways to stay in the same place after some steps have pointer index array size each can move position position right or stay same place pointer should not placed outside array any two integers steps ways such your pointer still index after exactly steps since answer may too modulo steps arrlen there differents ways stay index after stay left left stay steps arrlen there differents ways stay index after steps left stay steps arrlen steps arrlen
maximum fruits harvested after at most k steps fruits available some positions infinite integer array fruits where depicts amounti fruits position fruits already sorted positioni ascending each positioni also integer startpos integer position any can either walk left or takes one step move one unit can walk most k steps every position harvest all fruits fruits disappear maximum total fruits can fruits startpos k optimal way move right position harvest fruits move right position harvest fruits moved steps harvested fruits fruits startpos k can move most k so cannot reach position nor optimal way harvest fruits starting position move left position harvest fruit move right position harvest fruits move right position harvest fruits moved steps harvested fruits fruits startpos k can move most k steps cannot reach any position positioni positioni any i amounti k
find and replace pattern list strings words string list match may answer any word matches pattern there exists permutation letters p so after replacing every letter x pattern we get desired recall permutation letters bijection letters every letter maps another no two letters map same words pattern matches pattern because there permutation b does not match pattern because b not since b map same words pattern pattern lowercase english
minimum moves to make array complementary integer array nums even length integer one can replace any integer nums another integer between array nums complementary all indices i equals same array complementary because all indices minimum moves required make nums nums limit can change nums elements every so nums nums limit can change nums cannot change any since nums limit nums already limit
array of doubled pairs integer array even length true possible reorder arr such i every i or false arr false arr false arr true we can take two form or
minimum absolute sum difference two positive integer arrays both length absolute sum difference arrays defined sum each i can replace most one element any other element minimize absolute sum minimum absolute sum difference after replacing most one element array since answer may modulo defined x x or x there two possible optimal replace second element or replace second element both yield absolute sum difference or equal so no replacement this result absolute sum difference replace first element this yields absolute sum difference
online stock span design algorithm collects daily price quotes some stock returns span price current span price one day maximum consecutive days day going which stock price less than or equal price prices stock last four days price stock today then span today because starting price stock less than or equal consecutive prices stock last four days price stock today then span today because starting price stock less than or equal consecutive implement stockspanner initializes object int returns span price price input output explanation stockspanner stockspanner new because last prices price less than or equal price most calls made
design a number container system design container system can do insert or replace index smallest index implement numbercontainers initializes container void int fills container index there already replace int returns smallest index or there no index filled input output explanation numbercontainers nc new there no index filled we your container index filled your container index filled your container index filled your container index filled indices since smallest index filled we your container index filled note index filled then replaced indices smallest index filled we most calls made total change
verifying an alien dictionary alien they also use english lowercase but possibly different order alphabet some permutation lowercase sequence words written alien order true only words sorted lexicographically this alien words order true comes before this then sequence words order false comes after this then hence sequence words order false first three characters second string shorter according lexicographical rules because where defined blank character which less than any other character all characters order english lowercase
find total time spent by each employee sql schema employees column name type int date int int primary key this table shows entries exits day which this event minute which employee entered minute which they left between guaranteed no two events same day intersect write sql query calculate total time minutes spent each employee each day note within one employee can enter leave more than time spent office single entry result table any query result format following employees day employee three two day total one day total employee two one day total one day total
linked list cycle ii head linked node where cycle there no there cycle linked list there some node list can reached again continuously following next pos used denote index node next pointer connected there no note pos not passed do not modify linked head pos tail connects node index there cycle linked where tail connects second head pos tail connects node index there cycle linked where tail connects first head pos no cycle there no cycle linked nodes list range pos or valid index follow can solve using
longest path with different adjacent characters tree undirected graph no rooted node consisting nodes numbered tree represented array parent size where parent node since node also string s length where character assigned node length longest path tree such no pair adjacent nodes path have same character assigned parent s longest path where each two adjacent nodes have different characters tree length this path so can proven there no longer path satisfies parent s longest path where each two adjacent nodes have different characters length this path so all i parent represents valid s consists only lowercase english
profitable schemes there group list various crimes they could ith crime generates requires members participate member participates one member participate another call profitable scheme any subset these crimes generates least minprofit total members participating subset crimes most schemes can since answer may very modulo minprofit group profit make profit least group could either commit crimes or just crime there minprofit group profit make profit least group could commit any long they commit there possible minprofit
path with minimum effort hiker preparing upcoming array size rows x where represents height cell situated hope travel can move or wish find route requires minimum effort maximum absolute difference heights between two consecutive cells minimum effort required travel cell heights route maximum absolute difference consecutive this better than route where maximum absolute difference heights route maximum absolute difference consecutive which better than route heights this route does not require any rows columns columns
minimum speed to arrive on time representing amount time have reach commute must take trains sequential also integer array dist length where describes distance ith train each train can only depart integer so may need wait between each train train ride takes must wait additional hours before can depart train ride hour minimum positive integer speed kilometers per all trains must travel reach office or impossible tests generated such answer not exceed hour have most two digits after decimal dist hour speed first train ride takes since we already integer we depart immediately hour second train takes since we already integer we depart immediately hour third train takes arrive exactly hour dist hour speed first train ride takes since we not integer we wait until hour mark second train ride takes since we already integer we depart immediately hour third train takes arrive hour dist hour impossible because earliest third train can depart hour hour there most two digits after decimal point
flatten binary tree to linked list root binary flatten tree into should use same treenode class where right child pointer points next node list left child pointer always should same order traversal binary root root root nodes tree range follow can flatten tree extra
managers with at least 5 direct reports sql schema employee column name type id int name varchar department varchar managerid int id primary key column this each row this table indicates name their id their managerid then employee does not have no employee manager write sql query report managers least five direct result table any query result format following employee id name department managerid john none dan james amy anne ron b name john
stone game v there several stones arranged each stone associated value which integer array each round alice divides row into two rows left row right then bob calculates value each row which sum values all stones this bob throws away row which maximum score increases value remaining value two rows bob lets alice decide which row thrown next round starts remaining game ends when there only one stone initially maximum score alice can stonevalue first alice divides row left row value right row value bob throws away right row score now second round alice divides row this time bob throws away left row score becomes last round alice only one choice divide row which bob throws away right row score now game ends because only one stone remaining stonevalue stonevalue
letter case permutation string can transform every letter individually lowercase or uppercase create another list all possible strings we could output any s s s consists lowercase english uppercase english
leaf-similar trees consider all leaves binary left right values those leaves form leaf value tree leaf value sequence two binary trees considered their leaf value sequence true only two trees head nodes true false nodes each tree range both trees have values range
merge sorted array two integer arrays sorted two integers m representing elements merge into single array sorted final sorted array should not returned but instead stored inside array accommodate length m where first m elements denote elements should last elements set should length m arrays we merging result merge underlined elements coming m arrays we merging result merge m arrays we merging result merge note because m there no elements only there ensure merge result can fit m m follow can come up algorithm runs
jump game vii binary string s two integers minjump standing index which equal can move index i index j following conditions i minjump j true can reach index or false s minjump maxjump true first move index index second move index index s minjump maxjump false either or minjump maxjump
minimum operations to make the array k-increasing array arr consisting positive positive integer array arr called holds every index where k i arr k same arr not k or k one can choose index i change into any positive minimum operations required make array arr k k resultant array some arrays can formed all them require suboptimal change array because would take can shown we cannot make array less than arr k this same one problem every index i where i since array already we do not need perform any arr k indices only ones not satisfying i one ways we can make array changing array now note there can other ways make array but none them require less than k
pow(x, n) implement which calculates x raised power x x x x either x not zero or xn
check if a string can break another string two same check some permutation string can break some permutation string or other words can break or string x can break string y size alphabetical all i between true permutation which can break string which permutation false all permutations all permutation there not any permutation which can break some permutation true all strings consist lowercase english
valid number valid can split up into these components decimal or or followed decimal can split up into these components sign character or one following one or more followed dot one or more followed dot followed one or more dot followed one or more integer can split up into these components sign character or one or more all following valid while following not valid string true s valid s true s false s false s consists only english letters uppercase digits plus minus or dot
largest local values in a matrix x integer matrix generate integer matrix maxlocal size x such equal largest value x matrix grid centered around row i column j other we want find largest value every contiguous x matrix generated grid diagram above shows original matrix generated notice each value generated matrix corresponds largest value contiguous x matrix grid notice contained within every contiguous x matrix
reconstruct original digits from english string s containing english representation digits digits ascending s s one characters s guaranteed
max consecutive ones iii binary array nums integer maximum consecutive array can flip most k nums k bolded numbers flipped longest subarray nums k bolded numbers flipped longest subarray either or k
first missing positive unsorted integer array smallest missing positive must implement algorithm runs time uses constant extra nums numbers range all nums array but nums smallest positive integer
minimum changes to make alternating binary string string s consisting only characters one can change any or vice string called alternating no two adjacent characters string while string minimum operations needed make s s change last character s which s s already s need two operations reach or either or
intervals between identical elements array integers interval between two elements arr defined absolute difference between their more interval between array intervals length where sum intervals between each element arr same value absolute value arr index another found index index another found index index two more found indices index another found index index another found index index two more found indices index two more found indices arr index two more found indices index there only one so sum intervals identical elements index two more found indices index two more found indices
car pooling there car capacity empty vehicle only drives east cannot turn around drive integer capacity array trips where indicates ith trip numpassengersi passengers locations pick them up drop them off fromi toi locations kilometers due east initial true possible pick up drop off all passengers all or false trips capacity false trips capacity true numpassengersi fromi toi capacity
find duplicate file in system list paths directory including directory all files contents this all duplicate files file system terms their may answer any group duplicate files consists least two files have same single directory info string input list following means there files content respectively directory note m m means directory just root output list groups duplicate file each contains all file paths files have same file path string following paths paths consist english may assume no files or directories share same name same may assume each directory info represents unique single blank space separates directory path file follow imagine real file how search dfs or file content very large how modify your can only read file each how modify your what time complexity your modified what most part part how how make sure duplicated files find not false
count distinct numbers on board positive integer initially placed every perform following each x present find all numbers i such x i place those numbers distinct integers present board after days have once placed remain until stands modulo present next added since after added board because end billion distinct numbers board since added after billion only two distinct numbers board
kth missing positive number array arr positive integers sorted strictly increasing integer kth positive integer missing this arr k missing positive integers missing positive integer arr k missing positive integers missing positive integer k i j follow could solve this problem less than
count substrings that differ by one character two strings s find ways can choose substring s replace single character different character such resulting substring substring other find substrings s differ some substring t exactly one underlined substrings only differ so this valid substrings satisfy condition substring contiguous sequence characters within s t following pairs substrings s t differ exactly underlined portions substrings chosen s s t following pairs substrings s t differ underlined portions substrings chosen s s t consist lowercase english letters
construct binary tree from inorder and postorder traversal two integer arrays inorder postorder where inorder inorder traversal binary tree postorder postorder traversal same construct binary inorder postorder inorder postorder inorder postorder consist unique each value postorder also appears inorder guaranteed inorder traversal postorder guaranteed postorder traversal
convert sorted array to binary search tree integer array nums where elements sorted ascending convert binary search nums also nums both nums sorted strictly increasing
exam room there exam room seats single row labeled when student enters they must sit seat maximizes distance closest there multiple such they sit seat lowest no one then student sits seat design class simulates mentioned exam implement examroom initializes object exam room seats int returns label seat which next student void indicates student sitting seat p leave guaranteed there student sitting seat input output explanation examroom examroom new no one then student sits seat student sits last seat student sits last seat student sits last seat student sits last seat guaranteed there student sitting seat most calls made seat
lowest common ancestor of deepest leaves root binary lowest common ancestor deepest recall node binary tree leaf only no children depth root tree depth node depth each children d lowest common ancestor set s node largest depth such every node s subtree root root we node value colored yellow nodes coloured blue deepest note nodes also leaf but depth them but depth nodes root root deepest node lca root deepest leaf node tree lca one node nodes tree range values nodes tree this question same
removing stars from a string string which contains stars one choose star remove closest character well remove star string after all stars have been input generated such operation always can shown resulting string always s performing removals left closest character star s becomes closest character star s becomes closest character star s becomes there no more so we s entire string so we empty s consists lowercase english letters stars operation above can performed
sender with largest word count have chat log two string arrays messages senders where message sent message list words separated single space no leading or trailing word count sender total words sent note sender may send more than one sender largest word there more than one sender largest word one lexicographically largest uppercase letters come before lowercase letters lexicographical messages day day senders alice sends total usertwo sends total userthree sends total since alice largest word we messages leetcode useful senders bob sends total charlie sends total since there tie largest word we sender lexicographically larger consists uppercase lowercase english letters all words separated single does not have leading or trailing consists uppercase lowercase english letters
maximum score of a good subarray array integers nums integer score subarray defined i good subarray subarray where i k maximum possible score good nums k optimal subarray score nums k optimal subarray score k
backspace string compare two strings s true they equal when both typed into empty text means backspace note after backspacing empty text continue s t true both s t become s t true both s t become s t false s becomes while t becomes s t only contain lowercase letters follow can solve time
maximum subsequence score two integer arrays equal length positive integer must choose subsequence indices length chosen indices ik your score defined sum selected elements multiplied minimum selected elements can defined simply maximum possible subsequence indices array set can derived set deleting some or no k four possible subsequence scores we choose indices score we choose indices score we choose indices score we choose indices score we max which k choosing index maximum possible k
linked list cycle head linked determine linked list cycle there cycle linked list there some node list can reached again continuously following next pos used denote index node next pointer connected note pos not passed true there cycle linked head pos true there cycle linked where tail connects node head pos true there cycle linked where tail connects head pos false there no cycle linked nodes list range pos or valid index follow can solve using
maximum profit of operating a centennial wheel operator centennial wheel four each gondola room up four have ability rotate gondolas which costs runningcost array customers length where new customers arriving just before ith rotation this means must rotate wheel i times before customers cannot make customers wait there room each customer pays boardingcost dollars when they board gondola closest ground exit once gondola reaches ground can stop wheel any including before serving all decide stop serving all subsequent rotations free order get all customers down note there currently more than four customers waiting only four board rest wait next minimum rotations need perform maximize your there no scenario where profit customers boardingcost runningcost numbers written gondolas people currently customers board wait next wheel current profit customers waiting board wheel other wheel current profit final customers board wheel current profit highest profit after rotating wheel customers boardingcost runningcost customers board wait next wheel current profit customers board wait originally newly wheel current profit final customers board wheel current profit board wheel current profit board wheel current profit board wheel current profit wheel current profit highest profit after rotating wheel customers boardingcost runningcost customers board wheel current profit customers board wheel current profit customers board wheel current profit customers board wheel current profit customer board wheel current profit profit never so runningcost
grumpy bookstore owner there bookstore owner store open every some customers enter integer array customers length where customer enters store start ith minute all those customers leave after end some bookstore owner binary array grumpy where bookstore owner grumpy during ith when bookstore owner customers minute not they bookstore owner knows secret technique keep themselves not grumpy minutes consecutive but can only use maximum customers can satisfied throughout customers grumpy minutes bookstore owner keeps themselves not grumpy last maximum customers can satisfied customers grumpy minutes minutes either or
max difference you can get from changing an integer integer apply following steps exactly two pick digit x x pick another digit y y digit y can equal replace all occurrences x decimal representation num new integer cannot have any leading also new integer cannot let b results applying operations num first second max difference between num first time pick x y store new integer second time pick x y store new integer we have now b max difference num first time pick x y store new integer second time pick x y store new integer we have now b max difference num
number of ways of cutting a pizza rectangular pizza represented rows x cols matrix containing following integer have cut pizza into k pieces using each cut choose vertical or then choose cut position cell boundary cut pizza into two cut pizza give left part pizza cut pizza give upper part pizza give last piece pizza last ways cutting pizza such each piece contains least one since answer can huge this modulo pizza k figure above shows three ways cut note pieces must contain least one pizza k pizza k cols rows cols k pizza consists characters
next greater numerically balanced number integer x numerically balanced every digit d there exactly d occurrences digit integer smallest numerically balanced strictly greater than numerically balanced digit occurs also smallest numerically balanced strictly greater than numerically balanced digit occurs digit occurs also smallest numerically balanced strictly greater than note cannot answer because appeared more than numerically balanced digit occurs digit occurs also smallest numerically balanced strictly greater than
monotonic array array monotonic either monotone increasing or monotone array nums monotone increasing all i array nums monotone decreasing all i integer array true array or false nums true nums true nums false
advantage shuffle two integer arrays both same advantage respect indices i which any permutation maximizes advantage respect
shortest palindrome string can convert s palindrome adding characters front shortest palindrome can find performing this s s s consists lowercase english letters
painting a grid with three different colors two integers m consider m x grid where each cell initially can paint each cell or all cells must ways color grid no two adjacent cells having same since answer can very modulo m three possible colorings shown image m six possible colorings shown image m m
allocate mailboxes array houses where location ith house along street integer allocate k mailboxes minimum total distance between each house nearest test cases generated so answer fits houses k allocate mailboxes position minimum total distance each houses nearest mailboxes houses k allocate mailboxes position minimum total distance each houses nearest mailboxes k all integers houses
minimum hours of training to win a competition entering two positive integers initialenergy initialexperience denoting your initial energy initial experience also two integer arrays energy both length face opponents energy experience ith opponent denoted when face need have both strictly greater experience energy defeat them move next opponent defeating ith opponent increases your experience but decreases your energy before starting can train some after each hour can either choose increase your initial experience or increase your initial energy minimum training hours required defeat all initialenergy initialexperience energy experience can increase your energy after hours your experience after hours face opponents following have more energy experience than opponent so your energy becomes your experience becomes have more energy experience than opponent so your energy becomes your experience becomes have more energy experience than opponent so your energy becomes your experience becomes have more energy experience than opponent so your energy becomes your experience becomes did total hours training before so we can proven no smaller answer initialenergy initialexperience energy experience do not need any additional energy or experience win so we
invalid transactions transaction possibly invalid amount exceeds occurs within minutes another transaction same name different array strings transaction where consists values representing time city list transactions possibly may answer any transactions first transaction invalid because second transaction occurs within difference have same name different similarly second one invalid transactions transactions each takes form each consist lowercase english have lengths between each consist represent integer between each consist represent integer between
maximum number of integers to choose from a range i integer array banned two integers choosing some integers following below chosen integers have range each integer can chosen most chosen integers should not array sum chosen integers should not exceed maximum integers can choose following mentioned banned maxsum can choose integers range both did not appear their sum which did not exceed banned maxsum cannot choose any integer while following mentioned banned maxsum can choose integers they range all did not appear their sum which did not exceed maxsum
check if it is a straight line array where represents coordinate check these points make straight line xy coordinates true coordinates false coordinates contains no duplicate
eliminate maximum number of monsters playing video game where defending your city group integer array dist size where initial distance kilometers ith monster monsters walk toward city constant speed each monster integer array speed size where speed ith monster kilometers per have weapon once fully can eliminate single weapon takes one minute weapon fully charged very lose when any monster reaches your monster reaches city exact moment weapon fully counts game ends before can use your maximum monsters can eliminate before or can eliminate all monsters before they reach dist speed distances monsters eliminate first after distances monsters eliminate second after distances monsters eliminate thrid all monsters can dist speed distances monsters eliminate first after distances monsters so can only eliminate dist speed distances monsters eliminate first after distances monsters so can only eliminate
house robber iii thief found himself new place his thievery there only one entrance this called besides each house one only one parent after smart thief realized all houses this place form binary automatically contact police two houses broken into same root binary maximum amount money thief can rob without alerting root maximum amount money thief can rob root maximum amount money thief can rob nodes tree range
number of steps to reduce a number to zero integer steps reduce one current have divide have subtract num step divide obtain step subtract obtain step divide obtain step subtract obtain step divide obtain step subtract obtain num step divide obtain step divide obtain step divide obtain step subtract obtain num num
cyclically rotating a grid m x integer matrix where m both even integer matrix composed several which shown below where each color own cyclic rotation matrix done cyclically rotating each layer cyclically rotate layer each element layer take place adjacent element rotation shown matrix after applying k cyclic rotations grid k figures above represent grid every grid k figures above represent grid every m both m even k
minimum number of flips to make the binary string alternating binary string allowed perform two types operations string any remove character start string s append end pick any character s flip value becomes minimum operations need perform such s becomes string called alternating no two adjacent characters strings while string s use first operation two times make s use second operation third sixth elements make s s string already s use second operation second element make s either or
nearest exit from entrance in maze m x matrix maze empty cells walls also entrance where entrance denotes row column cell initially standing one can move one cell or cannot step into cell cannot step outside your goal find nearest exit exit defined empty cell border entrance does not count steps shortest path entrance nearest or no such path maze entrance there exits this maze entrance cell can reach moving steps can reach moving step impossible reach nearest exit which step maze entrance there exit this maze does not count exit since entrance entrance cell can reach moving steps nearest exit which steps maze entrance there no exits this m either or entrancerow m entrancecol entrance always empty
maximum path quality of a graph there undirected graph nodes numbered integer array values where value ith also integer array where each indicates there undirected edge between nodes uj takes timej seconds travel between two integer valid path graph any path starts node ends node takes most maxtime seconds may visit same node multiple quality valid path sum values unique nodes visited path value added most once maximum quality valid there most four edges connected each values edges maxtime one possible path total time taken nodes visited giving maximal path quality values edges maxtime one possible path total time taken nodes visited giving maximal path quality values edges maxtime one possible path total time taken nodes visited giving maximal path quality uj vj maxtime all pairs there most four edges connected each graph may not
number of music playlists your music player contains different want listen goal songs necessarily during your avoid create playlist so every song played least song can only played again only k other songs have been possible playlists can since answer can very modulo goal k there possible goal k there possible goal k there possible k goal
the latest time to catch a bus integer array buses length where represents departure time ith also integer array passengers length where represents arrival time jth all bus departure times all passenger arrival times integer which represents maximum passengers can get each when passenger they wait line next available can get bus departs x minutes arrive y minutes where y bus not passengers earliest arrival times get bus more formally when bus capacity or fewer passengers waiting they all get or capacity passengers earliest arrival times get latest time may arrive bus station catch cannot arrive same time another arrays buses passengers not necessarily buses passengers capacity suppose arrive time time first bus departs time second bus departs note may not arrive same time another which why must arrive before passenger catch buses passengers capacity suppose arrive time time first bus departs time second bus departs time third bus departs passenger notice had arrived any then passenger would have taken your seat third m capacity each element buses each element passengers
maximum matrix sum x integer can do following operation any choose any two adjacent elements matrix multiply each them two elements considered adjacent only they share your goal maximize summation maximum sum elements using operation mentioned matrix we can follow following steps reach sum equals multiply elements first row multiply elements first column matrix we can follow following step reach sum equals multiply last elements second row
string matching in an array array string all strings words substring another can answer any substring contiguous sequence characters within string words substring substring also valid words substring words no string words substring another contains only lowercase english all strings words
walking robot simulation ii width x height grid cell cell height grid aligned four cardinal directions robot initially cell facing direction robot can instructed move specific each does attempts move forward one cell direction cell robot moving out robot instead turns degrees counterclockwise retries after robot finishes moving steps stops awaits next implement robot int initializes width x height grid robot facing void instructs robot move forward num returns current cell robot array length string returns current direction or input output explanation robot robot new initialize grid robot facing moves two steps east faces moves two steps east faces moves one step east faces moving next step east would out so turns faces moves one step north faces moves one step north faces north moving next step north would out so turns faces moves four steps west faces height num most calls total made
divide array in sets of k consecutive numbers array integers nums positive integer check whether possible divide this array into sets k consecutive true nums k true array can divided into nums k true array can divided into nums k false each array should divided subarrays size k this question same
detect cycles in 2d grid array characters grid size m x need find there exists any cycle consisting same value cycle path length or more grid starts ends same can move one cells adjacent one four directions or same value current cannot move cell visited your last cycle invalid because we visited which last visited true any cycle same value exists grid true there two valid cycles shown different colors image grid true there only one valid cycle highlighted image grid false m grid consists only lowercase english
assign cookies assume awesome parent want give your children some should give each child most one each child i greed factor which minimum size cookie child content each cookie j size we can assign cookie j child child i your goal maximize your content children output maximum g s have children greed factors children even though have since their size both could only make child whose greed factor need output g s have children greed factors children have cookies their sizes big enough gratify all need output
sales analysis iii sql schema product column name type int varchar int primary key this each row this table indicates name price each sales column name type int int int date quantity int price int this table no primary can have repeated foreign key product each row this table contains some information about one write sql query reports products only sold first quarter between result table any query result format following product iphone sales quantity price product id only sold spring product id sold spring but also sold after spring product id sold after spring we only product product only sold spring
minimum additions to make valid string string word which can insert letters or anywhere any minimum letters must inserted so word becomes string called valid can formed concatenating string several word insert letter right before letter right next obtain valid string word insert letters next each obtain valid string word word already no modifications word consists letters
minimum string length after removing substrings string s consisting only uppercase english can apply some operations this string one can remove any occurrence one substrings or minimum possible length resulting string can note string concatenates after removing substring could produce new or s we can do following remove substring so s remove substring so s remove substring so s so resulting length string can shown minimum length we can s we cannot do any operations string so length remains s consists only uppercase english
best time to buy and sell stock with transaction fee array prices where price stock ith integer fee representing transaction find maximum profit can may complete many transactions but need pay transaction fee each may not engage multiple transactions simultaneously must sell stock before buy prices fee maximum profit can achieved buying selling buying selling total profit prices fee fee
third maximum number integer array third distinct maximum this third maximum does not maximum nums first distinct maximum second distinct maximum third distinct maximum nums first distinct maximum second distinct maximum third distinct maximum does not so maximum returned nums first distinct maximum second distinct maximum counted together since they have same third distinct maximum follow can find
image overlap two represented square matrices size x binary matrix only we translate one image however we choose sliding all bits down any we then place top other we can then calculate overlap counting positions have both note also translation does not include any kind any bits translated outside matrix borders largest possible we translate right unit down positions have both images either or either or
minimum bit flips to convert number bit flip x choosing bit binary representation x flipping either or x binary representation we may choose any bit any leading zeros not flip we can flip first bit right get flip second bit right get flip fifth bit right leading get two integers start minimum bit flips convert start start goal binary representation we can convert flip first bit flip third bit flip fourth bit can shown we cannot convert less than we start goal binary representation we can convert flip first bit flip second bit flip third bit can shown we cannot convert less than we goal
number of senior citizens array strings each element details provides information about passenger compressed into string length system such first ten characters consist phone next character denotes gender following two characters used indicate age last two characters determine seat allotted passengers who strictly more than years details passengers indices have ages there people who over years details none passengers older than consists digits either or or phone numbers seat numbers passengers
count the number of beautiful subarrays integer array one choose two different indices i j such j choose integer k such kth bit binary representation subtract subarray beautiful possible make all elements equal after applying above operation any beautiful subarrays array subarray contiguous sequence elements within nums there beautiful subarrays we can make all elements subarray equal following choose k subtract both subarray becomes choose k subtract both subarray becomes we can make all elements subarray equal following choose k subtract both subarray becomes choose k subtract both subarray becomes choose k subtract both subarray becomes nums there no beautiful subarrays
check if all the integers in a range are covered integer array ranges two integers left each represents inclusive interval between starti true each integer inclusive range covered least one interval false integer x covered interval starti x ranges left right true every integer between covered first covered second covered third ranges left right false not covered any starti endi left right
fibonacci number fibonacci commonly denoted form called fibonacci such each sum two preceding starting calculate
my calendar ii implementing program use your we can add new event adding event not cause triple triple booking happens when three events have some intersection some moment common all three event can represented pair integers start end represents booking interval range real numbers x such start x implement mycalendartwo initializes calendar boolean int returns true event can added calendar successfully without causing triple false do not add event input output explanation mycalendartwo mycalendartwo new event can event can event can double event cannot because would result triple event can does not use time which already double event can time double booked third time single time double booked second start end most calls made
binary number with alternating bits positive check whether alternating two adjacent bits always have different true binary representation false binary representation false binary representation
last moment before all ants fall out of a plank we have wooden plank length some ants walking each ant moves speed unit per some ants move other move when two ants moving two different directions meet some they change their directions continue moving assume changing directions does not take any additional when ant reaches one end plank time falls out plank integer two integer arrays left positions ants moving left moment when last fall out left right image ant index named going ant index named b going ant index named c going ant index named d going last moment when ant plank t after falls immediately out we can say t there no ants left right all ants going ant index needs seconds left right all ants going ant index needs seconds all values left right each value can appear only one two
counting words with a given prefix array strings words string strings words contain pref prefix string s any leading contiguous substring words pref strings contain prefix words pref there no strings contain pref consist lowercase english
numbers with repeated digits integer positive integers range have least one repeated only positive least repeated digit positive numbers atleast repeated digit
maximum width of binary tree root binary maximum width maximum width tree maximum width among all width one level defined length between leftmost rightmost where null nodes between would present complete binary tree extending down level also counted into length guaranteed answer range signed root maximum width exists third level length root maximum width exists fourth level length root maximum width exists second level length nodes tree range
course schedule iv there total numcourses courses have labeled numcourses array prerequisites where indicates must take course ai first want take course pair indicates have take course before can take course prerequisites can also course prerequisite course course b prerequisite course then course prerequisite course also array queries where jth should answer whether course uj prerequisite course vj or boolean array where answer jth numcourses prerequisites queries pair indicates have take course before can take course course not prerequisite course but opposite numcourses prerequisites queries there no each course numcourses prerequisites queries numcourses bi ai bi all pairs prerequisites graph no vi ui vi
number of valid words in a sentence sentence consists lowercase letters digits hyphens punctuation marks spaces each sentence can broken down into one or more tokens separated one or more spaces token valid word all three following only contains lowercase punctuation there most one hyphen must surrounded lowercase characters but not there most one punctuation must end token but not examples valid words include string valid words sentence valid words sentence sentence there no valid words invalid because starts punctuation invalid because they contain sentence bob playing valid words sentence invalid because contains sentence only contains lowercase english there least
find the kth smallest sum of a matrix with sorted rows m x matrix mat rows sorted order integer allowed choose exactly one element each row form kth smallest array sum among all possible mat k choosing one element each first k smallest sum where sum mat k mat k choosing one element each first k smallest sum where sum m k
longest string chain array words where each word consists lowercase english worda predecessor wordb only we can insert exactly one letter anywhere worda without changing order other characters make equal predecessor while not predecessor word chain sequence words k where predecessor predecessor so single word trivially word chain k length longest possible word chain words chosen list words one longest word chains words all words can put word chain words trivial word chain one longest word not valid word chain because ordering letters only consists lowercase english
maximum or integer array nums length integer can choose element multiply maximum possible value can obtained after applying operation nums most k note b denotes bitwise or between two integers nums k we apply operation index our new array nums equal we bitwise or which nums k we apply operation twice index we yield new array we k
sum of unique elements integer array unique elements array elements appear exactly once sum all unique elements nums unique elements sum nums there no unique sum nums unique elements sum
capital gain/loss sql schema stocks column name type varchar operation enum int price int primary key this operation column enum type each row this table indicates stock which had operation day guaranteed each operation stock corresponding operation previous also guaranteed each operation stock corresponding operation upcoming write sql query report capital each capital stock total gain or loss after buying selling stock one or many result table any query result format following stocks operation price leetcode buy corona masks buy leetcode sell handbags buy corona masks sell corona masks buy corona masks sell corona masks buy handbags sell corona masks sell corona masks leetcode handbags leetcode stock bought day sold day capital gain handbags stock bought day sold day capital loss corona masks stock bought day sold day bought again day sold day bought day sold day capital sum capital each operation
stone game ix alice bob continue their games there row each stone associated integer array where value ith alice bob take alice starting each player may remove any stone player who removes stone loses sum values all removed stones divisible bob win automatically there no remaining stones assuming both players play true alice wins false bob stones true game played turn alice can remove either turn bob removes remaining sum removed stones divisible bob loses alice wins stones false alice remove only sum values removed stones since all stones removed sum values not divisible bob wins stones false bob always one possible way bob win shown turn alice can remove second stone value sum removed stones turn bob removes fifth stone value sum removed stones turn alices removes fourth stone value sum removed stones turn bob removes third stone value sum removed stones turn alice removes first stone value sum removed stones alice loses game because sum removed stones divisible bob wins
iterator for combination design combinationiterator int initializes object string characters sorted distinct lowercase english letters combinationlength returns next combination length combinationlength lexicographical returns true only there exists next input output explanation combinationiterator itr new true true false combinationlength all characters characters most calls made next guaranteed all calls function next
check if a word occurs as a prefix of any word in a sentence sentence consists some words separated single check searchword prefix any word index word sentence where searchword prefix this searchword prefix more than one index first word there no such word prefix string s any leading contiguous substring sentence love eating searchword prefix which word sentence problem easy searchword prefix which word but we minimal sentence am searchword not prefix any word sentence consists lowercase english letters searchword consists lowercase english
check if all a's appears before all b's string s consisting only characters true every appears before every s true indices while indices every appears before every we s false there index index not every appears before every we s true there no every appears before every we either or
widest vertical area between two points containing no points points plane where widest vertical area between two points such no points inside vertical area area extending infinitely along infinite widest vertical area one maximum note points edge vertical area not considered included points both red blue area points yi
matrix block sum m x matrix mat integer matrix answer where each sum all elements i k r i j k c j valid position mat k mat k m k
count nice pairs in an array array nums consists let us define reverse integer pair indices nice satisfies all following i j nice pairs since can too modulo nums two pairs nums
finding 3-digit even numbers integer array where each element array may contain need find all unique integers follow integer consists concatenation three elements digits any arbitrary integer does not have leading integer digits integers follow sorted array unique digits all possible integers follow requirements output notice there no odd integers or integers leading digits same digit can used many times appears this digit used twice each time digits no even integers can formed using
count nodes equal to average of subtree root binary nodes where value node equal average values average elements sum elements divided rounded down nearest subtree root tree consisting root all root node value average subtree node value average subtree node value average subtree node value average subtree node value average subtree root node value average subtree nodes tree range
letter tile possibilities have where each tile one letter printed possible sequences letters can make using letters printed those tiles possible sequences tiles tiles tiles consists uppercase english
filter restaurants by vegan-friendly, price and distance array restaurants where have filter restaurants using three veganfriendly filter either true should only include restaurants veganfriendlyi set or false can include any have filters maxprice maxdistance which maximum value price distance restaurants should consider array restaurant ids after ordered rating highest restaurants same order them id highest simplicity veganfriendlyi veganfriendly take value when when restaurants veganfriendly maxprice maxdistance restaurants restaurant restaurant restaurant restaurant restaurant after filter restaurants veganfriendly maxprice maxdistance we have restaurant restaurant restaurant rating highest restaurants veganfriendly maxprice maxdistance restaurants same but this case filter veganfriendly therefore all restaurants restaurants veganfriendly maxprice maxdistance distancei maxdistance veganfriendlyi veganfriendly or all idi
product of the last k numbers design algorithm accepts stream integers retrieves product last k integers implement productofnumbers initializes object empty void appends integer num int returns product last k numbers current can assume always current list least k test cases generated so any product any contiguous sequence numbers fit into single integer without input output explanation productofnumbers productofnumbers new product last numbers product last numbers product last numbers product last numbers num k most calls made add product stream any point time fit
minimize malware spread network nodes represented x adjacency matrix where ith node directly connected jth node some nodes initial initially infected whenever two nodes directly least one those two nodes infected both nodes infected this spread malware continue until no more nodes can infected this suppose final nodes infected malware entire network after spread malware we remove exactly one node node would minimize multiple nodes could removed minimize such node smallest note node removed initial list infected might still infected later due malware graph initial graph initial graph initial or all integers initial
minimum number of arrows to burst balloons there some spherical balloons taped onto flat wall represents balloons represented integer array points where denotes balloon whose horizontal diameter stretches between xstart do not know exact arrows can shot up directly vertically positive different points along balloon xstart xend burst arrow shot x xstart x there no limit arrows can shot arrow keeps traveling up bursting any balloons array minimum arrows must shot burst all points balloons can burst shoot arrow x bursting balloons shoot arrow x bursting balloons points one arrow needs shot each balloon total points balloons can burst shoot arrow x bursting balloons shoot arrow x bursting balloons xstart xend
neighboring bitwise xor array derived length derived computing bitwise xor adjacent values binary array original length each index i range i then array your task determine whether there exists valid binary array original could have formed true such array exists or false binary array array containing only derived true valid original array gives derived derived true valid original array gives derived derived false there no valid original array gives values derived either or
product sales analysis iii sql schema sales column name type int int year int quantity int price int primary key this foreign key product each row this table shows sale product certain note price per product column name type int varchar primary key this each row this table indicates product name each write sql query selects product price first year every product resulting table any query result format following sales year quantity price product nokia apple samsung quantity price
car fleet ii there cars traveling different speeds same direction along array cars length where positioni distance between ith car beginning road guaranteed positioni speedi initial speed ith car meters per cars can considered points moving along two cars collide when they occupy same once car collides another they unite form single car cars formed fleet have same position same which initial speed slowest car array where which ith car collides next or car does not collide next answers within actual answers cars after exactly one first car collide second form car fleet speed after exactly third car collide fourth form car fleet speed cars speedi positioni
random point in non-overlapping rectangles array rectangles rects where indicates corner point ith rectangle corner point ith design algorithm pick random integer point inside space covered one point perimeter rectangle included space covered any integer point inside space covered one rectangles should equally likely note integer point point integer implement solution initializes object rectangles returns random integer point inside space covered one input output explanation solution solution new ai xi bi yi xi ai yi bi all rectangles do not most calls made
valid boomerang array points where represents point true these points boomerang set three points all distinct not straight points true points false yi
richest customer wealth m x integer grid accounts where amount money ith customer jth wealth richest customer wealth amount money they have all their bank richest customer customer maximum accounts customer wealth customer wealth both customers considered richest wealth so accounts customer wealth customer wealth customer wealth customer richest wealth accounts m
watering plants ii alice bob want water plants their plants arranged row labeled left right where ith plant located x each plant needs specific amount alice bob have watering can initially they water plants following alice waters plants order left starting bob waters plants order right starting they begin watering plants takes same amount time water each plant regardless how much water must water plant they have enough their can fully water they first refill their can then water case both alice bob reach same one more water currently watering can should water this they have same amount then alice should water this integer array plants where amount water ith plant two integers capacitya capacityb representing capacities watering cans times they have refill water all plants capacitya capacityb alice bob have units water each their watering alice waters plant bob waters plant alice bob now have units units water alice enough water plant so she waters bob does not have enough water plant so refills his can then waters total times they have refill water all plants plants capacitya capacityb alice bob have units units water their watering cans alice waters plant bob waters plant alice bob now have unit water need water plants since neither them have enough water their current they refill their cans then water total times they have refill water all plants plants capacitya capacityb there only one watering can units whereas can since alice more water her she waters this total times they have refill capacityb
combination sum ii collection candidate numbers target find all unique combinations candidates where candidate numbers sum each candidates may only used once solution set must not contain duplicate candidates target candidates target target
smallest integer divisible by k positive integer need find length smallest positive integer such divisible only contains digit length there no such may not fit signed k smallest answer which length k there no such positive integer divisible k smallest answer which length k
minimize result by adding parentheses to expression string expression form where represent positive add pair parentheses expression such after addition expression valid mathematical expression evaluates smallest possible left parenthesis must added left right parenthesis must added right expression after adding pair parentheses such expression evaluates smallest possible there multiple answers yield same any input been generated such original value value expression after adding any pair parentheses meets requirements fits within signed expression expression evaluates note invalid because right parenthesis must right can shown smallest possible expression expression evaluates expression expression evaluates expression consists digits expression starts ends expression contains exactly one original value value expression after adding any pair parentheses meets requirements fits within signed
simple bank system have been tasked writing program popular bank automate all incoming transactions bank accounts numbered initial balance each account stored integer array account having initial balance execute all valid transaction valid account between amount money withdrawn or transferred less than or equal balance implement bank initializes object integer array boolean int long transfers money dollars account numbered account numbered true transaction false boolean long deposit money dollars into account numbered true transaction false boolean long withdraw money dollars account numbered true transaction false input output explanation bank bank new account balance so valid withdraw account account balance so valid transfer account account valid deposit account account current balance account so invalid transfer invalid because account does not money most calls made each function
minimum cost to reach destination in time there country cities numbered where all cities connected roads represented integer array edges where denotes road between cities xi yi takes timei minutes there may multiple roads differing travel times connecting same two but no road connects city each time pass through must pay passing this represented integer array passingfees length where amount dollars must pay when pass through city city want reach city maxtime minutes or cost your journey summation passing fees each city passed through some moment your journey source destination minimum cost complete your or cannot complete within maxtime maxtime edges passingfees path take which takes minutes worth passing maxtime edges passingfees path take which takes minutes worth passing cannot take path since would take too maxtime edges passingfees there no way reach city city within maxtime yi timei graph may contain multiple edges between two graph does not contain self
the number of beautiful subsets array nums positive integers positive integer subset nums beautiful does not contain two integers absolute difference equal beautiful subsets array subset nums array can obtained deleting some elements two subsets different only chosen indices delete nums k beautiful subsets array nums can proved there only beautiful subsets array nums k beautiful subset array nums can proved there only beautiful subset array k
minimum number of flips to convert binary matrix to zero matrix m x binary matrix one can choose one cell flip all four neighbors they exist changing pair cells called neighbors they share one minimum steps required convert mat zero matrix or binary matrix matrix all cells equal or zero matrix matrix all cells equal mat one possible solution flip then finally mat matrix zero we do not need change mat matrix cannot zero m either or
first unique character in a string string find first character does not s s s s consists only lowercase english
longest happy string string s called happy satisfies following s only contains letters s does not contain any or s contains most occurrences letter s contains most b occurrences letter s contains most c occurrences letter three integers longest possible happy there multiple longest happy any there no such empty string substring contiguous sequence characters within b c would also correct b c only correct answer this c b c
percentage of users attended a contest sql schema users column name type int varchar primary key this each row this table contains name id register column name type int int primary key this each row this table contains id user contest they registered write sql query find percentage users registered each contest rounded two result table ordered percentage descending case order ascending query result format following users alice bob alex register percentage all users registered contests percentage we sort them answer table ascending alice alex registered contest percentage bob registered contest percentage
rearrange array elements by sign integer array nums even length consisting equal positive negative should rearrange elements nums such modified array follows every consecutive pair integers have opposite all integers same order which they present nums rearranged array begins positive modified array after rearranging elements satisfy aforementioned nums positive integers nums negative integers only possible way rearrange them such they satisfy all conditions other ways such incorrect because they do not satisfy one or more nums only positive integer only negative integer so nums rearranged even nums consists equal positive negative
minimum total cost to make arrays unequal two integer arrays equal length one can swap values any two indices cost this operation sum find minimum total cost performing operation any times such all i after performing all minimum total cost such satisfy above case not one ways we can perform operations swap values indices incurring cost swap values indices incurring cost swap values indices incurring cost we can see each index cost required here note there other ways swap but can proven not possible obtain cost less than one ways we can perform operations swap values indices incurring cost swap values indices incurring cost total cost needed here which minimum can shown not possible satisfy conditions irrespective operations we we
find all anagrams in a string two strings s array all start indices anagrams may answer any anagram word or phrase formed rearranging letters different word or typically using all original letters exactly s p substring start index which anagram substring start index which anagram s p substring start index which anagram substring start index which anagram substring start index which anagram s p consist lowercase english
number of arithmetic triplets strictly increasing integer array nums positive integer triplet arithmetic triplet following conditions i j unique arithmetic nums diff arithmetic triplet because both arithmetic triplet because both nums diff arithmetic triplet because both arithmetic triplet because both diff nums strictly
increasing order search tree root binary search rearrange tree so leftmost node tree now root every node no left child only one right root root nodes tree range
add one row to tree root binary tree two integers val add row nodes value val depth note root node depth adding rule integer each not null tree node cur depth depth create two tree nodes value val left subtree root right subtree original left subtree should left subtree new left subtree original right subtree should right subtree new right subtree depth means there no depth depth then create tree node value val new root whole original original tree new left root val depth root val depth nodes tree range depth tree range val depth depth tree
adding two negabinary numbers two numbers base result adding them each array array most significant bit least significant arr represents arr format also guaranteed have no leading either arr or result adding same array no leading represents represents output represents or have no leading zeros
word search m x grid characters board string true word exists word can constructed letters sequentially adjacent where adjacent cells horizontally or vertically same letter cell may not used more than board word true board word true board word false m board word consists only lowercase uppercase english follow could use search pruning make your solution faster larger
tree node sql schema tree column name type id int int id primary key column this each row this table contains information about id node id parent node structure always valid each node tree can one three node leaf node root node neither leaf node nor root write sql query report type each node result table any query result format following tree id null id type root inner leaf leaf leaf node root node because parent node null child nodes node inner node because parent node child node nodes leaf nodes because they have parent nodes they do not have child tree id null id type root there only one node only need output root
prison cells after n days there prison cells row each cell either occupied or each whether cell occupied or vacant changes according following cell two adjacent neighbors both occupied or both then cell becomes becomes note because prison first last cells row have two adjacent integer array cells where ith cell occupied ith cell integer state prison after days such changes described cells following table summarizes state prison each day day day day day day day day cells either or
minimum number of increments on subarrays to form a target array integer array have integer array initial same size target all elements initially one operation can choose any subarray initial increment each value minimum operations form target array test cases generated so answer fits target we need least operations form target array initial increment index increment index increment index target array target target
cherry pickup ii rows x cols matrix grid representing field cherries where represents cherries can collect have two robots can collect cherries robot located corner robot located corner cols maximum cherries collection using both robots following rules cell robots can move cell j or j when any robot passes through picks up all cell becomes empty when both robots stay same only one takes both robots cannot move outside grid any both robots should reach bottom row grid path robot described color green blue cherries taken robot cherries taken robot total grid path robot described color green blue cherries taken robot cherries taken robot total rows cols cols
number of provinces there some them while some city connected directly city city b connected directly city then city connected indirectly city province group directly or indirectly connected cities no other cities outside x matrix isconnected where ith city jth city directly total isconnected isconnected or
integer replacement positive integer can apply one following replace replace either or minimum operations needed become or
minimum initial energy to finish tasks array tasks where actuali actual amount energy spend finish ith minimumi minimum amount energy require begin ith task your current energy cannot start this your current energy can complete this your energy after finishing can finish tasks any order minimum initial amount energy need finish all tasks starting we finish tasks following now energy now energy now energy notice even though we have leftover starting energy does not work because we cannot do tasks starting we finish tasks following now energy now energy now energy now energy now energy tasks starting we finish tasks following now energy now energy now energy now energy now energy now energy actuali minimumi
shopping offers leetcode there items each item there some special special offer consists one or more different kinds items sale integer array price where price ith integer array needs where pieces ith item want also array special where size where pieces jth item ith offer last integer price ith lowest price have pay exactly certain items where could make optimal use special not allowed buy more items than even would lower overall could use any special offers many times price special needs there two kinds their prices special offer can pay special offer can pay need buy so may pay offer price special needs price may pay need buy so may pay offer cannot add more though only
russian doll envelopes array integers envelopes where represents width height one envelope can fit into another only both width height one envelope greater than other width maximum envelopes can russian doll put one inside cannot rotate envelopes maximum envelopes can russian doll envelopes hi
count sub islands two m x binary matrices containing only island group connected or any cells outside grid considered water island considered there island contains all cells make up this island islands considered picture grid left grid right colored red those considered part there three picture grid left grid right colored red those considered part there two m either or
sum of even numbers after queries integer array nums array queries where each query apply then print sum even values integer array answer where answer ith nums queries array after adding array sum even values after adding array sum even values after adding array sum even values after adding array sum even values nums queries vali indexi
number of pairs of interchangeable rectangles rectangles represented integer array where denotes width height ith two rectangles i j considered interchangeable they have same more two rectangles interchangeable decimal not integer pairs interchangeable rectangles rectangles following interchangeable pairs rectangles index rectangle rectangle rectangle rectangle rectangle rectangle rectangle rectangle rectangle rectangle rectangle rectangle rectangles there no interchangeable pairs heighti
race car your car starts position speed infinite your car can go into negative your car drives automatically according sequence instructions when get instruction your car does position speed speed when get instruction your car does your speed positive then speed otherwise speed your position stays after commands your car goes positions your speed goes target position length shortest sequence instructions get target shortest instruction sequence your position goes target shortest instruction sequence your position goes target
word pattern pattern string find s follows same here follow means full such there bijection between letter pattern word pattern s cat cat true pattern s cat cat false pattern s cat cat false pattern contains only english s contains only lowercase english letters spaces s does not contain any leading or trailing all words s separated single
sum of root to leaf binary numbers root binary tree where each node value or each path represents binary starting most significant path then this could represent which all leaves consider numbers represented path root sum these test cases generated so answer fits root root nodes tree range or
count words obtained after adding a letter two arrays strings startwords each string consists lowercase english letters each string check possible choose string startwords perform conversion operation equal conversion operation described following two append any lowercase letter not present string string letters or can added but not resulting string rearrange letters new string any arbitrary can rearranged so note can also rearranged strings targetwords can obtained performing operations any string note only verifying string targetwords can obtained string startwords performing strings startwords do not actually change during this startwords targetwords order form we use append rearrange there no string startwords can used obtain note does exist but we must append one letter string before rearranging order form we use append rearrange startwords targetwords order form we use add rearrange there no string startwords can used obtain each string startwords targetwords consists lowercase english letters no letter occurs more than once any string startwords or
design cancellable function sometimes have long running may wish cancel before help this write function cancellable accepts generator object returns array two cancel function may assume generator function only yield your responsibility pass values resolved promise back promise your function should throw error back cancel callback called before generator your function should throw error back error should string error error returned promise should resolve next value yielded or promise should reject thrown no more code should when generator promise your function returned should resolve value generator generator throws returned promise should reject how your code would const val yield new yield new val calculation const logs instead not called or called after promise would have resolved generatorfunction cancelledat const generator const resolves generator immediately yields because returned promise immediately resolves note cancelling finished generator does generatorfunction const msg yield new throw cancelledat null promise function handles this waiting resolve then passes resolved value back then error thrown which effect causing promise reject same thrown generatorfunction yield new cancelledat while function waiting yielded promise this causes error message sent back since this error returned promise rejected this generatorfunction let result yield new result yield new yield new result yield new cancelledat null promises two those promises have their values added after generator finishes value value resolved returned generatorfunction let result try yield new result yield new yield new result yield new cancelledat first two yielded promises resolve cause result generator error sent generator caught result returned finally resolved returned generatorfunction try yield new let yield new let b yield new cancelledat null first yielded promise immediately this error because generator been execution continues ends up resolving cancelledat null or cancelledat generatorfunction returns generator object
last day where you can still cross there binary matrix where represents land represents integers row col representing rows columns initially day entire matrix each day new cell becomes flooded array where represents ith cell rith row cith column covered water changed want find last day possible walk top bottom only walking land can start any cell top row end any cell bottom can only travel four cardinal directions last day where possible walk top bottom only walking land row col cells above image depicts how matrix changes each day starting day last day where possible cross top bottom day row col cells above image depicts how matrix changes each day starting day last day where possible cross top bottom day row col cells above image depicts how matrix changes each day starting day last day where possible cross top bottom day col row col row col ri row ci col all values cells
minimum difficulty of a job schedule want schedule list jobs d jobs dependent work ith have finish all jobs j where j have finish least one task every difficulty job schedule sum difficulties each day d difficulty day maximum difficulty job done integer array jobdifficulty integer difficulty ith job minimum difficulty job cannot find schedule jobs jobdifficulty d first day can finish first total difficulty second day can finish last total difficulty difficulty schedule jobdifficulty d finish job per day still have free cannot find schedule jobdifficulty d schedule one job per total difficulty d
maximum sum with exactly k elements integer array nums integer your task perform following operation exactly k times order maximize your select element m remove selected element m add new element value m increase your score maximum score can achieve after performing operation exactly k nums k we need choose exactly elements nums maximize first we choose then sum nums second we choose then sum nums third we choose then sum nums we can maximum answer we can nums k we need choose exactly elements nums maximize first we choose then sum nums second we choose then sum nums we can maximum answer we can k
make costs of paths equal in a binary tree integer representing nodes perfect binary tree consisting nodes numbered root tree node each node i tree two children where left child node i right child i each node tree also cost represented integer array cost size where cost node i allowed increment cost any node any minimum increments need make cost paths root each leaf node perfect binary tree tree where each except leaf exactly cost path sum costs nodes cost we can do following increase cost node one increase cost node three increase cost node two each path root leaf have total cost total increments we did can shown this minimum answer we can cost two paths already have equal total so no increments power
two best non-overlapping events integer array events where ith event starts starttimei ends attend this receive value can choose most two events attend such sum their values this maximum note start time end time cannot attend two events where one them starts other ends same more attend event end time next event must start or after t events choose green sum events choose event sum events choose events sum starttimei endtimei valuei
partition to k equal sum subsets integer array nums integer true possible divide this array into k subsets whose sums all nums k true possible divide into subsets equal nums k false k frequency each element range
escape the ghosts playing simplified game infinite start point destination point target trying get there several ghosts map their starting positions array where represents starting position ith all inputs integral each all ghosts may independently choose either move unit any four cardinal or or stay all actions happen escape only can reach target before any ghost reaches reach any square same time does not count true possible escape regardless how ghosts otherwise ghosts target true can reach destination after while ghosts located cannot catch up ghosts target false need reach destination but ghost lies between ghosts target false ghost can reach target same time yi there can multiple ghosts same ytarget
jump game iv array integers initially positioned first index one step can jump index i i i i i j i minimum steps reach last index notice can not jump outside array any arr need three jumps index note index last index arr start index last do not need arr can jump directly index index which last index
process tasks using servers two integer arrays servers tasks lengths m weight ith time needed process jth task tasks assigned servers using task all servers queue second jth task inserted into queue task being inserted second long there free servers queue not task front queue assigned free server smallest case assigned free server smallest there no free servers queue not we wait until server becomes free immediately assign next multiple servers become free same then multiple tasks queue assigned order insertion following weight index priorities server assigned task j second t free again second t build array ans length where index server jth task assigned array servers tasks events chronological order go second task added processed using server until second second server becomes task added processed using server until second second task added processed using server until second second server becomes task added processed using server until second second task added processed using server until second second all servers become task added processed using server until second servers tasks events chronological order go second task added processed using server until second second task added processed using server until second second servers become task added processed using server until second second task added processed using server until second second server becomes task added processed using server until second second task added processed using server until second second task added processed using server until second m m
string compression array characters compress using following begin empty string each group consecutive repeating characters length append character append character followed compressed string s should not returned but stored input character array note group lengths or longer split into multiple characters after done modifying input new length must write algorithm uses only constant extra chars first characters input array should groups this compresses chars first character input array should only group which remains uncompressed since single chars first characters input array should groups this compresses lowercase english uppercase english or
fix names in a table sql schema users column name type int name varchar primary key this this table contains id name name consists only lowercase uppercase write sql query fix names so only first character uppercase rest result table ordered query result format following users name alice bob name alice bob
palindrome number integer true x palindrome false x true reads left right right x false left reads right becomes therefore not x false reads right therefore not x follow could solve without converting integer
is subsequence two strings s true s subsequence or false subsequence string new string formed original string deleting some characters without disturbing relative positions remaining subsequence while s t true s t false s t consist only lowercase english follow suppose there lots incoming say sk where k want check one one see t this how would change your
intersection of multiple arrays integer array nums where array distinct positive list integers present each array nums sorted ascending nums only integers present each so we nums there does not exist any integer present both so we empty list all values
rearranging fruits have two fruit baskets containing fruits two integer arrays representing cost fruit each want make both baskets do can use following operation many times chose two indices i swap ith fruit jth fruit cost swap two baskets considered equal sorting them according fruit cost makes them exactly same minimum cost make both baskets equal or swap index index which cost now rearranging both arrays makes them can shown impossible make both baskets
array partition integer array nums group these integers into pairs such sum all i maximized nums all possible pairings ordering so maximum possible sum nums optimal pairing
self dividing numbers divisible every digit because not allowed contain digit two integers left list all numbers range left right left right left right
delete columns to make sorted ii array strings all same we may choose any deletion we delete all characters those indices each we have strs deletion indices then final array after deletions suppose we chose set deletion indices answer such after final array elements lexicographic order minimum possible value strs after deleting first strs now strs lexicographic order we require least deletion since initially strs not lexicographic so answer strs strs already lexicographic so we do not need delete note rows strs not necessarily lexicographic not necessarily true strs we have delete every consists lowercase english
the k strongest values in an array array integers arr integer value said stronger than value where m median then said stronger than list strongest k values answer any arbitrary median middle value ordered integer more length list median element position sorted list arr median obtained sorting array arr median where m median arr median obtained sorting array arr median where m median arr k median elements array sorted strongest strongest elements also accepted please note although but stronger than because arr k median elements array sorted strongest strongest elements arr k median elements array sorted strongest any permutation k
uncrossed lines two integer arrays we write integers order they two separate horizontal we may draw connecting straight line connecting two numbers such line we draw does not intersect any other connecting note connecting line cannot intersect even endpoints each can only belong one connecting maximum connecting lines we can draw this we can draw uncrossed lines we cannot draw uncrossed because line intersect line
find the highest altitude there biker going road road trip consists points different biker starts his trip point altitude equal integer array gain length where net gain altitude between points i i all i highest altitude gain altitudes highest gain altitudes highest
random pick index integer array nums possible randomly output index target can assume target must exist implement solution initializes object array int picks random index i nums where there multiple valid then each index should have equal probability input output explanation solution solution new should either index or each index should have equal probability should since array only equal should either index or each index should have equal probability target integer most calls made
longest substring of all vowels in order string considered beautiful satisfies following each english vowels must appear least once letters must sorted alphabetical order all before all before strings considered but not string word consisting english length longest beautiful substring no such substring substring contiguous sequence characters word longest beautiful substring word length word longest beautiful substring word length word there no beautiful so word consists characters
sum of all odd length subarrays array positive integers sum all possible subarrays subarray contiguous subsequence arr subarrays arr their sums we add all these together we get arr there only subarrays odd their sum arr follow could solve this problem time
fruit into baskets visiting farm single row fruit trees arranged left trees represented integer array fruits where type fruit ith tree want collect much fruit owner some strict rules must only have two each basket can only hold single type there no limit amount fruit each basket can starting any tree your must pick exactly one fruit every tree start while moving picked fruits must fit one your once reach tree fruit cannot fit your must integer array maximum fruits can fruits we can pick all fruits we can pick trees we had started first we would only pick trees fruits we can pick trees we had started first we would only pick trees
find a peak element ii peak element grid element strictly greater than all adjacent neighbors m x matrix mat where no two adjacent cells find any peak element length array may assume entire matrix surrounded outer perimeter value each must write algorithm runs or mat both peak elements so both acceptable mat both peak elements so both acceptable m no two adjacent cells
flatten nested list iterator nested list integers each element either integer or list whose elements may also integers or other implement iterator flatten implement nestediterator initializes iterator nested list int returns next integer nested boolean returns true there still some integers nested list false your code tested following initialize iterator nestedlist res while append end res res res matches expected flattened then your code judged nestedlist calling next repeatedly until hasnext returns order elements returned next should nestedlist calling next repeatedly until hasnext returns order elements returned next should values integers nested list range
tag validator string representing code implement tag validator parse code whether code snippet valid all following rules code must wrapped valid closed code closed tag necessarily exactly following format among start end start end tags should closed tag valid only valid only contain length range valid may contain other valid closed cdata any characters except unmatched unmatched start end unmatched or closed tags invalid start tag unmatched no end tag exists same vice also need consider issue unbalanced when tags unmatched cannot find subsequent when find or all subsequent characters until next should parsed necessarily cdata following format range defined characters between first subsequent may contain any function cdata forbid validator parse so even some characters can parsed tag matter valid or should treat regular code first line true code wrapped closed tag consists some characters although unmatched start tag invalid should considered plain not parsed so then code thus code true we first separate code into could also separated into cdata where reason why not because rule reason why cdata not because rule code false then must vice code consists english
bulls and cows playing bulls cows game your write down secret ask your friend guess what when your friend makes provide hint following which digits guess correct which digits guess your secret but located wrong digits guess could rearranged such they become secret secret your guess hint your hint should formatted where x bulls y note both secret guess may contain duplicate secret guess bulls connected cows secret guess bulls connected cows or note only one two unmatched counted cow since digits can only rearranged allow one secret guess consist digits
minimum interval to include each query integer array where describes ith interval starting lefti ending righti size interval defined integers or more formally righti lefti also integer array answer jth query size smallest interval i such lefti no such interval answer array containing answers intervals queries queries processed query interval smallest interval containing answer query interval smallest interval containing answer query interval smallest interval containing answer query interval smallest interval containing answer intervals queries queries processed query interval smallest interval containing answer query none intervals contain answer query interval smallest interval containing answer query interval smallest interval containing answer lefti righti
insert delete getrandom o(1) implement randomizedset initializes randomizedset bool inserts item val into set not returns true item not false bool removes item val set returns true item false int returns random element current set elements guaranteed least one element exists when this method each element must have same probability being must implement functions class such each function works average time input output explanation randomizedset randomizedset new inserts returns true inserted returns false does not exist inserts returns set now contains should either or removes returns set now contains already so since only always val most calls made there least one element data structure when getrandom
flip string to monotone increasing binary string monotone increasing consists some followed some possibly binary string can flip changing or minimum flips make s monotone s we flip last digit get s we flip get or alternatively s we flip get either or
find all k-distant indices in an array integer array nums two integers key index index i nums which there exists least one index j such k list all indices sorted increasing nums key k key index k so there no j where k not index k so index k so index k so index k so index k so index k so we which sorted increasing nums key k all indices i there exists some index j such k so every index we key integer array k
average waiting time there restaurant single array where arrivali arrival time ith arrival times sorted timei time needed prepare order ith when customer gives chef his chef starts preparing once customer waits till chef finishes preparing his chef does not prepare food more than one customer chef prepares food customers order they average waiting time all solutions within actual answer considered customers first customer arrives time chef takes his order starts preparing immediately time finishes time so waiting time first customer second customer arrives time chef takes his order starts preparing time finishes time so waiting time second customer third customer arrives time chef takes his order starts preparing time finishes time so waiting time third customer so average waiting time customers first customer arrives time chef takes his order starts preparing immediately time finishes time so waiting time first customer second customer arrives time chef takes his order starts preparing time finishes time so waiting time second customer third customer arrives time chef takes his order starts preparing time finishes time so waiting time third customer fourth customer arrives time chef takes his order starts preparing immediately time finishes time so waiting time fourth customer so average waiting time timei arrivali
n-queens puzzle problem placing queens x chessboard such no two queens attack each integer all distinct solutions may answer any each solution contains distinct board configuration where both indicate queen empty there exist two distinct solutions puzzle shown above
sum game alice bob take turns playing alice starting string num even length consisting digits each player do following there still least one choose index i where replace any digit between game ends when there no more characters bob sum digits first half num must equal sum digits second alice sums must not game ended num then bob wins because game ended num then alice wins because assuming alice bob play true alice win false bob num false there no moves sum first half equal sum second num true alice can replace one impossible bob make sums num false can proven bob always one possible outcome alice replaces first num bob replaces one right half num alice replaces one right half num bob replaces last right half num bob wins because num consists only digits
design skiplist design skiplist without using any skiplist data structure takes time erase comparing treap tree which same function code length skiplist can comparatively short idea behind skiplists just simple linked we have skiplist containing we want add into skiplist works this artyom kalinin via wikimedia commons can see there many layers each layer sorted linked help top erase search can faster than can proven average time complexity each operation space complexity see more about implement skiplist initializes object bool returns true integer target exists skiplist or false void inserts value num into bool removes value num skiplist returns num does not exist do nothing there exist multiple num removing any one them note duplicates may exist your code needs handle this input output explanation skiplist skiplist new false true not true already been target most calls made
min cost to connect all points array points representing integer coordinates some points where cost connecting two points manhattan distance between where denotes absolute value minimum cost make all points all points connected there exactly one simple path between any two points we can connect points shown above get minimum cost notice there unique path between every pair points yi all pairs
cat and mouse ii game played cat mouse named cat environment represented grid size rows x where each element player or players represented characters floors represented character can walked walls represented character cannot walked food represented character can walked there only one each character mouse cat play according following mouse moves then they take turns during each cat mouse can jump one four directions they cannot jump over wall nor outside mousejump maximum lengths cat mouse can jump cat mouse can jump less than maximum staying same position mouse can jump over game can end cat occupies same position cat cat reaches food cat mouse reaches food mouse mouse cannot get food within cat rows x cols matrix grid two integers catjump true mouse can win game both cat mouse play otherwise grid catjump mousejump true cat cannot catch mouse turn nor can get food before grid catjump mousejump true grid catjump mousejump false rows cols cols consist only characters there only one each character mousejump
maximum genetic difference query there rooted tree consisting nodes numbered each denotes unique genetic value genetic value node x genetic difference between two genetic values defined their integer array where parent node node x root then also array queries where each query find maximum genetic difference between vali where pi genetic value any node path between nodei root nodei more want maximize vali xor array ans where answer ith parents queries queries processed node maximum genetic difference difference xor node maximum genetic difference difference xor node maximum genetic difference difference xor parents queries queries processed node maximum genetic difference difference xor node maximum genetic difference difference xor node maximum genetic difference difference xor every node i not nodei vali
check if every row and column contains all numbers x matrix valid every row every column contains all integers x integer matrix true matrix matrix true this every row column contains numbers we matrix false this but first row first column do not contain numbers or we
redundant connection this tree undirected graph connected no graph started tree nodes labeled one additional edge added edge two different vertices chosen not edge already graph represented array edges length where indicates there edge between nodes ai bi edge can removed so resulting graph tree there multiple answer occurs last edges edges ai bi ai bi there no repeated graph
determine if two strings are close two strings considered close can attain one other using following operation swap any two existing abcde aecdb operation transform every occurrence one existing character into another existing do same other aacabb bbcbaa turn into all turn into can use operations either string many times two true false true can attain apply operation apply operation false impossible attain or vice any true can attain apply operation apply operation apply operation contain only lowercase english
wiggle sort ii integer array reorder such may assume input array always valid nums also nums guaranteed there answer input follow can do time extra
brace expansion ii under grammar strings can represent set lowercase let denote set words expression grammar can best understood through simple single letters represent singleton set containing when we take list two or more we take union final set only contains each word most when we concatenate two we take set possible concatenations between two words where first word comes first expression second word comes second three rules our every lowercase letter we have expressions ek k we have expressions we have b where denotes denotes cartesian expression representing set words under sorted list words expression expression expression each distinct word written only once final consists lowercase english expression represents set words based grammar
number of rectangles that can form the largest square array rectangles where represents ith rectangle length li width can cut ith rectangle form square side length k both k li k have rectangle can cut get square side length most let maxlen side length largest square can obtain any rectangles can make square side length rectangles largest squares can get each rectangle lengths largest possible square length can get out rectangles wi li wi
minimum jumps to reach home certain home position help them get there position bug jumps according following can jump exactly positions forward can jump exactly b positions backward cannot jump backward twice cannot jump any forbidden bug may jump forward beyond but cannot jump positions numbered negative array integers where means bug cannot jump position integers minimum jumps needed bug reach there no possible sequence jumps lands bug position forbidden b x jumps forward get bug forbidden b x forbidden b x one jump forward then one jump backward get bug x all elements forbidden position x not
minimum number of days to disconnect island m x binary grid grid where represents land represents island maximal or connected group grid said connected we have exactly one otherwise said one we allowed change any single land cell into water cell minimum days disconnect grid we need least days get disconnected change land water get disconnected grid grid full water also disconnected m either or
number of excellent pairs positive integer array nums positive integer pair numbers called excellent following conditions both numbers exist array sum set bits or greater than or equal where or bitwise or operation bitwise distinct excellent two pairs considered distinct either c or b note pair such can also excellent have least one occurrence nums k excellent pairs or both equal total set bits which greater than or equal k equal or equal total set bits equal or equal total set bits so excellent pairs nums k there no excellent pairs this k
delete and earn integer array want maximize points get performing following operation any pick any delete earn must delete every element equal every element equal maximum points can earn applying above operation some nums can perform following delete earn also nums delete earn nums earn total nums can perform following delete earn all also nums delete again earn nums delete once more earn nums earn total
count different palindromic subsequences string different palindromic subsequences since answer may very modulo subsequence string obtained deleting zero or more characters sequence palindromic equal sequence two sequences different there some i which ai s different palindromic subsequences note counted only even though occurs s there different palindromic which modulo either or
divisor game alice bob take turns playing alice starting there each player makes move consisting choosing any x x x replacing chalkboard player cannot make they lose true only alice wins assuming both players play true alice chooses bob no more false alice chooses bob chooses alice no more
count subarrays with median k array nums size consisting distinct integers positive integer subarrays nums have median equal median array middle element after sorting array ascending array even median left middle median median subarray contiguous part nums k subarrays have median equal nums k only subarray median equal k integers nums
function composition array functions new function fn function composition array function composition function composition empty list functions identity function may assume each function array accepts one integer input returns one integer functions x x x x x evaluating right left starting x functions x x x evaluating right left functions x composition zero functions identity function x all functions accept single integer
split array into fibonacci sequence string digits such we can split into sequence sequence list f integers such each integer fits signed integer all i note when splitting string into each piece must not have extra leading except piece any sequence split or cannot num output would also num task num leading zeroes not so not num contains only
count of range sum integer array nums two integers lower range sums lie range sum defined sum elements nums between indices i j where i nums lower upper three ranges their respective sums nums lower upper lower upper answer guaranteed fit
cousins in binary tree root binary tree unique values values two different nodes tree x true nodes corresponding values x y tree or false two nodes binary tree cousins they have same depth different note binary root node depth children each depth k node depth k root x y false root x y true root x y false nodes tree range each node unique x y x y exist
sleep positive integer write asynchronous function sleeps millis can resolve any millis should promise resolves after let t millis should promise resolves after millis
remove zero sum consecutive nodes from linked list head linked we repeatedly delete consecutive sequences nodes sum until there no such after doing head final linked may any such examples all sequences serializations listnode head answer would also head head linked list contain between each node linked list
set matrix zeroes m x integer matrix element set entire row column must do matrix matrix m follow straightforward solution using space probably bad simple improvement uses but still not best could devise constant space
reorder data in log files array each log string where first word there two types all words consist lowercase english all words consist reorder these logs so come before all sorted lexicographically their their contents then sort them lexicographically their maintain their relative final order logs art own kit art art art own kit contents all so their ordering kit have relative order logs act off key act act act off key all tokens separated single guaranteed have identifier least one word after
insert into a binary search tree root node binary search tree value insert into root node bst after guaranteed new value does not exist original notice there may exist multiple valid ways long tree remains bst after can any root val another accepted tree root val root val nodes tree range all values val guaranteed val does not exist original
